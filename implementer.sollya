/*
 * Copyright 2008-2011 by 
 * 
 * Laboratoire de l'Informatique du ParallÃ©lisme, 
 * UMR CNRS - ENS Lyon - UCB Lyon 1 - INRIA 5668
 *
 * and by
 *
 * Laboratoire d'Informatique de Paris 6, equipe PEQUAN,
 * UPMC Universite Paris 06 - CNRS - UMR 7606 - LIP6, Paris, France.
 *
 * Sollya metalibm main exploitation script for implementing functions 
 * with polynomial approximation and Horner scheme evaluation
 *
 * Contributor: Christoph Quirin Lauter (ENS Lyon/ UPMC LIP6 PEQUAN) 
 *              christoph.lauter@ens-lyon.org
 *
 * This file is part of the metalibm library developed by the Arenaire
 * project at Ecole Normale Superieure de Lyon and by the equipe PEQUAN
 * at Universite Pierre et Marie Curie Paris 6.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or 
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
*/

roundingwarnings=off!;
prec = 350!;
verbosity = 0!;

/* --------------------------------------------------------
   Read in configuration
----------------------------------------------------------- */ 

execute("config.sollya");

/* --------------------------------------------------------
   Load implementer
----------------------------------------------------------- */ 

execute("implement.sollya");

/* --------------------------------------------------------
   Read in problem to implement 
----------------------------------------------------------- */ 

execute("problemdef.sollya");

/* -------------------------------------------------------- 
   Put additional configuration data here
----------------------------------------------------------- */ 

variableFormat = DD;

doplots = true;
dotiming = true;

iterations = 1b11;	

trim = 1/2;

polynomialName = "f_approx";
gappaOutputTmpFile = "gappaOutput.sollya";
compiledCode = "implementation.so";

/* -------------------------------------------------------- 
   Print out problem configuration 
----------------------------------------------------------- */ 

if ((variableFormat == TD) && (target > 1b-103)) then { print("Warning: reduced format of variable"); variableFormat = DD; };
if ((variableFormat == DD) && (target > 1b-52)) then { print("Warning: reduced format of variable"); variableFormat = D; };

write("The function to be implemented is: ",f,"\n");
write("The domain is: ",dom,"\n");
write("The target error is ",target," = 2^(",round(log2(abs(target)),12,RN),")\n");

/* -------------------------------------------------------- 
   Launch implementer
----------------------------------------------------------- */ 

problemdef.func = f;
problemdef.dom = dom;
problemdef.target = trim * target;
problemdef.variableFormat = variableFormat;

parametrization.maxDegree = maxDegree;
parametrization.minWidth = minWidth;
parametrization.tableIndexWidth = tableIndexWidth;
parametrization.beta = trim + trim + trim * trim;
parametrization.implementationFile = implementationFile;
parametrization.gappaFile = gappaFile;
parametrization.gappaOutputFile = gappaOutputTmpFile;
parametrization.gappaExecutable = gappaExecutable;
parametrization.functionBasename = polynomialName;


resultat = tryImplementation(problemdef, parametrization);

/* -------------------------------------------------------- 
   Print out results of the implementer, do timing and plotting
----------------------------------------------------------- */ 

write("\n");

if (resultat.okay) then write("Yippie! Everything worked fine.\n") else write("There has been some error. Check it out!\n");

sollyapath = sollyaPath;
if sollyapath[length(sollyapath)-1] != "/" then sollyapath = sollyapath @ "/";

if (resultat.okay) then {
   
   match (resultat) with 
         { .poly = default } : {
                                  write("The implemented polynomial is:\n\t");
                                  printexpansion(resultat.poly);
                               }
         default :             { 
                                  write("Argument reduction code implies use of more than one polynomial\n");
                               };
   
   if (variableFormat == D) then
	signature = "D_TO_"
   else
	if (variableFormat == DD) then
		signature = "DD_TO_"
	else 
		signature = "TD_TO_";
		
   signature = signature @ (match resultat.outputformat with 
                                  D       : ("D") 
                                  DD      : ("DD")
                                  TD      : ("TD")
                                  default : ("")); 

   bashexecute(sollyapath@"compile.sh "@sollyapath@" "@implementationFile@" "@signature@" "@resultat.functionname@" "@compiledCode);


   if (doplots) then {
      externalplotPrecision = 18;
      match (resultat) with 
            { .centerpoint = default } : {
                                             match (resultat) with 
                                                   { .poly = default } : {
                                 	                                     plot(resultat.poly/f(x + resultat.centerpoint) - 1, [inf(dom) - resultat.centerpoint; sup(dom) - resultat.centerpoint]);	    
                                                                         }
                                                   default :             {
                                                                             write("Argument reduction code implies use of more than one polynomial\n");
                                                                         };
                                             match (resultat) with 
                                                   { .poly = default, 
                                                     .pstar = default } : {
                                 	                                     plot(resultat.poly/f(x + resultat.centerpoint) - 1,resultat.pstar/f(x + resultat.centerpoint) - 1, [inf(dom) - resultat.centerpoint; sup(dom) - resultat.centerpoint]);	    
                                                                         }
                                                   default :             {
                                                                             write("Argument reduction code implies use of more than one polynomial and pstar\n");
                                                                         };
                                             match (resultat) with 
                                                   { .pstar = default } : {
                                					     plot(resultat.pstar/f(x + resultat.centerpoint) - 1, [inf(dom) - resultat.centerpoint; sup(dom) - resultat.centerpoint]);	    
                                                                         }
                                                   default :             {
                                                                             write("Argument reduction code implies use of more than one pstar\n");
                                                                         };

                                             if (resultat.centerpoint == 0) then externalplotPrecision = 12;
                                             if (0 in dom) then externalplotPrecision = 14;
                                             match (resultat) with 
                                                   { .poly = default } : {
                                                                             externalplot(sollyapath@compiledCode,relative,resultat.poly(x - resultat.centerpoint),dom,externalplotPrecision);
                                                                         }
                                                   default :             {
                                                                             write("Argument reduction code implies use of more than one polynomial\n");
                                                                         };
                                         }
            default :                    {
                                             write("Argument reduction code implies use of more than one centerpoint\n");
                                         };
       
       if (0 in dom) then externalplotPrecision = 14;
       externalplot(sollyapath@compiledCode,relative,f,dom,externalplotPrecision); 
   };

   resultfile = resumedImplementationFile;

   if (dotiming) then {

        externalproc(timefunc, sollyapath@compiledCode, (constant, constant, integer, integer) -> integer);

	evaltime = round(timefunc(inf(dom), sup(dom), 2000, iterations) / iterations, 12, RN);

	print("Time needed for evaluating the polynomial implemented:", evaltime,"time units");

   };

};
