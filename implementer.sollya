/*
 * Copyright 2008 by 
 * 
 * Laboratoire de l'Informatique du ParallÃ©lisme, 
 * UMR CNRS - ENS Lyon - UCB Lyon 1 - INRIA 5668
 *
 * Sollya metalibm main exploitation script for implementing functions 
 * with polynomial approximation and Horner scheme evaluation
 *
 * Contributor: Christoph Quirin Lauter (ENS Lyon) -- christoph.lauter@ens-lyon.fr
 *
 * This file is part of the metalibm library developed by the Arenaire
 * project at Ecole Normale Superieure de Lyon
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or 
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
*/

roundingwarnings=off!;
prec = 350!;
verbosity = 0!;

/* --------------------------------------------------------
   Read in configuration
----------------------------------------------------------- */ 

execute("config.sollya");

/* --------------------------------------------------------
   Load implementer
----------------------------------------------------------- */ 

execute("implement.sollya");

/* --------------------------------------------------------
   Read in problem to implement 
----------------------------------------------------------- */ 

execute("problemdef.sollya");

/* -------------------------------------------------------- 
   Put additional configuration data here
----------------------------------------------------------- */ 

variableFormat = D;

doplots = true;
dotiming = true;

iterations = 1b11;	

trim = 1/2;

polynomialName = "f_approx";
gappaOutputTmpFile = "gappaOutput.sollya";
compiledCode = "implementation.so";

/* -------------------------------------------------------- 
   Print out problem configuration 
----------------------------------------------------------- */ 

if ((variableFormat == TD) && (target > 1b-103)) then { print("Warning: reduced format of variable"); variableFormat = DD; };
if ((variableFormat == DD) && (target > 1b-52)) then { print("Warning: reduced format of variable"); variableFormat = D; };

write("The function to be implemented is: ",f,"\n");
write("The domain is: ",dom,"\n");
write("The target error is ",target," = 2^(",round(log2(abs(target)),12,RN),")\n");

/* -------------------------------------------------------- 
   Launch implementer
----------------------------------------------------------- */ 

resultat = implementsmallwithcentering(f, dom, trim * target, (trim + trim + trim * trim), variableFormat, implementationFile, gappaFile, 
                                       gappaOutputTmpFile,gappaExecutable,polynomialName);

/* -------------------------------------------------------- 
   Print out results of the implementer, do timing and plotting
----------------------------------------------------------- */ 

write("\n");

if (resultat.okay) then write("Yippie! Everything worked fine.\n") else write("There has been some error. Check it out!\n");

sollyapath = sollyaPath;
if sollyapath[length(sollyapath)-1] != "/" then sollyapath = sollyapath @ "/";

if (resultat.okay) then {
   
   write("The implemented polynomial is:\n\t");
   printexpansion(resultat.poly);
   
   if (variableFormat == D) then
	signature = "D_TO_"
   else
	if (variableFormat == DD) then
		signature = "DD_TO_"
	else 
		signature = "TD_TO_";
		
   signature = signature @ (match resultat.outputformat with 
                                  D       : ("D") 
                                  DD      : ("DD")
                                  TD      : ("TD")
                                  default : ("")); 

   bashexecute(sollyapath@"compile.sh "@sollyapath@" "@implementationFile@" "@signature@" "@resultat.functionname@" "@compiledCode);


   if (doplots) then {

      plot(resultat.poly/f(x + resultat.centerpoint) - 1, [inf(dom) - resultat.centerpoint; sup(dom) - resultat.centerpoint]);	    
      plot(resultat.pstar/f(x + resultat.centerpoint) - 1, [inf(dom) - resultat.centerpoint; sup(dom) - resultat.centerpoint]);	    
      plot(resultat.poly/f(x + resultat.centerpoint) - 1,resultat.pstar/f(x + resultat.centerpoint) - 1, [inf(dom) - resultat.centerpoint; sup(dom) - resultat.centerpoint]);	    

      externalplotPrecision = 12;
      if (resultat.centerpoint != 0) then externalplotPrecision = 18;
      externalplot(sollyapath@compiledCode,relative,resultat.poly(x - resultat.centerpoint),dom,externalplotPrecision);
      externalplot(sollyapath@compiledCode,relative,f,dom,externalplotPrecision);

   };

   resultfile = resumedImplementationFile;

   if (dotiming) then {

        externalproc(timefunc, sollyapath@compiledCode, (constant, constant, integer, integer) -> integer);

	evaltime = round(timefunc(inf(dom), sup(dom), 2000, iterations) / iterations, 12, RN);

	print("Time needed for evaluating the polynomial implemented:", evaltime,"time units");

	display = dyadic!;
	write("[|", f, ", ", resultat.centerpoint, ", ", resultat.poly, ", ", dom, ", ", target, ", ", round((1 + resultat.approxerr) * (1 + resultat.implerr) - 1,12,RD) , ", ", evaltime, "|],\n") >> resultfile; 
	display = default!;

   } else {

     	display = dyadic!;	
	write("[|", f, ", ", resultat.centerpoint, ", ", resultat.poly, ", ", dom, ", ", target, ", ", round((1 + resultat.approxerr) * (1 + resultat.implerr) - 1,12,RD) , ", ", infty, "|],\n") >> resultfile; 
	display = default!;

   };

};
