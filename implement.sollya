/*
 * Copyright 2008-2011 by 
 * 
 * Laboratoire de l'Informatique du ParallÃ©lisme, 
 * UMR CNRS - ENS Lyon - UCB Lyon 1 - INRIA 5668
 *
 * and by
 *
 * Laboratoire d'Informatique de Paris 6, equipe PEQUAN,
 * UPMC Universite Paris 06 - CNRS - UMR 7606 - LIP6, Paris, France.
 *
 * Sollya metalibm main procedures for implementing functions 
 * with polynomial approximation and Horner scheme evaluation
 *
 * Contributor: Christoph Quirin Lauter (ENS Lyon/ UPMC LIP6 PEQUAN) 
 *              christoph.lauter@ens-lyon.org
 *
 * This file is part of the metalibm library developed by the Arenaire
 * project at Ecole Normale Superieure de Lyon and by the equipe PEQUAN
 * at Universite Pierre et Marie Curie Paris 6.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or 
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
*/

execute("remezwrapper.sollya");
execute("upperbounds.sollya");
execute("vandercoeff.sollya");
execute("fpminimax.sollya");
execute("galoptimisation.sollya");
execute("symetries.sollya");


procedure myfindzeros(func,dom) {
	  var zeros, numZeros, nz, minBound, maxBound, i, len, dist, z;
	  var oldPoints, valid, ya, yb;

	  oldPoints = points;
	  points = 1001!;
	  
	  numZeros = dirtyfindzeros(func,dom);
	  len = length(numZeros);
	  zeros = [||];
	  if ((len > 0) && (len < 500)) then {
	     	  dist = ((sup(dom) - inf(dom)) * diam)/2;
	  	  minBound = inf(dom);
	  	  for i from 0 to len-1 do {
		      if (i != len-1) then {
		      	maxBound = numZeros[i + 1] - dist;
		      } else {
		      	maxBound = sup(dom);
		      };
		      nz = numZeros[i];
		      z = [ max(minBound, nz - dist) ; min(maxBound, nz + dist) ];
		      zeros = zeros :. z;
		      minBound = maxBound;
	  	  };
		  valid = true;
		  for z in zeros do {
		      ya = mid(evaluate(func,inf(z)));
		      yb = mid(evaluate(func,sup(z)));
		      if (ya * yb > 0) then {
		      	 valid = false;
		      };
		  };
		  if (!valid) then {
		     zeros = findzeros(func,dom);
		  };
          } else {
	    	  if (len >= 500) then {
		    zeros = findzeros(func,dom);
		  } else {
		    zeros = [||];
		  };
	  };

	  points = oldPoints!;

	  return zeros;
};


/* Quickly checks if the infinite norm of func 
   in dom is less than target 

   Returns false if it is not
   Returns the infinite norm if it is

*/
procedure dirtycheckinfnorm(func,dom,target) {
	  var t, b, h, y, maxy;
	  var oldprec;
	  var res;
	  var infn;

	  oldprec = prec = ?;
	  prec = 20!;
	  t = inf(dom);
	  b = sup(dom);
	  h = round((b - t) / 64,12,RU);
	  maxy = 0; 
	  while ((t <= b) && (maxy <= target)) do {
	  	maxy := abs(func(t));
		t = round(t + h,12,RU);
	  };
	  prec = oldprec!;
	  
	  if (maxy > target) then 
	      res = false 
	  else {
	       infn = dirtyinfnorm(func,dom);
	       if (infn > target) then {
	       	  write("Warning: dirtycheckinfnorm decides false case by dirtyinfnorm\n");
	       	  res = false; 
	       } else res = infn;
 	  };

	  return res;
};


/* implementandcheck

   implements a polynomial in a domain for a given target error 
   and checks whether the overall error is less than the target error

   approxerr may be false, in which case the procedure computes the infnorm

   Returns a list containing a boolean (works or not), a polynomial (the implemented one if works), an approx error and an evaluation error.

   The procedure may return false for problems with the implementation

*/
procedure implementandcheck(func,poly,dom,targeterr,targeterrimpl,approxerr,beta,variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName) {
	  var res;
	  var myapproxerr;
	  var q;
	  var implapproxerr;
	  var boundsList;
	  var evalerr;
	  var i;
	  var oldverb;

	  q = poly;
	  
	  if (approxerr == false) then {
	    myapproxerr = dirtyinfnorm(poly/func-1,dom);
	  } else {
	    myapproxerr = approxerr;
	  };
	  implapproxerr = myapproxerr;
	  evalerr = false;

	  // myapproxerr, targeterr;

	  res = (myapproxerr < targeterr);
	  if (res) then {
	     	q = implementpoly(poly,dom,targeterrimpl,variableFormat,polynomialName,implementationFile,honorcoeffprec,gappaFile);
		if (!(q == q)) then {
		   write("Something strange happened. The implementpoly command did not succeed\n");
		   oldverb = verbosity = ?;
		   verbosity = 2!;
	     	   q = implementpoly(poly,dom,targeterrimpl,variableFormat,polynomialName,implementationFile,honorcoeffprec,gappaFile);
		   verbosity = oldverb!;
		   q = poly;
		};
		if (horner(q) == horner(poly)) then {
		   implapproxerr = myapproxerr;
		} else {
		   implapproxerr = dirtyinfnorm(q/func-1,dom);
		};
	        res = (implapproxerr < targeterr);		
		if (res) then {
		   	write("boundsList = [|") > gappaOutputFile;
			bashexecute(gappaExecutable@" < "@gappaFile@" 2>&1 | grep 'epsilon in' | sed -n 's/\\({[^}]*}\\)//g;p' | sed -n 's/epsilon in \\[//;p' | sed -n 's/\\]/,/;p' | sed -n 's/, /,\\n/;p' >> "@gappaOutputFile);
			print("0|];") >> gappaOutputFile;
			execute(gappaOutputFile);	
			evalerr = 0;
			for i in boundsList do if (abs(i) > evalerr) then evalerr = abs(i);			
			if (evalerr == 0) then evalerr := 1/0;
			write("\tGappa determined evaluation error = 2^(",round(log2(evalerr),12,RU),")\n");

			res = ((implapproxerr + evalerr + implapproxerr * evalerr) <= (targeterr * beta));
		};
	  };
	  
	  if (res) then res = [|true, q, implapproxerr, evalerr|] else res = [| false, q, implapproxerr, evalerr|];

	  return res;
};


/* configToNumber 

   Gives the number of a configuration under a permutation order

*/
procedure configToNumber(config,permut) {
	  var res, k, i, tt;

	  res = 0;
	  for k from length(config)-1 to 0 by -1 do {
	      i = config[permut[k]];
	      res = res * 3;
	      if (i == D) then
		tt = 0
	      else 
		if (i == DD) then
			tt = 1
		else 
			tt = 2;
	      res = res + tt;
	  };

	  return res;
};

/* numberToConfig

   Gives a configuration of a configuration number under a permutation order

*/
procedure numberToConfig(t,permut,numberMonomials) {
	var k, configur, j, dv, r, form;
	k = t;
	configur = [|1,...,numberMonomials|];
	j = 0;
	while (j < numberMonomials) do {
		dv := floor(k / 3);
		r := k - 3 * dv;
		if (r == 0) then
			form = D
		else 
			if (r == 1) then
				form = DD
			else 
				form = TD;
		configur[permut[j]] = form;
		k = dv;
		j := j + 1;
	};
	return configur;
};


procedure isHigherPrecisionConfig(config,bounds) {
	  var res;
	  var i, c, b;

	  if (length(config) != length(bounds)) then {
	     res = false;
	  } else {
	     res = true;
	     i = 0;
	     while ((i < length(bounds)) && res) do {
	     	   c = config[i];
		   b = bounds[i];
		   if (((c == D) && (b != D)) || ((c == DD) && (b == TD))) then res = false;
	     	   i := i + 1;
	     };
	  };
	  return res;
};

procedure isLowerPrecisionConfig(config,bounds) {
	  var res;
	  var i, c, b;

	  if (length(config) != length(bounds)) then {
	     res = false;
	  } else {
	     res = true;
	     i = 0;
	     while ((i < length(bounds)) && res) do {
	     	   c = config[i];
		   b = bounds[i];
		   if (((b == D) && (c != D)) || ((b == DD) && (c == TD))) then res = false;
	     	   i := i + 1;
	     };
	  };
	  return res;
};


procedure extraroundcoefficients(poly,monomials,configuration) {
	  var confli;
	  var i;

	  confli = [||];
	  for i from 0 to degree(poly) do confli = D.:confli;

	  for i from 0 to length(monomials) - 1 do {
	      confli[monomials[i]] = configuration[i];
	  };

	  return roundcoefficients(poly,confli);
};


/* implementconfigurations

   Based on func, pstar, lowerbounds, upperbounds and optimisationPermut
   tries to find the first polynomial in optimisationPermut order
   (with the least number of coefficients) that satisfies targeterr

   Uses fpminimax

   Returns [|true, poly, approxerr, implerr, pstar|] if a configuration has been found
   Returns [|false, bestpoly, bestapprox, bestimplerr, pstar |] if no configuration satisfies the target error
   Returns [|false, pstar, 0, 0, false, pstar|] if some other error occurs

*/
procedure implementconfigurations(func,pstar,dom,targeterr,beta,lowerbounds,upperbounds,optimisationPermut,
	                          variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName) {
          var ii;
	  var okay;
	  var numbercoefficients;
	  var res;
	  var approxerr;
	  var pointlist;
	  var d;
	  var monomials;
	  var symetrical;
	  var firstmonomial;
	  var bestpoly, bestapprox, bestimplerr;
	  var configuration;
	  var implresult;
	  var poly;
	  var targetlog;
	  var looparound, targeterrimpl;
	  var dci, dcii, polyRound;

	  okay = true;
	  numbercoefficients = 0;
	  for ii from 0 to degree(pstar) do if (coeff(pstar,ii) != 0) then numbercoefficients := numbercoefficients + 1;
	  if ((length(lowerbounds) != length(upperbounds)) || (numbercoefficients != length(lowerbounds))) then {
	     okay = false;
	     res = [| false, pstar, 0, 0, false, pstar |];
	  };

	  if (okay) then {
	     approxerr = dirtyinfnorm(pstar/func-1,dom);

	     monomials = [||];
	     for ii from 0 to degree(pstar) do 
	           if (coeff(pstar,ii) != 0) then monomials = monomials:.ii;
	     
	     symetrical = true;
	     ii := length(monomials) - 1;
	     firstmonomial = head(monomials);
	     while ((ii >= 0) && symetrical) do {
	  	if (floor((monomials[ii] + firstmonomial) / 2) * 2 != (monomials[ii] + firstmonomial)) then 
		   symetrical = false;
		ii := ii - 1;
	     };
	     if (symetrical) then {
	        if (-inf(dom) > sup(dom)) then 
		   d = [1b-1075, -inf(dom)]
	        else 
		   d = [1b-1075, sup(dom)];
	     } else {
	        d = dom;
	     };

	     pointlist = dirtyfindzeros(pstar/func-1,d);

	     firstConfigNumber = configToNumber(lowerbounds,optimisationPermut);
	     lastConfigNumber = configToNumber(upperbounds,optimisationPermut);
	     t = firstConfigNumber;
	     found = false;
	     bestpoly = 0;
	     bestimplerr = 1000;	
	     bestapproxerr = 1000;
	     ii = 1;
	     targetlog = round(log2(targeterr),12,RN);
	     while ((!found) && (t <= lastConfigNumber)) do {
	           // "Configuration t = ", t, ", lastConfigNumber = ", lastConfigNumber;
	     	   configuration = numberToConfig(t,optimisationPermut,numbercoefficients);
		   if (isHigherPrecisionConfig(configuration,lowerbounds) && isLowerPrecisionConfig(configuration,upperbounds)) then {
		      write("Trying configuration #",ii," ",configuration,":\n");

		      poly = fpminimaxwrapper(func,dom,monomials,pstar,pointlist,configuration);
		      
		      if (poly != false) then {
		      	        dci = dirtycheckinfnorm(poly/func-1,dom,targeterr); 
				if (dci == false) then {
				   polyRound = extraroundcoefficients(pstar,monomials,configuration);
				   dcii = dirtycheckinfnorm(polyRound/func-1,dom,targeterr);
				   if (dcii != false) then {
				      write("Warning: rounded Pstar better that fpminimax polynomial\n");
				      poly = polyRound;
				      dci = dcii;
				   };
				};
		      	       	if (dci != false) then {      	              
		      	       	      looparound = true;
				      targeterrimpl = targeterr;
				      while (looparound && (targeterrimpl >= targeterr/16)) do {
		      		      	    implresult = implementandcheck(func,poly,dom,targeterr,targeterrimpl,dci,beta,
									   variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName);

					    // implresult[0], implresult[3];				   
				            if (implresult[0]) then 
					       looparound = false
					    else {
					    	 if ((implresult[3] == false) || (implresult[3] == 1/0)) then 
						    looparound = false 
						 else 
						    targeterrimpl := targeterrimpl / 2;
					    };					    
				      };
                                      if (implresult[0]) then {
				            found = true;
                                            bestpoly = poly;
					    bestimplerr = implresult[3];
					    bestapproxerr = implresult[2];
					    
					    write("\tfound: target = 2^(",targetlog,"), approx = 2^(",round(log2(bestapproxerr),12,RU),"), evaluat = 2^(",
                                                  round(log2(bestimplerr),12,RU),"), overall = 2^(",
						  round(log2(bestimplerr + bestapproxerr + bestimplerr * bestapproxerr),12,RU),")");
			              } else {				      
				            if (implresult[2] < bestapproxerr) then {
					       bestpoly = poly;
					       bestapproxerr = implresult[2];
					       bestimplerr = implresult[3];
                                            };
				            write("\tunusable: target = 2^(",targetlog,"), approx = 2^(", 
                                                  round(log2(implresult[2]),12,RN),") (best approx = 2^(",
					          round(log2(bestapproxerr),12,RN),"))");
                                      };
                                } else {
				      write("\tunusable: target = 2^(",targetlog,")");
				};
		      } else {
		      	write("\tproblem with fpminimax");
		      };
		      write("\n");
		      ii := ii + 1;
		   };
	     	   t := t + 1;
	     };
	     res = [| found, bestpoly, bestapproxerr, bestimplerr, pstar |];
	  };

          return res;		    
};


/* implements a function by polynomial approximation in an interval centered in 0 

   Returns 

    [| true, poly, approxerr, implerr, pstar |] if everything is fine
    [| false, 0, 0, 0, 0 |] otherwise

    No test is made whether the interval is correctly centered in 0

*/
procedure implementcentered(func, dom, target, beta, variableFormat, galoptimizedMonomials, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName) {
	  var res;
	  var Pstar, upperbounds, lowerbounds, optimisationPermut;	  
	  var i, monomials;
	  var lowerboundsAndOptiPermut;
	  var k, l;

	  res = [| false, 0, 0, 0, 0 |];

	  Pstar = remezwrapper(func, dom, target, 3);

	  if (Pstar != false) then {
	  
		monomials = [||];
		for i from 0 to degree(Pstar) do {
		    if (coeff(Pstar,i) != 0) then monomials = monomials:.i;
		};

		upperbounds = determineupperbounds(Pstar, func, dom, target, variableFormat, implementationFile);

		lowerboundsAndOptiPermut = determinelowerbounds(Pstar, func, dom, target);


		if (lowerboundsAndOptiPermut == false) then {

          	        lowerbounds = [||];
	                for i in upperbounds do {
	                   if (i == D) then 
	                      lowerbounds = lowerbounds:.D
                           else
	                      if (i == DD) then 
		                 lowerbounds = lowerbounds:.D
	                      else 
                                 lowerbounds = lowerbounds:.DD;
                        };

                        optimisationPermut = [| 0, ..., length(upperbounds)-1 |];
                } else {
		        lowerbounds = lowerboundsAndOptiPermut[0];
			optimisationPermut = lowerboundsAndOptiPermut[1];
			
			for l from 0 to length(monomials) - 1 do {
			    if (listcontains(galoptimizedMonomials,monomials[l])) then {
			       lowerbounds[l] = D;
			    }; 
			};

                };

		if (length(lowerbounds) == length(upperbounds)) then {

		for k from 0 to length(lowerbounds) - 1 do {
		    if ((upperbounds[k] == D) && (lowerbounds[k] != D)) then upperbounds[k] = lowerbounds[k];
		    if ((upperbounds[k] == DD) && (lowerbounds[k] == TD)) then upperbounds[k] = lowerbounds[k];
		};

	        write("Chosen monomial base: ",monomials,"\n");
	        write("Lower bounds for precisions of coefficients: ",lowerbounds,"\n");
	        write("Upper bounds for precisions of coefficients: ",upperbounds,"\n");		
	        write("Optimisation permutation: ",optimisationPermut,"\n");
	        write("\n");

                res = implementconfigurations(func,Pstar,dom,target,beta,lowerbounds,upperbounds,optimisationPermut,
	                                      variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable, polynomialName);
		};
          };

	  return res;
};



/* implements a function by polynomial approximation in a small interval

   Returns 

    [| true, centerpoint, poly, approxerr, implerr |] if everything is fine
    [| false, 0, 0, 0, 0 |] otherwise

   The function to be implemented may have at most 1 zero in the domain.
   No test for this condition is made.

*/
procedure implementsmall(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName) {
	  var res;
	  var zerosInInterval, zerosInIntervalRaw, zr, midpoint, zerosInIntervalTemp, zerosInIntervalRaw2;
	  var smallestAbsZero;
	  var Pstar;
	  var okay;
	  var startmidpoint;
	  var shiftedFunc, shiftedDom;
	  var resImpl;
	  var oldprec, oldpoints, olddiam;
	  var galoptim;		  
	  var galoptimizedMonomials;

	  /* write("implementsmall(",func,",", dom,",", target,",", beta,",", variableFormat,",", implementationFile,",", gappaFile,",", gappaOutputFile,",", gappaExecutable,",", polynomialName,")\n"); */
	  
	  galoptimizedMonomials = [||];
	  okay = true;
	  
	  if (inf(dom) * sup(dom) >= 0) then {
	       zerosInInterval = [||];
	       oldprec = (prec = ?);
	       prec = oldprec * 3!;
	       oldpoints = (points = ?);
	       points = oldpoints * 6!;
	       olddiam = (diam = ?);
	       diam = olddiam / 1b8!;
 	       zerosInIntervalRaw2 = myfindzeros(func,dom);
	       zerosInIntervalRaw = [||];
	       for zr in zerosInIntervalRaw2 do 
	          zerosInIntervalRaw = zerosInIntervalRaw @(myfindzeros(func,zr));
	       for zr in zerosInIntervalRaw do 
	          zerosInInterval = zerosInInterval @ (dirtyfindzeros(func,zr));
	       prec = oldprec!;
	       points = oldpoints!;
	       diam = olddiam!;
	       zerosInIntervalTemp = sort(zerosInInterval);	  
	       zeroInInterval = [||];
	       for zr in zerosInIntervalTemp do zerosInInterval = zerosInInterval:.(mid(evaluate(D(x),zr)));
	       if (zerosInInterval != [||]) then {
	           smallestAbsZero = zerosInInterval[0];
	           for zr in zerosInInterval do 
	     	       if (abs(func(zr)) < abs(func(smallestAbsZero))) then smallestAbsZero = zr;
	           midpoint := D(smallestAbsZero);	 	 
	       } else {
	           symetrypoint = testEvenSymetry(func, dom, 1b-10);
		   if (symetrypoint != false) then {
		      write("Even symmetry dectected\n");
		      midpoint := D(symetrypoint);
		   } else {
		     if (target < 1b-50) then {
	              Pstar = simplifysafe(horner(simplifysafe(substitute(remezwrapper(func(x + D(mid(dom))), [inf(dom) - D(mid(dom));sup(dom) - D(mid(dom))], target, 3),(x - D(mid(dom)))))));
	              if (Pstar != false) then {
	                 startmidpoint := D(mid(dom));
			 galoptim = galoptimisation(Pstar,func,dom,target,startmidpoint);
	                 midpoint := D(galoptim[0]);
			 galoptimizedMonomials = galoptim[1];
	              } else {
	                 midpoint := D(mid(dom));
	              };
		      } else {
		      	 midpoint := D(mid(dom));
		      };
		   };
	       };

          } else {
	       midpoint = 0;
          };

	  if (okay) then {
	     write("Chosen midpoint = ",round(midpoint,53,RN)," = ");
	     printhexa(midpoint);
	     
	     shiftedFunc = horner(func(x + midpoint));
	     shiftedDom = [inf(dom) - midpoint ; sup(dom) - midpoint];

	     write("The translated function is f = ",shiftedFunc,"\n");
	     write("The translated domain is dom = ",shiftedDom,"\n");

	     resImpl = implementcentered(shiftedFunc, shiftedDom, target, beta, variableFormat, galoptimizedMonomials,
	                                 implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName);

	     res = [| resImpl[0], midpoint, resImpl[1], resImpl[2], resImpl[3], resImpl[4] |];				 

	  } else {
	    res = [| false, 0, 0, 0, 0, 0 |];
	  };

	  return res;
};

procedure implementShifter(centerPoint, dom, variableFormat, outputFormat, polynomialName, functionName, implementationFile) {
	  var res;
	  var shifterCode, oldDisplay;
	  var sterbenzOkay;

	  res = { .okay = false };

	  /* Check if centerPoint is a double precision number in the domain
             and if Sterbenz' lemma will be verified for the whole domain */
	  if ((D(centerPoint) - centerPoint == 0) && 
              (centerPoint in dom)) then {	      
              sterbenzOkay = (((inf(dom) * sup(dom) > 0) && (inf(dom) * centerPoint > 0)) && ((abs(inf(dom)) >= abs(centerPoint)/2) && (abs(sup(dom)) <= 2 * abs(centerPoint))));
	      if (sterbenzOkay) then {
               res.okay = true;
	       oldDisplay = display;
	       display = decimal!;
	       shifterCode = "\n\n#define " @ functionName @ "_centerpoint " @ centerPoint;
	       display = oldDisplay!;
	       shifterCode = shifterCode @ "\n\nvoid "@functionName@"(";
	       shifterCode = shifterCode @ (match outputFormat with 
                                                  D   : ( "double *res_resh, " )
                                                  DD  : ( "double *res_resh, double *res_resm, " )
                                                  TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                           );
               shifterCode = shifterCode @ (match variableFormat with 
                                                  D   : ( "double x" )
                                                  DD  : ( "double xh, double xm" )
                                                  TD  : ( "double xh, double xm, double xl" )
                                           );
               shifterCode = shifterCode @ ") {\n";
               shifterCode = shifterCode @ (match variableFormat with 
                                                  D   : ( "double t;\n\n" )
                                                  DD  : ( "double th, tm;\ndouble temp;\n\n" )
                                                  TD  : ( "double th, tm, tl;\ndouble temp;\n\n" )
                                           );
               shifterCode = shifterCode @ (match variableFormat with 
                                                  D   : ( "t = x - " @ functionName @ "_centerpoint;" )
                                                  DD  : ( "temp = xh - " @ functionName @ "_centerpoint;\nAdd12(th,tm,temp,xm);" )
                                                  TD  : ( "temp = xh - " @ functionName @ "_centerpoint;\nRenormalize3(&th,&tm,&tl,temp,xm,xl);" )
                                           );
               shifterCode = shifterCode @ "\n\n";
	       shifterCode = shifterCode @ polynomialName @ "(";
	       shifterCode = shifterCode @ (match outputFormat with 
                                                  D   : ( "res_resh, " )
                                                  DD  : ( "res_resh, res_resm, " )
                                                  TD  : ( "res_resh, res_resm, res_resl, " )
                                           );
               shifterCode = shifterCode @ (match variableFormat with 
                                                  D   : ( "t" )
                                                  DD  : ( "th, tm" )
                                                  TD  : ( "th, tm, tl" )
                                           );
               shifterCode = shifterCode @ ");\n\n";
	       shifterCode = shifterCode @ "}\n";
	       write(shifterCode) >> implementationFile;
          } else {
	    write("Error: Sterbenz condition not fulfilled for argument center ", centerPoint, " and domain ", dom, "\n");
	  };
	  };

	  return res;
};

/* implements a function by polynomial approximation in a small interval
   while issuing appropriate range translation code if the interval 
   is not centered in zero.

   Returns a structure that 

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the approximation error
          * implerr      the implementation (round-off) error
          * centerpoint  the point the original interval got centered at
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         translation
          * poly         the polynomial that has been used
          * pstar        the best approximation polynomial used for 
                         floating-point approximation

   The function to be implemented may have at most 1 zero in the domain.
   No test for this condition is made.

*/
procedure implementsmallwithcentering(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName) {
	  var res, resultat, outputFormat, resShifter;

	  resultat = { .okay = false };

	  res = implementsmall(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName);

	  if (res[0]) then {
	     /* Get the information returned by the implementer function working on a small interval */
	     resultat.okay = true;
	     resultat.approxerr = res[3];
	     resultat.implerr = res[4];
	     resultat.poly = res[2];
	     resultat.pstar = res[5];
	     resultat.centerpoint = res[1];

	     /* Determine the output format of the implemented polynomial */
	     outputFormat = parse(bashevaluate("cat "@implementationFile@" | grep \"void "@polynomialName@"\" | sed -n 's/double x.*//g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, double \\*"@polynomialName@"_resm, double \\*"@polynomialName@"_resl, /TD/g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, double \\*"@polynomialName@"_resm, /DD/g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, /D/g;p'"));
	     resultat.outputformat = outputFormat;

	     /* Generate the code that shifts the domain with the centerpoint determined beforehand */
	     if (resultat.centerpoint != 0) then {
	       resultat.functionname = polynomialName@ "_shifter";
	       resShifter = implementShifter(resultat.centerpoint, dom, variableFormat, outputFormat, polynomialName, resultat.functionname, implementationFile);
	       if (!resShifter.okay) then {
	       	  resultat = { .okay = false };
	       };
	     } else {
	       resultat.functionname = polynomialName;
	     };
	  }; 

	  return resultat;
};

procedure splitList(l, i) {
	  var res;
	  var lA, lB, k, lenL;

	  lenL = length(l);
	  if ((i < 0) || (i >= lenL)) then {
	     res.lA = l;
	     res.lB = [||];
	  } else {
	    lA = [||];
	    for k from 0 to i - 1 do {
	    	lA = lA :. (l[k]);
	    };
	    lB = [||];
	    for k from i to lenL - 1 do {
	    	lB = lB :. (l[k]);
	    };
	    res.lA = lA;
	    res.lB = lB;
	  };

	  return res;
};

procedure generateRecursiveSplitter(splitPointName, domains, functionNames, outputFormats, variableFormat, globalOutputFormat) {
	  var resultat;
	  var lenDomains, lenFunctionNames, lenOutputFormats, splitterCode, middleIndex, res;
	  var splitPointA, splitPointB;
	  var temp;
	  var domainsLeft, domainsRight, functionNamesLeft, functionNamesRight, outputFormatsLeft, outputFormatsRight;
	  var oldDisplay, resLeft, resRight, myDefines;

	  resultat = { .okay = false };

	  lenDomains = length(domains);
	  lenFunctionNames = length(functionNames);
	  lenOutputFormats = length(outputFormats);
	  
	  if ((lenDomains == lenFunctionNames) &&
	      (lenFunctionNames == lenOutputFormats) &&
	      (lenDomains != 0)) then {

	      if (lenDomains == 1) then {
	          resultat.okay = true;
		  resultat.defines = "";
		  splitterCode = functionNames[0] @ "(";
		  splitterCode = splitterCode @ (match (outputFormats[0]) with 
		                                       D  :    ("res_resh, ")
                                                       DD :    ("res_resh, res_resm, ")
                                                       TD :    ("res_resh, res_resm, res_resl, ")
                                                );
                  splitterCode = splitterCode @ (match (variableFormat) with 
                                                       D  :    ("xh")
                                                       DD :    ("xh, xm")
                                                       TD :    ("xh, xm, xl")
                                                );
                  splitterCode = splitterCode @ ");\n";
                  match (globalOutputFormat) with 
                        TD : {
                                match (outputFormats[0]) with 
                                      DD :  {
                                                splitterCode = splitterCode @ "*res_resl = 0.0;\n";
                                            }
                                      D  :  {
                                                splitterCode = splitterCode @ "*res_resm = 0.0;\n";
                                                splitterCode = splitterCode @ "*res_resl = 0.0;\n";
                                            }
                                      default : { };
                             }
                        DD : {
                                if (outputFormats[0] == D) then {
                                   splitterCode = splitterCode @ "*res_resm = 0.0;\n";
                                };
                             }
                        default : { };
	          resultat.splitterCode = splitterCode;
	      } else {
	      	  middleIndex = floor(lenDomains / 2);
		  splitPointA = inf(domains[middleIndex]);
		  splitPointB = sup(domains[middleIndex - 1]);
                  if (splitPointA == splitPointB) then {
		     temp = splitList(domains, middleIndex);
		     domainsLeft = temp.lA;
		     domainsRight = temp.lB;
		     temp = splitList(functionNames, middleIndex);
		     functionNamesLeft = temp.lA;
		     functionNamesRight = temp.lB;
		     temp = splitList(outputFormats, middleIndex);
		     outputFormatsLeft = temp.lA;
		     outputFormatsRight = temp.lB;
		     resLeft = generateRecursiveSplitter(splitPointName @ "_0", domainsLeft, functionNamesLeft, outputFormatsLeft, variableFormat, globalOutputFormat);
		     resRight = generateRecursiveSplitter(splitPointName @ "_1", domainsRight, functionNamesRight, outputFormatsRight, variableFormat, globalOutputFormat);
		     if (resLeft.okay && resRight.okay) then {
		         resultat.okay = true;
			 oldDisplay = display;
			 display = decimal!;
			 myDefines = "#define " @ splitPointName @ "_splitpoint " @ splitPointA @ "\n";
			 display = oldDisplay!;
			 splitterCode = "if ( xh < " @ splitPointName @ "_splitpoint ) {\n" @
                                        resLeft.splitterCode @ "} else {\n" @
                                        resRight.splitterCode @ "}\n";
			 resultat.defines = resLeft.defines @ myDefines @ resRight.defines;
			 resultat.splitterCode = splitterCode;
		     };
		  };
	      };
	  };

	  return resultat;
};


/* implements a function by polynomial approximation in small intervals
   obtained by cutting the interval at given points

   Returns a structure that 

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the maximum approximation error
          * implerr      the maximum implementation (round-off) error
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         reduction

   The function to be implemented may have at most 1 zero in each sub-domain.
   No test for this condition is made.

*/
procedure implementwithdomainsplitlist(func, dom, splitPoints, minWidth, definitionDomain, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName) {
	  var resultat;
	  var okay, sp;
	  var mySplitPoints;
	  var approxerr, implerr, outputFormats, functionNames;
	  var domains, i, numberSplitPoints, myDom, mySuffix, myImplementationFile;
	  var res, implementationFiles, implFile, myOutputFormat, opF, myOutputFormatNum;
	  var myFunctionName, splitterCode, oldDisplay, recursiveSplitterRes, symmetrizedDom, recovered;

	  /* write("implementwithdomainsplitlist(",func,",", dom,",", splitPoints,",", minWidth,",", definitionDomain,",", target,",", beta,",", variableFormat,",", implementationFile,",", gappaFile,",", gappaOutputFile,",", gappaExecutable,",", polynomialBaseName,")\n"); */

	  resultat = { .okay = false };

	  /* First of all, if no splitPoints are given, the domain is not
	     split and we can simply call implementsmallwithcentering
	  */
	  if (splitPoints == [||]) then {
	     resultat = implementsmallwithcentering(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName);
	  } else {	   
	  /* To start with, check if all splitPoints are doubles and 
             if they are contained in the given domain 
          */
	  okay = true;
	  for sp in splitPoints do {
	      okay = okay && ((D(sp) - sp == 0) && (sp in dom));
	  };
	  if (okay) then {
	     /* Now sort the split points by increasing order, 
	     adding the bounds to the list */
	     mySplitPoints = sort(splitPoints @ [| inf(dom), sup(dom) |]);

	     /* While we succeed in implementing the subdomains,
	        cut out a new subdomain, generate function and
		file names and try implementation.
             */
	     approxerr = 0;
	     implerr = 0;
	     outputformats = [||];
  	     functionNames = [||];
	     domains = [||];
	     implementationFiles = [||];
	     numberSplitPoints = length(mySplitPoints);
	     myDomains = [||];
	     for i from 0 to numberSplitPoints - 2 do {
	     	 myDomains = myDomains :. ( [ mySplitPoints[i], mySplitPoints[i + 1] ] );
	     };
	     i = 0;
	     while ((okay) && (myDomains != [||])) do {
	     	   myDom = head(myDomains);
		   myDomains = tail(myDomains);
		   write("\nStarting implementation on subdomain ",myDom,"\n");
		   mySuffix = "_subdomain_" @ i ;
		   myImplementationFile = implementationFile @ mySuffix;	
		   res = implementsmallwithcentering(func, myDom, target, beta, variableFormat, myImplementationFile, gappaFile @ mySuffix, gappaOutputFile @ mySuffix, gappaExecutable, polynomialBaseName @ mySuffix);
		   if (res.okay) then {
		         write("Subdomain ",myDom," done\n");
   		         domains = domains :. myDom;
		         implementationFiles = implementationFiles :. myImplementationFile;
			 approxerr = max(approxerr, abs(res.approxerr));
			 implerr = max(implerr, abs(res.implerr));
			 outputformats = outputformats :. (res.outputformat);
			 functionNames = functionNames :. (res.functionname);
			 i := i + 1;
		   } else {
		     if (abs(sup(myDom) - inf(myDom)) < minWidth) then {
		        write("Error on subdomain ",myDom,", check ", gappaFile @ mySuffix, "\n");
		        okay = false;
	             } else {
		        recovered = false;
		        symmetrizedDom = myDom;
			if (inf(myDom) == 0) then { 
			   symmetrizedDom = [-sup(myDom),sup(myDom)];
			};
			if (sup(myDom) == 0) then {
			   symmetrizedDom = [inf(myDom),-inf(myDom)];
			};
			if ((inf(myDom) == 0) || (sup(myDom) == 0)) then {
			   if (symmetrizedDom in definitionDomain) then {
			      write("Using symmetrized domain around 0 instead of original domain to exploit symmetries of the function\n");
			      res = implementsmallwithcentering(func, symmetrizedDom, target, beta, variableFormat, myImplementationFile, gappaFile @ mySuffix, gappaOutputFile @ mySuffix, gappaExecutable, polynomialBaseName @ mySuffix);
      		              if (res.okay) then {
		                 write("Subdomain ",myDom," done\n");
   		                 domains = domains :. myDom;
		                 implementationFiles = implementationFiles :. myImplementationFile;
			         approxerr = max(approxerr, abs(res.approxerr));
			         implerr = max(implerr, abs(res.implerr));
			         outputformats = outputformats :. (res.outputformat);
			         functionNames = functionNames :. (res.functionname);
			         i := i + 1;
				 recovered = true;
		              };
			   };
			};

			if (!recovered) then {
			   write("Resplitting on subdomain ",myDom,"\n");
		           if (inf(myDom) * sup(myDom) < 0) then {
			      myDomains = [ inf(myDom) , D(inf(myDom) / 3) ] .: ( [ D(inf(myDom) / 3) , D(sup(myDom) / 3) ] .: ( [ D(sup(myDom) / 3) , sup(myDom) ] .: myDomains )); 	  
			   } else {
			      myDomains = [ inf(myDom) , D(mid(myDom)) ] .: ( [ D(mid(myDom)) , sup(myDom) ] .: myDomains ); 	  
			   };
			};
		     };
		   };
	     };
	     
	     /* Now generate the argument reduction code if 
	        we succeeded in generating code for all 
		subdomains and combine all files.
             */
	     if (okay) then {
	        oldDisplay = display;
		display = dyadic!;
	     	write("\n\n") > implementationFile;
                display = oldDisplay!;
		for implFile in implementationFiles do {
		    bashexecute("cat " @ implFile @ " >> " @ implementationFile);
		};
		write("\n\n") >> implementationFile;
		myOutputFormatNum = 1;
		for opF in outputformats do {
		    myOutputFormatNum = max(myOutputFormatNum,
                                            match opF with 
                                                  D  : (1) 
                                                  DD : (2) 
                                                  TD : (3)
                                                  default : { okay = false; return 0; });
		};
		if (okay) then {
		   myOutputFormat = match myOutputFormatNum with 1 : (D) 2 : (DD) 3 : (TD);
                   myFunctionName = polynomialBaseName @ "_splitter";
		   splitterCode = "\n\n";
		   recursiveSplitterRes = generateRecursiveSplitter(myFunctionName, domains, functionNames, outputformats, variableFormat, myOutputFormat); 
		   if (!recursiveSplitterRes.okay) then okay = false;
		   if (okay) then {
		        splitterCode = splitterCode @ recursiveSplitterRes.defines;
             	        splitterCode = splitterCode @ "\n\nvoid "@myFunctionName@"(";
	       	        splitterCode = splitterCode @ (match myOutputFormat with 
                   	                                     D   : ( "double *res_resh, " )
                                                             DD  : ( "double *res_resh, double *res_resm, " )
                                                             TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                                      );
                        splitterCode = splitterCode @ (match variableFormat with 
                                                             D   : ( "double xh" )
                                                             DD  : ( "double xh, double xm" )
                                                             TD  : ( "double xh, double xm, double xl" )
                                                      );
                        splitterCode = splitterCode @ ") {\n";
		        splitterCode = splitterCode @ recursiveSplitterRes.splitterCode;
                        splitterCode = splitterCode @ "}\n\n";
		        write(splitterCode) >> implementationFile; 
                   };
		   if (okay) then {
		      resultat.okay = true;
		      resultat.approxerr = approxerr;
		      resultat.implerr = implerr;
		      resultat.outputformat = myOutputFormat;
		      resultat.functionname = myFunctionName;
		   };
		};
	     };
	  };
	  };

	  return resultat;
};

procedure computeDomainSplitting(func, dom, maxDegree, target) {
	  var resultat;
	  var poly;
	  var deg;
	  var subdomains, splitpoints, aSp, bSp, sd;
	  var res, recursiveSplitPoints, y, guess;
	  var midpoint;
	  var remezFunc, remezDom;
	  var zeros, t, z;

	  resultat = { .okay = false };
	  deg = -1;

	  if ((!(0 in dom)) && 
	      (!(dom in [(mid(dom) * 100)/199;(mid(dom)*199)/100]))) then {
	      /* We have to split because the Sterbenz condition will
	         not be fulfilled for center points on this subdomain 

		 We simultate the case with a dummy degree that is too huge
	       */
	       deg = maxDegree * 2;

	  } else {

	  remezFunc = func;
	  remezDom = dom;
	  if (0 in evaluate(func,dom)) then {
	     y = evaluate(func, 0);
	     if (!((inf(y) <= 0) && (sup(y) >= 0))) then {
	     	/* func has a zero in dom but not in 0 */
		zeros = dirtyfindzeros(func, dom);
		if (zeros != [||]) then {
		   /* I found zeros of func in dom,
		      let's look for the zero farthest
		      from 0
		   */
		   t = zeros[0];
		   for z in zeros do {
		       if (abs(z) > abs(t)) then t = z;
		   };
		   /* Now translate the function so 
		      that it has a zero in 0
                   */
		   remezFunc = func(x + t);
		   remezDom = dom - t;
		};
	     };
	  };

	  if (0 in remezDom) then { y = evaluate(remezFunc, 0); } else { y = 1; };
	  if ((inf(y) <= 0) && (sup(y) >= 0)) then {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),x/remezFunc,maxDegree+2); };
	     guess = guess + 1;
	  } else {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),1/remezFunc,maxDegree+2); };
	  };

	  if ((guess == guess) && (guess != false)) then {
	          deg = inf(guess);
	  } else {
	  	  write("Computing a remez polynomial for ", func, " in ", dom, " with target ", target,"\n");
	  	  poly = simpleRemezWrapper(remezFunc, remezDom, target, 3);
		  if ((poly == poly) && (poly != false)) then {
		     deg = degree(poly);
		  };
          };

	  };

	     if (deg >= 0) then { 
	     	if (deg <= maxDegree) then {
		   resultat.okay = true;
		   resultat.splitPoints = [||];
		} else {
		   if (inf(dom) * sup(dom) < 0) then {
		      aSp = D(inf(dom)/3);
		      bSp = D(sup(dom)/3);
		      splitpoints = [| aSp , bSp |];
		      subdomains = [| [ inf(dom) , aSp ], [ aSp, bSp ], [ bSp, sup(dom) ] |];
		   } else {
		      aSp = D(mid(dom));
		      splitpoints = [| aSp |];
		      subdomains = [| [ inf(dom), aSp ], [ aSp, sup(dom) ] |];
		   };
		   okay = true;
		   recursiveSplitPoints = [||];
		   while ((okay) && (subdomains != [||])) do {
		   	 sd = head(subdomains);
			 subdomains = tail(subdomains);
			 res = computeDomainSplitting(func, sd, maxDegree, target);
			 if (res.okay) then {
			    recursiveSplitPoints = recursiveSplitPoints @ (res.splitPoints);
			 } else {
			   okay = false;
			 };
		   };
		   if (okay) then {
		      resultat.okay = true;
		      resultat.splitPoints = recursiveSplitPoints @ splitpoints;
		   };
	     	};
	     };
	    

	  return resultat;
};


/* implements a function by polynomial approximation in small intervals
   that are automatically computed using a maximum polynomial degree
   indication

   Returns a structure that 

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the maximum approximation error
          * implerr      the maximum implementation (round-off) error
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         reduction

   The function to be implemented may have at most 1 zero in each sub-domain.
   No test for this condition is made.

*/
procedure implementwithdomainsplitting(func, dom, maxDegree, minWidth, definitionDomain, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName) {
	  var resultat, res, splitPoints;

	  /* write("implementwithdomainsplitting(",func,",", dom,",", maxDegree,",", minWidth,",", definitionDomain,",", target,",", beta,",", variableFormat,",", implementationFile,",", gappaFile,",", gappaOutputFile,",", gappaExecutable,",", polynomialBaseName,")\n"); */

	  resultat = { .okay = false };

	  res = computeDomainSplitting(func, dom, maxDegree, target);

	  if (res.okay) then {
	     splitPoints = sort(res.splitPoints);

	     write("The domain will first be split at the following points: ", splitPoints, "\n");

	     res = implementwithdomainsplitlist(func, dom, splitPoints, minWidth, definitionDomain, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName);

	     if (res.okay) then {
	     	resultat = res;
	     };

	  } else {
	    write("Could not compute a domain splitting\n");
	  };

	  return resultat;
};


procedure tryImplementationThroughDomainSplitting(problemdef, parametrization) {
	  var result, definitionDomain;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with 
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default } } : {
				                definitionDomain = problemdef.dom;
						match (problemdef) with 
                                                      { .definitionDomain = default } : { definitionDomain = problemdef.definitionDomain; }
                                                      default : { };
					        result = implementwithdomainsplitting(problemdef.func, 
						                                      problemdef.dom, 
                                                                                      parametrization.maxDegree, 
                                                                                      parametrization.minWidth, 
										      definitionDomain,
                                                                                      problemdef.target, 
                                                                                      parametrization.beta, 
                                                                                      problemdef.variableFormat, 
                                                                                      parametrization.implementationFile, 
										      parametrization.gappaFile, 
										      parametrization.gappaOutputFile, 
										      parametrization.gappaExecutable, 
										      parametrization.functionBasename);
					}
                default : { };

	  return result;
};

procedure checkIfSufficientDegree(func, dom, maxDegree, target) {
	  var resultat;
	  var poly;
	  var deg;
	  var y, guess;
	  var remezFunc, remezDom;
	  var zeros, t, z;

	  resultat = { .okay = false };
	  deg = -1;

	  if ((!(0 in dom)) && 
	      (!(dom in [(mid(dom) * 100)/199;(mid(dom)*199)/100]))) then {
	      /* We have to split because the Sterbenz condition will
	         not be fulfilled for center points on this subdomain 

		 We simultate the case with a dummy degree that is too huge
	       */
	       deg = maxDegree * 2;

	  } else {

	  remezFunc = func;
	  remezDom = dom;
	  if (0 in evaluate(func,dom)) then {
	     y = evaluate(func, 0);
	     if (!((inf(y) <= 0) && (sup(y) >= 0))) then {
	     	/* func has a zero in dom but not in 0 */
		zeros = dirtyfindzeros(func, dom);
		if (zeros != [||]) then {
		   /* I found zeros of func in dom,
		      let's look for the zero farthest
		      from 0
		   */
		   t = zeros[0];
		   for z in zeros do {
		       if (abs(z) > abs(t)) then t = z;
		   };
		   /* Now translate the function so 
		      that it has a zero in 0
                   */
		   remezFunc = func(x + t);
		   remezDom = dom - t;
		};
	     };
	  };

	  if (0 in remezDom) then { y = evaluate(remezFunc, 0); } else { y = 1; };
	  if ((inf(y) <= 0) && (sup(y) >= 0)) then {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),x/remezFunc,maxDegree+2); };
	     guess = guess + 1;
	  } else {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),1/remezFunc,maxDegree+2); };
	  };

	  if ((guess == guess) && (guess != false)) then {
	          deg = inf(guess);
	  } else {
	  	  write("Computing a remez polynomial for ", func, " in ", dom, " with target ", target,"\n");
	  	  poly = simpleRemezWrapper(remezFunc, remezDom, target, 3);
		  if ((poly == poly) && (poly != false)) then {
		     deg = degree(poly);
		  };
          };

	  };

	     if (deg > 0) then { 
	     	if (deg <= maxDegree) then {
		   resultat.okay = true;
		   resultat.sufficientDegree = true;
		} else {
		   resultat.okay = true;
		   resultat.sufficientDegree = false;
	     	};
	     };
	    

	  return resultat;
};

procedure tryDetectSymmetry(func, dom, target) {
	  var res, testfunc, zerosUpper, zerosLower, myDom, y;

	  res = { .okay = false };

	  myDom = [0; min(sup(dom), -inf(dom))];
	  testfunc = simplifysafe((func/(func(-x))) - 1);
	  y = evaluate(testfunc, min(sup(dom), -inf(dom)) / 2);
	  if (y in [-target, target]) then {
	  	  zerosUpper = dirtyfindzeros(testfunc + target, myDom);
	  	  zerosLower = dirtyfindzeros(testfunc - target, myDom);
          } else {
	          zerosUpper = [| 0 |];
		  zerosLower = [| 0 |];
	  };		  

	  if ((zerosUpper == [||]) && (zerosLower == [||])) then {
	     res.okay = true;
	     res.evenSymmetry = true;
	  } else {
	     testfunc = simplifysafe((func/(-func(-x))) - 1);
   	     y = evaluate(testfunc, min(sup(dom), -inf(dom)) / 2);
	     if (y in [-target, target]) then {
	  	  zerosUpper = dirtyfindzeros(testfunc + target, myDom);
	  	  zerosLower = dirtyfindzeros(testfunc - target, myDom);
             } else {
	          zerosUpper = [| 0 |];
		  zerosLower = [| 0 |];
	     };		  

	     if ((zerosUpper == [||]) && (zerosLower == [||])) then {
	        res.okay = true;
	        res.evenSymmetry = false;
	     };
	  };

	  return res;
};

procedure tryImplementationThroughSymmetryDetectionAroundZero(problemdef, parametrization) {
	  var result, splitPoints, needToDetectSymmetry, res, evenSymmetry, myDom, oppositeOnNegative;
	  var suffix, myProblemdef, myParametrization, origDefDom, symmetryCode;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with 
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default } } : {
				       
				       /* Start with a test if zero is actually inside the domain */
				       if (sup(problemdef.dom) * inf(problemdef.dom) < 0) then {

				       /* Continue with a test if the domain actually needs 
                                          to be split in order to stay below the maximum 
					  polynomial degree 
				        */	     
				       needToDetectSymmetry = true;
				       res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                               if (res.okay) then {
   	                                   if (res.sufficientDegree) then needToDetectSymmetry = false;
				       } else {
				           needToDetectSymmetry = false;
				       };

				       if (needToDetectSymmetry) then {
				       
				            /* Try to detect a symmetry of func around 0 */
					    res = tryDetectSymmetry(problemdef.func, problemdef.dom, problemdef.target * 13/32);

					    if (res.okay) then {
					       /* If we detected a symmetry */
					       if (res.evenSymmetry) then {
					       	  write("Detected an even symmetry\n");
					       } else {
					          write("Detected an odd symmetry\n");
					       };
					       /* Now compute the reduced domain and determine
					          when we have to compute the opposite of the argument.
					       */
                                               if (-inf(dom) < sup(dom)) then {
					           myDom = [ 0, sup(dom) ];
						   oppositeOnNegative = true;
					       } else {
					           myDom = [ inf(dom), 0 ];
						   oppositeOnNegative = false;
					       };
					       evenSymmetry = res.evenSymmetry;
					       write("The subdomain after range reduction for symmetry is: ", myDom, "\n");
					       
					       /* Now call the implementer recursively on the reduced domain */
					       suffix = "_symmetrical";
					       myProblemdef = problemdef;
					       myProblemdef.dom = myDom;
					       myProblemdef.target = problemdef.target * 13/32;
					       origDefDom = dom;
					       match (problemdef) with { .definitionDomain = default } : { 
					                       if (origDefDom in problemdef.definitionDomain) then {
                                                                  origDefDom = problemdef.definitionDomain;
                                                               }; }
                                                                       default : {};
					       myProblemdef.definitionDomain = origDefDom;
					       myParametrization = parametrization;
					       myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					       myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					       myParametrization.functionBasename = parametrization.functionBasename @ suffix;
					       res = tryImplementation(myProblemdef, myParametrization);
					       
					       if (res.okay) then {
					       	  /* The implementation worked on the subdomain 

						     Now generate the reduction code.

						  */
						  symmetryCode = "";
						  symmetryCode = symmetryCode @ "\n\nvoid "@parametrization.functionBasename@"(";
						  symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                       D   : ( "double *res_resh, " )
                                                                                       DD  : ( "double *res_resh, double *res_resm, " )
                                                                                       TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                                                                );
                                                  symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                       D   : ( "double xh" )
                                                                                       DD  : ( "double xh, double xm" )
                                                                                       TD  : ( "double xh, double xm, double xl" )
                                                                                );
                                                  symmetryCode = symmetryCode @ ") {\n";
						  if (evenSymmetry) then {
						     if (oppositeOnNegative) then {
						     	symmetryCode = symmetryCode @ "if (xh < 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     } else {
						     	symmetryCode = symmetryCode @ "if (xh > 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     };
						  } else {
						     symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                          D   : ( "double sym_res_resh;" )
                                                                                          DD  : ( "double sym_res_resh, sym_res_resm;" )
                                                                                          TD  : ( "double sym_res_resh, sym_res_resm, sym_res_resl;" )
                                                                                   );
						     symmetryCode = symmetryCode @ "\n";
						     if (oppositeOnNegative) then {
						     	symmetryCode = symmetryCode @ "if (xh < 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "&sym_res_resh, " )
                                                                                             DD  : ( "&sym_res_resh, &sym_res_resm, " )
                                                                                             TD  : ( "&sym_res_resh, &sym_res_resm, &sym_res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "*res_resh = -sym_res_resh;" )
                                                                                             DD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm;" )
                                                                                             TD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm; *res_resl = -sym_res_resl;" )
                                                                                      );
						        symmetryCode = symmetryCode @ "\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     } else {
						     	symmetryCode = symmetryCode @ "if (xh > 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "&sym_res_resh, " )
                                                                                             DD  : ( "&sym_res_resh, &sym_res_resm, " )
                                                                                             TD  : ( "&sym_res_resh, &sym_res_resm, &sym_res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "*res_resh = -sym_res_resh;" )
                                                                                             DD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm;" )
                                                                                             TD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm; *res_resl = -sym_res_resl;" )
                                                                                      );
						        symmetryCode = symmetryCode @ "\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     };
						  };						  
						  symmetryCode = symmetryCode @ "}\n";
						  write(symmetryCode) >> parametrization.implementationFile;
						  result = res;
						  result.functionname = parametrization.functionBasename;
					       }; 
					    };
				       };
				       };
				     }
                default : { };

	  return result;
};

procedure tryDetectExponentialArgRed(func, dom, target) {
	  var result, base, a, b, c, d, ratio, oldPrec, testfunc;
	  var y, zerosUpper, zerosLower;

	  result = { .okay = false };

	  /* We have to detect if func behaves in dom 
	     like 

	     base^x for some unknown base

	     We say that func behaves like base^x 
	     if 

	     base^x = func * (1 + eps) with abs(eps) <= target.
	     
	     We start by computing a possible base
	     as

	     base = exp((log(f(c+d)/f(c))/d))
	     
	     with 

	       - d = b - a                  if b - a < 5
	         c = a

	       - d = 5                      otherwise
                 c = max(a, (a+b)/2 - 2.5) 

             where dom = [a;b]

	     We can stop trying if f(c+d)/f(c) is 
	     negative.
	  */	     
	  a = inf(dom);
	  b = sup(dom);
	  if (b - a < 5) then {
	     d = b - a;
	     c = a;
	  } else {
	     d = 5;
	     c = max(a, (a + b)/2 - 2.5);
	  };
	  ratio = f(c + d) / f(c);
	  if (ratio > 0) then {
	     /* Here, f(c + d) / f(c) is positive 

	        So we can compute a presumed base 
		as 

		base = exp(log(ratio)/d)

		where ratio = f(c + d) / f(c)

		We need to perform this evaluation 
		with an accuracy of at least the 
		double of the prevailing precision
		as the rest of the argument reduction
		code must receive a pretty accurate 
		base.

	     */
	     oldPrec = prec;
	     prec = max(2 * prec, ceil(-log2(abs(target))) * 3)!;
	     base := exp(log(ratio) / d);
	     prec = oldPrec!;

	     /* Now we have to check if base^x effectively approximates func with 
	        an accuracy of target 
	     */
	     testfunc = simplifysafe((base^x)/func - 1);
	     y = evaluate(testfunc, mid(dom));
	     if (y in [-target, target]) then {
	  	  zerosUpper = dirtyfindzeros(testfunc + target, dom);
	  	  zerosLower = dirtyfindzeros(testfunc - target, dom);

		  if ((zerosUpper == [||]) && (zerosLower == [||])) then {
	              result.okay = true;
		      result.exponentialFunc = base^x;
		      result.exponentialBase = base;
	          };  
             };		  
	  };
	  return result;
};

procedure tryGenerateExponentialArgumentReduction(base, dom, functionName, polynomialFunctionName, outputformat, polynomialVariableFormat, variableFormat, argRedTarget, reconstructTableTarget, tableWidth) {
	  var result, code, table, okay, variableDeclarations, reductionCode, reconstructionCode;
	  var oldDisplay, tableFormat, i, tblEntry, tblEntryExact, logBaseOfTwoFormat, logBaseOfTwoExact;

	  result = { .okay = false };
	  okay = true;

	  table = "\n";
	  oldDisplay = display;
	  display = decimal!;
	  if (tableWidth > 0) then {
	        if (3/8 * reconstructTableTarget < 1b-107) then tableFormat = TD
                else if (3/8 * reconstructTableTarget < 1b-53) then tableFormat = DD 
		else tableFormat = D;
	  	table = table @ "static const double " @ functionName @ "_twoPower_Index_Hi[" @ (~(2^tableWidth)) @ "] = {\n";
		for i from 0 to 2^tableWidth - 1 do {
		    tblEntryExact = 2^(i * 2^(-tableWidth));
		    tblEntry = simplifysafe(D(tblEntryExact));
		    table = table @ " " @ tblEntry;
		    if (i != 2^tableWidth - 1) then table = table @ ",";
		    table = table @ "\n";
		};
		table = table @ "};\n\n";
		if ((tableFormat == DD) || (tableFormat == TD)) then {
	           table = table @ "static const double " @ functionName @ "_twoPower_Index_Mi[" @ (~(2^tableWidth)) @ "] = {\n";
		   for i from 0 to 2^tableWidth - 1 do {
		       tblEntryExact = 2^(i * 2^(-tableWidth));
		       tblEntry = simplifysafe(D(tblEntryExact - D(tblEntryExact)));
		       table = table @ " " @ tblEntry;
		       if (i != 2^tableWidth - 1) then table = table @ ",";
		       table = table @ "\n";
		   };
		   table = table @ "};\n\n";
		};
	        if (tableFormat == TD) then {
	           table = table @ "static const double " @ functionName @ "_twoPower_Index_Lo[" @ (~(2^tableWidth)) @ "] = {\n";
		   for i from 0 to 2^tableWidth - 1 do {
		       tblEntryExact = 2^(i * 2^(-tableWidth));
		       tblEntry = simplifysafe(D(tblEntryExact - (D(tblEntryExact) + D(tblEntryExact - D(tblEntryExact)))));
		       table = table @ " " @ tblEntry;
		       if (i != 2^tableWidth - 1) then table = table @ ",";
		       table = table @ "\n";
		   };
		   table = table @ "};\n\n";
		};
          };

	  table = table @ "#define " @ functionName @ "_argred_log2_of_base_times_two_to_w " @ (simplifysafe(D(log2(base) * 2^tableWidth))) @ "\n";

	  if (argRedTarget * 2^(-tableWidth - 2) < 1b-106) then logBaseOfTwoFormat = TD
	  else if (argRedTarget * 2^(-tableWidth - 2) < 1b-53) then logBaseOfTwoFormat = DD
	  else logBaseOfTwoFormat = D;

	  logBaseOfTwoExact = -2^(-tableWidth) * log(2)/log(base);
	  table = table @ "#define " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi " @ (simplifysafe(D(logBaseOfTwoExact))) @ "\n";
	  if ((logBaseOfTwoFormat == DD) || (logBaseOfTwoFormat == TD)) then {
	     table = table @ "#define " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_mi " @ (simplifysafe(D(logBaseOfTwoExact - D(logBaseOfTwoExact)))) @ "\n";
	  };
	  if (logBaseOfTwoFormat == TD) then {
	     table = table @ "#define " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_lo " @ (simplifysafe(D(logBaseOfTwoExact - (D(logBaseOfTwoExact) + D(logBaseOfTwoExact - D(logBaseOfTwoExact)))))) @ "\n";
	  };

	  table = table @ "#define " @ functionName @ "_argred_shifter 6755399441055744.0\n";
	  table = table @ "#define " @ functionName @ "_argred_w " @ tableWidth @ "\n";
	  table = table @ "#define " @ functionName @ "_argred_idx_mask " @ (simplifysafe(2^tableWidth - 1)) @ "ull\n";
	  table = table @ "#define " @ functionName @ "_argred_lower_32_bits 0xffffffffull\n";
	  display=oldDisplay!;

	  variableDeclarations = "\n";
	  reductionCode = "\n";
	  reconstructionCode = "\n";
	  
 	  variableDeclarations = variableDeclarations @ "double t;\n";
	  reductionCode = reductionCode @ "t = xh * " @ functionName @ "_argred_log2_of_base_times_two_to_w;\n";
 	  variableDeclarations = variableDeclarations @ "double shifted_t;\n";
	  reductionCode = reductionCode @ "shifted_t = t + " @ functionName @ "_argred_shifter;\n";
 	  variableDeclarations = variableDeclarations @ "double mAsDouble;\n";
	  reductionCode = reductionCode @ "mAsDouble = shifted_t - " @ functionName @ "_argred_shifter;\n";
 	  variableDeclarations = variableDeclarations @ "db_number argRedCaster;\n";
 	  variableDeclarations = variableDeclarations @ "int mAsInt;\n";
	  reductionCode = reductionCode @ "argRedCaster.d = shifted_t;\n";
	  reductionCode = reductionCode @ "mAsInt = (int) (argRedCaster.l & " @ functionName @ "_argred_lower_32_bits);\n";
 	  variableDeclarations = variableDeclarations @ "int E;\n";
	  reductionCode = reductionCode @ "E = mAsInt >> " @ functionName @ "_argred_w;\n";
 	  variableDeclarations = variableDeclarations @ "int E1;\n";
	  reductionCode = reductionCode @ "E1 = E >> 1;\n";
 	  variableDeclarations = variableDeclarations @ "int E2;\n";
	  reductionCode = reductionCode @ "E2 = E - E1;\n";
 	  variableDeclarations = variableDeclarations @ "int idx;\n";
	  reductionCode = reductionCode @ "idx = mAsInt & " @ functionName @ "_argred_idx_mask;\n";

	  match (logBaseOfTwoFormat) with 
	  	D  : {
		        variableDeclarations = variableDeclarations @ "double rescaled_m_hi;\n";
	                reductionCode = reductionCode @ "rescaled_m_hi = mAsDouble * " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi;\n";
		     }
		DD : {
		        variableDeclarations = variableDeclarations @ "double rescaled_m_hi;\n";
		        variableDeclarations = variableDeclarations @ "double rescaled_m_mi;\n";
	                reductionCode = reductionCode @ "Mul122(&rescaled_m_hi, &rescaled_m_mi, mAsDouble, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_mi);\n";
	             }
		TD : {
		        variableDeclarations = variableDeclarations @ "double rescaled_m_hi;\n";
		        variableDeclarations = variableDeclarations @ "double rescaled_m_mi;\n";
		        variableDeclarations = variableDeclarations @ "double rescaled_m_lo;\n";
	                reductionCode = reductionCode @ "Mul133(&rescaled_m_hi, &rescaled_m_mi, &rescaled_m_lo, mAsDouble, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_mi, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_lo);\n";
	             };
	  
	  match (logBaseOfTwoFormat) with 
	  	D  : {
		          match (variableFormat) with 
			  	D  : {
				         match (polynomialVariableFormat) with 
					       D  : {
	                                                reductionCode = reductionCode @ "zh = xh + rescaled_m_hi;\n";
					       	    }
					       DD : {
	                                                reductionCode = reductionCode @ "zh = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "zm = 0.0;\n";
					       	    }
					       TD : {
	                                                reductionCode = reductionCode @ "zh = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "zm = 0.0;\n";
	                                                reductionCode = reductionCode @ "zl = 0.0;\n";
					       	    };
				     }
			  	DD : {
				         match (polynomialVariableFormat) with 
					       D  : {
	                                                reductionCode = reductionCode @ "zh = (xh + rescaled_m_hi) + xm;\n";
					       	    }
					       DD : {
					                variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,xm);\n";
					       	    }
					       TD : {
					                variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,xm);\n";
                                                        reductionCode = reductionCode @ "zl = 0.0;\n";												       	  
					       	    };
				     }
			  	TD : {
				         match (polynomialVariableFormat) with 
					       D  : {
	                                                reductionCode = reductionCode @ "zh = (xh + rescaled_m_hi) + (xm + xl);\n";
					       	    }
					       DD : {
					                variableDeclarations = variableDeclarations @ "double tempArgRed1;\n";
					                variableDeclarations = variableDeclarations @ "double tempArgRed2;\n";
	                                                reductionCode = reductionCode @ "tempArgRed1 = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "tempArgRed2 = xm + xl;\n";
	                                                reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed1,tempArgRed2);\n";
					       	    }
					       TD : {
					                variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
					                variableDeclarations = variableDeclarations @ "double tempArgRed_hi;\n";
					                variableDeclarations = variableDeclarations @ "double tempArgRed_mi;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "Add12Cond(tempArgRed_hi,tempArgRed_mi,tempArgRed,xm);\n";
                                                        reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed_hi,tempArgRed_mi,xl);\n";
					       	    };
				     };				     
		     }
		DD : {
		          match (variableFormat) with 
			  	D  : {
				         match (polynomialVariableFormat) with 
					       D  : {
	                                                reductionCode = reductionCode @ "zh = (xh + rescaled_m_hi) + rescaled_m_mi;\n";
					       	    }
					       DD : {
					       	        variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
						        reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,rescaled_m_mi);\n";
					       	    }
					       TD : {
					       	        variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
						        reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,rescaled_m_mi);\n";
						        reductionCode = reductionCode @ "zl = 0.0;\n";
					       	    };
				     }
			  	DD : {
				         match (polynomialVariableFormat) with 
					       D  : {
	                                                reductionCode = reductionCode @ "tempArgRed = ((xh + rescaled_m_hi) + xm) + rescaled_m_mi;\n";	
					       	    }
					       DD : {
					                reductionCode = reductionCode @ "Add22(&zh,&zm,xh,xm,rescaled_m_hi,rescaled_m_mi);\n";
					       	    }
					       TD : {
					       	        variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Add12Cond(tempArgRed2_hi,tempArgRed2_lo,xm,rescaled_m_hi);\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed,tempArgRed2_hi,tempArgRed2_lo);\n";
					       	    };
				     }
			  	TD : {
				         match (polynomialVariableFormat) with 
					       D  : {
					                reductionCode = reductionCode @ "tempArgRed = (((xh + rescaled_m_hi) + xm) + rescaled_m_mi) + xl;\n";	
					       	    }
					       DD : {
					       	        variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,xl);\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
					       	    }
					       TD : {
					       		variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed4;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,xl);\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed3_hi,&tempArgRed3_mi,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
							tempArgRed4 = tempArgRed3_lo + tempArgRed2_lo;
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed3_hi,tempArgRed3_mi,tempArgRed4);\n";
					       	    };
				     };				     
	             }
		TD : {
		          match (variableFormat) with 
			  	D  : {
				         match (polynomialVariableFormat) with 
					       D  : {
	                                                reductionCode = reductionCode @ "zh = ((xh + rescaled_m_hi) + rescaled_m_mi) + rescaled_m_lo;\n";
					       	    }
					       DD : {
							variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed2,tempArgRed,rescaled_m_mi,rescaled_m_lo);\n";
					       	    }
					       TD : {
							variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed,rescaled_m_mi,rescaled_m_lo);\n";
					       	    };
				     }
			  	DD : {
				         match (polynomialVariableFormat) with 
					       D  : {
	                                                reductionCode = reductionCode @ "zh = (((xh + rescaled_m_hi) + xm) + rescaled_m_mi) + rescaled_m_lo;\n";
					       	    }
					       DD : {
					       		variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed4;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed5;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,rescaled_m_lo);\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed3_hi,&tempArgRed3_mi,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
							tempArgRed4 = tempArgRed3_lo + tempArgRed2_lo;
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed5,tempArgRed3_hi,tempArgRed3_mi,tempArgRed4);\n";
					       	    }
					       TD : {
					       		variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed4;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,rescaled_m_lo);\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed3_hi,&tempArgRed3_mi,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
							tempArgRed4 = tempArgRed3_lo + tempArgRed2_lo;
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed3_hi,tempArgRed3_mi,tempArgRed4);\n";
					       	    };
				     }
			  	TD : {
				         match (polynomialVariableFormat) with 
					       D  : {
	                                                reductionCode = reductionCode @ "zh = ((((xh + rescaled_m_hi) + xm) + rescaled_m_mi) + xl) + rescaled_m_lo;\n";
					       	    }
					       DD : {
							variableDeclarations = variableDeclarations @ "double tempArgRed_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2;\n";     
							reductionCode = reductionCode @ "Add33(&tempArgRed_hi,&tempArgRed_mi,&tempArgRed_lo,xh,xm,xl,rescaled_m_hi,rescaled_m_mi,rescaled_m_lo);\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed2,tempArgRed_hi,tempArgRed_mi,tempArgRed_lo);\n";
					       	    }
					       TD : {
							variableDeclarations = variableDeclarations @ "double tempArgRed_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed_lo;\n";
							reductionCode = reductionCode @ "Add33(&tempArgRed_hi,&tempArgRed_mi,&tempArgRed_lo,xh,xm,xl,rescaled_m_hi,rescaled_m_mi,rescaled_m_lo);\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed_hi,tempArgRed_mi,tempArgRed_lo);\n";
					       	    };
				     };				     
	             };

	  if (tableWidth > 0) then {
          match (outputformat) with 
                D  : {
			match (tableFormat) with 
			      D  : {
					variableDeclarations = variableDeclarations @ "double table_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "tableTimesPoly_hi = table_hi * poly_resh;\n";
			      	   }
			      DD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_lo;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr2;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul12(&tempReconstr_hi,&tempReconstr_lo,table_hi,poly_resh);\n";
					reconstructionCode = reconstructionCode @ "tempReconstr2 = table_mi * poly_resh;\n";					
					reconstructionCode = reconstructionCode @ "tableTimesPoly_hi = tempReconstr_hi + (tempReconstr_lo + tempReconstr2);\n";					
			      	   }
		              TD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
				        variableDeclarations = variableDeclarations @ "double table_lo;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_lo;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr2_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr2_lo;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr3_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr3_lo;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr4;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_lo = " @ functionName @ "_twoPower_Index_Lo[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul12(&tempReconstr_hi,&tempReconstr_lo,table_hi,poly_resh);\n";
					reconstructionCode = reconstructionCode @ "Mul12(&tempReconstr2_hi,&tempReconstr2_lo,table_mi,poly_resh);\n";
					reconstructionCode = reconstructionCode @ "Add12Cond(tempReconstr3_hi,tempReconstr3_lo,tempReconstr_lo,tempReconstr2_hi);\n";		
					reconstructionCode = reconstructionCode @ "tempReconstr4 = table_lo * poly_resh;\n";										
					reconstructionCode = reconstructionCode @ "tableTimesPoly_hi = (((tempReconstr4 + tempReconstr2_lo) + tempReconstr3_lo) + tempReconstr3_hi) + tempReconstr_hi;\n";
			      	   };
		     }
                DD : {
		        match (tableFormat) with 
			      D  : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul122(&tableTimesPoly_hi,&tableTimesPoly_mi,table_hi,poly_resh,poly_resm);\n";					
			      	   }
			      DD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul22(&tableTimesPoly_hi,&tableTimesPoly_mi,table_hi,table_mi,poly_resh,poly_resm);\n";					
			      	   }
		              TD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
				        variableDeclarations = variableDeclarations @ "double table_lo;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_mi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_lo;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr2;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_lo = " @ functionName @ "_twoPower_Index_Lo[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul233(&tempReconstr_hi,&tempReconstr_mi,&tempReconstr_lo,poly_resh,poly_resm,table_hi,table_mi,table_lo);\n";					
					reconstructionCode = reconstructionCode @ "Renormalize3(&zh,&zm,&tempReconstr2,tempReconstr_hi,tempReconstr_mi,tempReconstr_lo);\n";					
			      	   };
                     }
                TD : {
			match (tableFormat) with 
			      D  : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_lo;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul133(&tableTimesPoly_hi,&tableTimesPoly_mi,&tableTimesPoly_lo,table_hi,poly_resh,poly_resm,poly_resl);\n";					
			      	   }
			      DD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_lo;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul233(&tableTimesPoly_hi,&tableTimesPoly_mi,&tableTimesPoly_lo,table_hi,table_mi,poly_resh,poly_resm,poly_resl);\n";
			      	   }
		              TD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
				        variableDeclarations = variableDeclarations @ "double table_lo;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_lo;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_lo = " @ functionName @ "_twoPower_Index_Lo[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul33(&tableTimesPoly_hi,&tableTimesPoly_mi,&tableTimesPoly_lo,table_hi,table_mi,table_lo,poly_resh,poly_resm,poly_resl);\n";
			      	   };
                     };
          };
          
	  variableDeclarations = variableDeclarations @ "db_number twoE1;\n";
	  reconstructionCode = reconstructionCode @ "twoE1.l = E1 + 1023ll;\n"; 
	  reconstructionCode = reconstructionCode @ "twoE1.l <<= 52;\n"; 
	  variableDeclarations = variableDeclarations @ "db_number twoE2;\n";
	  reconstructionCode = reconstructionCode @ "twoE2.l = E2 + 1023ll;\n"; 
	  reconstructionCode = reconstructionCode @ "twoE2.l <<= 52;\n"; 

	  if (tableWidth > 0) then {
          match (outputformat) with 
                D  : {
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_hi = twoE1.d * tableTimesPoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1tablePoly_hi;\n";
		     }
		DD : {
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_hi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_mi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_hi = twoE1.d * tableTimesPoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_mi = twoE1.d * tableTimesPoly_mi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1tablePoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1tablePoly_mi;\n";
		     }
		TD : {
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_hi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_mi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_lo;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_hi = twoE1.d * tableTimesPoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_mi = twoE1.d * tableTimesPoly_mi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_lo = twoE1.d * tableTimesPoly_lo;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1tablePoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1tablePoly_mi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resl = twoE2.d * twoE1tablePoly_lo;\n";
		     };
          } else {          
          match (outputformat) with 
                D  : {
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_hi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_hi = twoE1.d * poly_resh;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1Poly_hi;\n";
		     }
		DD : {
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_hi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_mi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_hi = twoE1.d * poly_resh;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_mi = twoE1.d * poly_resm;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1Poly_hi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1Poly_mi;\n";
		     }
		TD : {
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_hi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_mi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_lo;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_hi = twoE1.d * poly_resh;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_mi = twoE1.d * poly_resm;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_lo = twoE1.d * poly_resl;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1Poly_hi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1Poly_mi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resl = twoE2.d * twoE1Poly_lo;\n";
		     };
	  };

	  code = "\n";
	  code = code @ "void " @ functionName @ "(";
	  code = code @ (match outputformat with 
                               D   : ( "double *res_resh, " )
                               DD  : ( "double *res_resh, double *res_resm, " )
                               TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                        );
          code = code @ (match variableFormat with 
                               D   : ( "double xh" )
                               DD  : ( "double xh, double xm" )
                               TD  : ( "double xh, double xm, double xl" )
                        );
          code = code @ ") {\n";
          code = code @ (match polynomialVariableFormat with 
                               D   : ( "double zh;" )
                               DD  : ( "double zh, zm;" )
                               TD  : ( "double zh, zm, zl;" )
                        );
          code = code @ "\n";
          code = code @ (match outputformat with 
                               D   : ( "double poly_resh;" )
                               DD  : ( "double poly_resh, poly_resm;" )
                               TD  : ( "double poly_resh, poly_resm, poly_resl;" )
                        );
          code = code @ "\n";
	  code = code @ variableDeclarations @ "\n";
	  code = code @ reductionCode @ "\n";
          code = code @ polynomialFunctionName @ "(";				  
          code = code @ (match outputformat with 
                               D   : ( "&poly_resh, " )
                               DD  : ( "&poly_resh, &poly_resm, " )
                               TD  : ( "&poly_resh, &poly_resm, &poly_resl, " )
                        );
          code = code @ (match polynomialVariableFormat with 
                               D   : ( "zh" )
                               DD  : ( "zh, zm" )
                               TD  : ( "zh, zm, zl" )
                        );
          code = code @ ");\n";				  
	  code = code @ reconstructionCode @ "\n";
          code = code @ "}\n";

	  if (okay) then {
	     result.code = table @ code;
	     result.okay = true;
	  };

	  return result;
};

procedure tryImplementationThroughArgumentReductionExponential(problemdef, parametrization) {
	  var result, needArgumentReduction, res, myTableWidth, base, myDom, reducedFunc;
	  var doNotPerformExponentialArgRed, argRedTarget, myVariableFormat, myProblemdef, myParametrization;
	  var suffix, origDefDom, resArgRed;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with 
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default, 
				       .tableIndexWidth = default } } : {
				       
				       /* Test if we may perform this type of argument
				          reduction
				       */
				       doNotPerformExponentialArgRed = false;
				       match (parametrization) with 
				             { .doNotPerformExponentialArgRed = true } : { doNotPerformExponentialArgRed = true; }
					     default : { };

				       if (!doNotPerformExponentialArgRed) then {
				           /* Start with a test if the domain actually needs 
                                              argument reduction in order to stay below the maximum 
					      polynomial degree 
				           */	     
				           needArgumentReduction = true;
				           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                                   if (res.okay) then {
   	                                       if (res.sufficientDegree) then needArgumentReduction = false;
				           } else {
				               needArgumentReduction = false;
				           };

				           if (needArgumentReduction) then {
				       	      /* Here, we need to detect if we can use 
					         the exponential argument reduction 
					         for the given function 
					      */
					      res = tryDetectExponentialArgRed(problemdef.func, problemdef.dom, problemdef.target * 1/8);
					       
					      if (res.okay) then {
					         /* Here we can use the argument reduction for (res.exponentialBase)^x = res.exponentialFunc 

					            We start by computing the range of the reduced argument.
						
						    We have

						    base^x = 2^k * a^(x - k * log(2)/log(base))

						    where k is computed as

						    k = 2^(-w) * nearestint(x * log2(base) * 2^w)

						    where w is the table index width.

						    Hence the reduced argument z = x - k * log(2)/log(base)
						    varies in the domain

						    myDom = [ -2^(-w-1) * log(2)/log(base) ; 2^(-w-1) * log(2)/log(base) ]
					         */
					         base = res.exponentialBase;
					         reducedFunc = res.exponentialFunc;
		                                 write("Detected possible argument reduction as base^x, where base is approximately: ", round(base,24,RN), "\n");
					         myTableWidth = parametrization.tableIndexWidth;
					         if (myTableWidth < 0) then myTableWidth = 0;
					     
					         myDom = [ -2^(-myTableWidth-1) * log(2)/log(base);
					                    2^(-myTableWidth-1) * log(2)/log(base)];
							
					         write("The reduced argument domain is ", myDom, "\n");

				                 /* Now we have to check if the "argument reduction"
					            actually reduces the size of the argument range.
						    If not, base is too small for our table size
						    and we'd better apply some other technique.
				                 */
					         if (sup(myDom) - inf(myDom) < sup(problemdef.dom) - inf(problemdef.dom)) then {
					     	    /* Now we can try to implement our reduced function.
						       We have to add a marker to the parametrization
						       in order not to re-perform an argument reduction
						       of the same type.

						       To do so, we have to determine the precision
						       needed for the reduced argument.
						       						       
						       It is pretty easy to show that the amplified
                                                       forward error of the argument reduction eps2 
						       can be expressed as

						       eps2 = base^(eps1 * z) - 1

						       where z is the reduced argument and eps1 is
						       the relative error on the reduced argument.
						       In order to keep eps2 at 1/8 * target, eps1
						       must hence be bounded by

						       abs(eps1) <= min( abs(log(1 - 1/8 * target) / log(base^inf(myDom))),
						                         abs(log(1 - 1/8 * target) / log(base^sup(myDom))),
						                         abs(log(1 + 1/8 * target) / log(base^inf(myDom))),
						                         abs(log(1 + 1/8 * target) / log(base^sup(myDom))) )
						    */
						    argRedTarget = min( abs(log(1 - 1/8 * (problemdef.target)) / log(base^inf(myDom))),
						                        abs(log(1 - 1/8 * (problemdef.target)) / log(base^sup(myDom))),
						                        abs(log(1 + 1/8 * (problemdef.target)) / log(base^inf(myDom))),
						                        abs(log(1 + 1/8 * (problemdef.target)) / log(base^sup(myDom))) );

					            write("The maximum error allowed for argument reduction is 2^(", round(log2(argRedTarget),12,RN), ")\n");
						    if (argRedTarget < 1b-102) then myVariableFormat = TD
						    else if (argRedTarget < 1b-51) then myVariableFormat = DD
						    else myVariableFormat = D;
						    if (problemdef.variableFormat == TD) then myVariableFormat = TD
						    else if (problemdef.variableFormat == DD) then myVariableFormat = DD;
						    write("This means the reduced argument will be represented on a ", myVariableFormat, "\n");
						    
						    myProblemdef.func = reducedFunc;
						    myProblemdef.dom = myDom;
						    myProblemdef.target = 1/8 * (problemdef.target);
						    myProblemdef.variableFormat = myVariableFormat;
						    suffix = "_exp_arg_red";
					            origDefDom = problemdef.dom;
					            match (problemdef) with { .definitionDomain = default } : { 
					                                         if (origDefDom in problemdef.definitionDomain) then {
                                                                                    origDefDom = problemdef.definitionDomain;
                                                                                 }; }
                                                                            default : {};
					            myProblemdef.definitionDomain = origDefDom;
					            myParametrization = parametrization;
					            myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					            myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					            myParametrization.functionBasename = parametrization.functionBasename @ suffix;
						    myParametrization.doNotPerformExponentialArgRed = true;
						    
					            res = tryImplementation(myProblemdef, myParametrization);

						    if (res.okay) then {
						       write("Implementation of the approximation on the reduced domain worked, generating argument reduction and tables\n");
						       resArgRed = tryGenerateExponentialArgumentReduction(base, problemdef.dom, parametrization.functionBasename, 
						                                                           res.functionname, res.outputformat, myVariableFormat, problemdef.variableFormat, 
													   argRedTarget, 1/8 * (problemdef.target), myTableWidth);

						       if (resArgRed.okay) then {
						          write("Argument reduction code correctly generated\n");
						          write(resArgRed.code) >> parametrization.implementationFile;
							  result.okay = true;
	                                                  result.approxerr = res.approxerr;
							  result.implerr = res.implerr;
							  result.outputformat = res.outputformat;
						          result.functionname = parametrization.functionBasename;
						       } else {
                                                          write("No argument reduction code could be generated\n");
						       };
						    };						    
					         };
					      };
				           };
				         };
				     }
                default : { };

	  return result;
};

procedure dirtyEvaluateImage(f,dom) {
	  var fDiff, zeros, z, fmin, fmax, y;

	  fDiff = diff(f);
	  zeros = (dirtyfindzeros(fDiff,dom)) :. (sup(dom));
	  fmin = inf(evaluate(f,inf(dom)));
	  fmax = sup(evaluate(f,inf(dom)));
	  for z in zeros do {
	      y = evaluate(f,z);
	      if (inf(y) < fmin) then fmin = inf(y);
	      if (sup(y) > fmax) then fmax = sup(y);
	  };
	  
	  return [ fmin; fmax ];
};

procedure tryDetectExponentialBehaviorArgRed(func, dom, maxReducRatio) {
	  var result, base, a, b, c, d, ratio, oldPrec, testfunc;
	  var yOrig, yReduc, widthOrig, withReduc, reducRatio;


	  result = { .okay = false };

	  /* We have to detect if func behaves in dom 
	     like 

	     base^x for some unknown base

	     We say that func behaves like base^x 
	     if 

	     base^x = func * (1 + eps) with abs(eps) <= target.
	     
	     We start by computing a possible base
	     as

	     base = exp((log(f(c+d)/f(c))/d))
	     
	     with 

	       - d = b - a                  if b - a < 5
	         c = a

	       - d = 5                      otherwise
                 c = max(a, (a+b)/2 - 2.5) 

             where dom = [a;b]

	     We can stop trying if f(c+d)/f(c) is 
	     negative.
	  */	     
	  a = inf(dom);
	  b = sup(dom);
	  if (b - a < 5) then {
	     d = b - a;
	     c = a;
	  } else {
	     d = 5;
	     c = max(a, (a + b)/2 - 2.5);
	  };
	  ratio = f(c + d) / f(c);
	  if (ratio > 0) then {
	     /* Here, f(c + d) / f(c) is positive 

	        So we can compute a presumed base 
		as 

		base = exp(log(ratio)/d)

		where ratio = f(c + d) / f(c)

		We need to perform this evaluation 
		with an accuracy of at least the 
		double of the prevailing precision
		as the rest of the argument reduction
		code must receive a pretty accurate 
		base.

	     */
	     oldPrec = prec;
	     prec = max(2 * prec, ceil(-log2(abs(target))) * 3)!;
	     base := exp(log(ratio) / d);
	     prec = oldPrec!;

	     /* Now check if dividing the given function by 
	        base^x reduces the output domain for the factor g(x):

		f(x) = base^x * g(x).
             */
 	     testfunc = simplifysafe(func/(base^x));
	     yOrig = dirtyEvaluateImage(func,dom);
	     yReduc = dirtyEvaluateImage(testfunc,dom);
	     widthOrig = sup(yOrig) - inf(yOrig);
	     widthReduc = sup(yReduc) - inf(yReduc);
	     reducRatio = widthReduc / widthOrig;

	     if (reducRatio <= maxReducRatio) then {
	     	result.okay = true;
		result.g = base^x;
		result.h = testfunc;
	     };
	  };
	  return result;
};

procedure tryImplementationThroughArgumentReductionWithExponentialBehavior(problemdef, parametrization) {
	  var result, needArgumentReduction, res, myTableWidth, base, myDom, reducedFunc;
	  var doNotPerformExponentialArgRed, argRedTarget, myVariableFormat, myProblemdef, myParametrization;
	  var suffix, origDefDom, resArgRed, doNotPerformExponentialBehaviorArgRed, g, h, res2, myOutputFormat;
	  var implementationcode;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with 
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default, 
				       .tableIndexWidth = default,
				       .minimalReductionRatio = default } } : {
				       
				       /* Test if we may perform this type of argument
				          reduction
				       */
				       doNotPerformExponentialArgRed = false;
				       doNotPerformExponentialBehaviorArgRed = false;
				       match (parametrization) with 
				             { .doNotPerformExponentialArgRed = true } : { doNotPerformExponentialArgRed = true; }
					     { .doNotPerformExponentialBehaviorArgRed = true } : { doNotPerformExponentialBehaviorArgRed = true; }
					     default : { };

				       if (!(doNotPerformExponentialArgRed || doNotPerformExponentialBehaviorArgRed)) then {
				           /* Start with a test if the domain actually needs 
                                              argument reduction in order to stay below the maximum 
					      polynomial degree 
				           */	     
				           needArgumentReduction = true;
				           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                                   if (res.okay) then {
   	                                       if (res.sufficientDegree) then needArgumentReduction = false;
				           } else {
				               needArgumentReduction = false;
				           };

				           if (needArgumentReduction) then {
				       	      /* Here, we need to detect if we can use 
					         the exponential argument reduction 
					         for the given function 
					      */
					      res = tryDetectExponentialBehaviorArgRed(problemdef.func, problemdef.dom, (1 / parametrization.minimalReductionRatio));
					       
					      if (res.okay) then {
					      	 write("Argument reduction detection detected that the function can be split into f = g * h with\n");
						 write("    g(x) = ", res.g, " and\n");
						 write("    h(x) = ", res.h, "\n");
						 g = res.g;
						 h = res.h;

						 write("Trying to implement g\n");
						 myProblemdef.func = g;
						 myProblemdef.dom = problemdef.dom;
						 myProblemdef.target = 1/8 * (problemdef.target);
						 myProblemdef.variableFormat = problemdef.variableFormat;
						 suffix = "_exp_behav_split_g";
					         origDefDom = problemdef.dom;
					         match (problemdef) with { .definitionDomain = default } : { 
					                                      if (origDefDom in problemdef.definitionDomain) then {
                                                                                 origDefDom = problemdef.definitionDomain;
                                                                              }; }
                                                                         default : {};
					         myProblemdef.definitionDomain = origDefDom;
					         myParametrization = parametrization;
					         myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					         myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					         myParametrization.functionBasename = parametrization.functionBasename @ suffix;
						 myParametrization.doNotPerformExponentialBehaviorArgRed = true;
						 
					         res = tryImplementation(myProblemdef, myParametrization);

						 if (res.okay) then {
						    write("Subfunction g correctly implemented\n");

						    write("Trying to implement h\n");
						    myProblemdef.func = h;
						    myProblemdef.dom = problemdef.dom;
						    myProblemdef.target = 1/8 * (problemdef.target);
						    myProblemdef.variableFormat = problemdef.variableFormat;
						    suffix = "_exp_behav_split_h";
					            origDefDom = problemdef.dom;
					            match (problemdef) with { .definitionDomain = default } : { 
					                                         if (origDefDom in problemdef.definitionDomain) then {
                                                                                    origDefDom = problemdef.definitionDomain;
                                                                                 }; }
                                                                            default : {};
					            myProblemdef.definitionDomain = origDefDom;
					            myParametrization = parametrization;
					            myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					            myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					            myParametrization.functionBasename = parametrization.functionBasename @ suffix;
						    myParametrization.doNotPerformExponentialBehaviorArgRed = true;
						    myParametrization.implementationFile = parametrization.implementationFile @ "_subfunction_h";
						 
					            res2 = tryImplementation(myProblemdef, myParametrization);

						    if (res2.okay) then {
						       write("Subfunction h correctly implemented\n");
						 
						       bashexecute("cat " @ parametrization.implementationFile @ "_subfunction_h >> " @ parametrization.implementationFile);
						       myOutputFormat = res.outputformat;
						       match (res2.outputformat) with 
						       	     D  : { }
							     DD : { if (myOutputFormat == D) then myOutputFormat = DD; }
							     TD : { myOutputFormat = TD; };
						       implementationcode = "\n";
						       implementationcode = implementationcode @ "void " @ parametrization.functionBasename @ "(";
						       implementationcode = implementationcode @ (match myOutputFormat with
						       			    		       	 	D  : ( "double *res_resh, " )
													DD : ( "double *res_resh, double *res_resm, " )
													TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
						       implementationcode = implementationcode @ (match problemdef.variableFormat with 
						       			    		       	 	D  : ( "double xh" )
													DD : ( "double xh, double xm" )
													TD : ( "double xh, double xm, double xl"));
				                       implementationcode = implementationcode @ ") {\n";
						       match (res.outputformat) with 
						       	     D  : {
									implementationcode = implementationcode @ "double res_g_resh;\n";									
							     	  }
						       	     DD : {
									implementationcode = implementationcode @ "double res_g_resh;\n";									
									implementationcode = implementationcode @ "double res_g_resm;\n";									
							     	  }
						       	     TD : {
									implementationcode = implementationcode @ "double res_g_resh;\n";									
									implementationcode = implementationcode @ "double res_g_resm;\n";									
									implementationcode = implementationcode @ "double res_g_resl;\n";									
							     	  };
						       match (res2.outputformat) with 
						       	     D  : {
									implementationcode = implementationcode @ "double res_h_resh;\n";									
							     	  }
						       	     DD : {
									implementationcode = implementationcode @ "double res_h_resh;\n";									
									implementationcode = implementationcode @ "double res_h_resm;\n";									
							     	  }
						       	     TD : {
									implementationcode = implementationcode @ "double res_h_resh;\n";									
									implementationcode = implementationcode @ "double res_h_resm;\n";									
									implementationcode = implementationcode @ "double res_h_resl;\n";									
							     	  };
						       implementationcode = implementationcode @ "\n";
						       implementationcode = implementationcode @ res.functionname @ "(";
						       implementationcode = implementationcode @ (match (res.outputformat) with 
						       			    		       	 	D  : ( "&res_g_resh, " )
													DD : ( "&res_g_resh, &res_g_resm, " )
													TD : ( "&res_g_resh, &res_g_resm, &res_g_resl, "));
						       implementationcode = implementationcode @ (match (problemdef.variableFormat) with 
						       			    		       	 	D  : ( "xh" )
													DD : ( "xh, xm" )
													TD : ( "xh, xm, xl" ));
						       implementationcode = implementationcode @ ");\n";
                                                       implementationcode = implementationcode @ res2.functionname @ "(";
						       implementationcode = implementationcode @ (match (res2.outputformat) with 
						       			    		       	 	D  : ( "&res_h_resh, " )
													DD : ( "&res_h_resh, &res_h_resm, " )
													TD : ( "&res_h_resh, &res_h_resm, &res_h_resl, "));
						       implementationcode = implementationcode @ (match (problemdef.variableFormat) with 
						       			    		       	 	D  : ( "xh" )
													DD : ( "xh, xm" )
													TD : ( "xh, xm, xl" ));
						       implementationcode = implementationcode @ ");\n";
						       match (myOutputFormat) with 
						       	     D  : {
									implementationcode = implementationcode @ "*res_resh = res_g_resh * res_h_resh;\n";
                                                                  }
						             DD : {
									match (res.outputformat) with 
									      D  : {
											implementationcode = implementationcode @ "Mul122(res_resh,res_resm,res_g_resh,res_h_resh,res_h_resm);\n";
									      	   }
								              DD : {
											match (res2.outputformat) with 
											      D  : {
											      	        implementationcode = implementationcode @ "Mul122(res_resh,res_resm,res_h_resh,res_g_resh,res_g_resm);\n";
												   }
										              DD : {
											                implementationcode = implementationcode @ "Mul22(res_resh,res_resm,res_g_resh,res_g_resm,res_h_resh,res_h_resm);\n";
												   };
									      	   };
							          }
							     TD : {
									match (res.outputformat) with 
									      D  : {
									      		implementationcode = implementationcode @ "Mul133(res_resh,res_resm,res_resl,res_g_resh,res_h_resh,res_h_resm,res_h_resl);\n";   
									      	   }
									      DD : {
									      		implementationcode = implementationcode @ "Mul233(res_resh,res_resm,res_resl,res_g_resh,res_g_resm,res_h_resh,res_h_resm,res_h_resl);\n";   
									      	   }
									      TD : {
											match (res2.outputformat) with
											      D  : {
											      	        implementationcode = implementationcode @ "Mul133(res_resh,res_resm,res_resl,res_h_resh,res_g_resh,res_g_resm,res_g_resl);\n";
											      	   }
											      DD : {
											      	        implementationcode = implementationcode @ "Mul233(res_resh,res_resm,res_resl,res_h_resh,res_h_resm,res_g_resh,res_g_resm,res_g_resl);\n";
											      	   }
											      TD : {
											      	        implementationcode = implementationcode @ "Mul33(res_resh,res_resm,res_resl,res_h_resh,res_h_resm,res_h_resl,res_g_resh,res_g_resm,res_g_resl);\n";
											      	   };
									      	   };								              
							     	  };					
						       implementationcode = implementationcode @ "}\n";
						       write(implementationcode) >> parametrization.implementationFile;
						       result = res;
						       result.outputformat = myOutputFormat;
						       result.functionname = parametrization.functionBasename;
						    } else {
						      write("Could not implement subfunction h\n");
						    };
						 } else {
						   write("Could not implement subfunction g\n");
						 };
					      };
				           };
				         };
				     }
                default : { };

	  return result;
};

procedure tryImplementationConstant(problemdef, parametrization) {
	  var result, func, dom, target, ya, yb, yc, myConst, testfunc, oldPrec;
	  var y, zerosUpper, zerosLower, myConstHi, myConstMi, myConstLo, myConstFormat;
	  var implementation, oldDisplay;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with 
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default 
				     } } : {
				       func = problemdef.func;
				       dom = problemdef.dom;
				       target = problemdef.target;
				       oldPrec = prec;
				       prec = max(prec, -floor(log2(target)) * 4)!;
				       ya = mid(evaluate(func,inf(dom)));
				       yb = mid(evaluate(func,sup(dom)));
				       yc = mid(evaluate(func,mid(dom)));
				       myConst := (ya + yb + yc) / 3;
				       prec = oldPrec!;
				       if ((abs(ya - yb) <= abs(ya * 1/4 * target)) && 
				       	   (abs(ya - yc) <= abs(ya * 1/4 * target)) && 
					   (abs(yb - yc) <= abs(yb * 1/4 * target))) then {
					  testfunc = simplifysafe((myConst/func) - 1);
          	                          y = evaluate(testfunc, mid(dom));
	                                  if (y in [-1/4 * target, 1/4 * target]) then {
	  	                             zerosUpper = dirtyfindzeros(testfunc + 1/4 * target, dom);
	  	                             zerosLower = dirtyfindzeros(testfunc - 1/4 * target, dom);

		                             if ((zerosUpper == [||]) && (zerosLower == [||])) then {
		  			     	write("Trying to replace the given function by the constant ", myConst, "\n");
						myConstHi = simplifysafe(D(myConst));
						myConstMi = simplifysafe(D(myConst - myConstHi));
						myConstLo = simplifysafe(D(myConst - (myConstHi + myConstMi)));
						if (abs(1/4 * target) < 1b-107) then {
						   myConstFormat = TD;
						   if (myConstLo == 0) then {
						      myConstFormat = DD;
						      if (myConstMi == 0) then {
						      	 myConstFormat = D; 
						      };
						   };
						} else {
						  if (abs(1/4 * target) < 1b-53) then {
						    myConstFormat = DD;
						    if (myConstMi == 0) then {
						       myConstFormat = D;
						    };
						  } else {
						    myConstFormat = D;
						  };
						};
						
						implementation = "\n";
						oldDisplay = display;
						display = decimal!;
						match myConstFormat with 
						      D  : {
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_hi " @ myConstHi @ "\n";
						           }
						      DD : {
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_hi " @ myConstHi @ "\n";
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_mi " @ myConstMi @ "\n";
						           }
						      TD : {
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_hi " @ myConstHi @ "\n";
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_mi " @ myConstMi @ "\n";
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_lo " @ myConstLo @ "\n";
						           };
						implementation = implementation @ "\n";	   
						display = oldDisplay!;
						implementation = implementation @ "void " @ parametrization.functionBasename @ "(";
						match myConstFormat with 
						      D  : { 
						      	     implementation = implementation @ "double *res_resh, ";
							   }
						      DD : { 
						      	     implementation = implementation @ "double *res_resh, double *res_resm, ";
							   }
						      TD : { 
						      	     implementation = implementation @ "double *res_resh, double *res_resm, double *res_resl, ";
							   };							   			
						match problemdef.variableFormat with 
						      D  : {
							     implementation = implementation @ "double xh";
							   }
						      DD : {
							     implementation = implementation @ "double xh, double xm";
							   }
						      TD : {
							     implementation = implementation @ "double xh, double xm, double xl";
							   };
					        implementation = implementation @ ") {\n";
						match myConstFormat with 
						      D  : { 
						      	     implementation = implementation @ "*res_resh = " @ parametrization.functionBasename @ "_const_hi;\n";
							   }
						      DD : { 
						      	     implementation = implementation @ "*res_resh = " @ parametrization.functionBasename @ "_const_hi;\n";
						      	     implementation = implementation @ "*res_resm = " @ parametrization.functionBasename @ "_const_mi;\n";
							   }
						      TD : { 
						      	     implementation = implementation @ "*res_resh = " @ parametrization.functionBasename @ "_const_hi;\n";
						      	     implementation = implementation @ "*res_resm = " @ parametrization.functionBasename @ "_const_mi;\n";
						      	     implementation = implementation @ "*res_resl = " @ parametrization.functionBasename @ "_const_lo;\n";
							   };							   			
					        implementation = implementation @ "}\n\n";
						write(implementation) > parametrization.implementationFile;
						result.okay = true;
						myFinalConst = match myConstFormat with 
						 	       	     D  : (myConstHi)
								     DD : (myConstHi + myConstMi)
								     TD : (myConstHi + myConstMi + myConstLo);
						result.approxerr = dirtyinfnorm(myFinalConst/func - 1,dom);
						result.implerr = 0;    
         					result.outputformat = myConstFormat;
          					result.functionname = parametrization.functionBasename;
				             };
				          };
				       };
				     }
                default : { };

	  return result;
};

procedure tryImplementation(problemdef, parametrization) {
	  var result, res, tryImplementationInstance, tryImplementationChoices;
	  var okay;

	  result = { .okay = false };

	  tryImplementationChoices = [| tryImplementationConstant,
	                                tryImplementationThroughArgumentReductionExponential, 
                                        tryImplementationThroughArgumentReductionWithExponentialBehavior, 
                                        tryImplementationThroughSymmetryDetectionAroundZero, 
                                        tryImplementationThroughDomainSplitting |];

	  okay = false;
	  while ((!okay) && (tryImplementationChoices != [||])) do {
	          tryImplementationInstance = head(tryImplementationChoices);
		  tryImplementationChoices = tail(tryImplementationChoices);
	          res = tryImplementationInstance(problemdef, parametrization);

		  if (res.okay) then {
		     result = res;
		     okay = true;
		  };
	  };

	  return result;
};

