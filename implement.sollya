/*
 * Copyright 2008-2013 by
 *
 * Laboratoire de l'Informatique du Parall√©lisme,
 * UMR CNRS - ENS Lyon - UCB Lyon 1 - INRIA 5668
 *
 * and by
 *
 * Laboratoire d'Informatique de Paris 6, equipe PEQUAN,
 * UPMC Universite Paris 06 - CNRS - UMR 7606 - LIP6, Paris, France.
 *
 * Sollya metalibm main procedures for implementing functions
 * with polynomial approximation and Horner scheme evaluation
 *
 * Contributor: Christoph Quirin Lauter (ENS Lyon/ UPMC LIP6 PEQUAN)
 *              christoph.lauter@ens-lyon.org
 *
 * This file is part of the metalibm library developed by the Arenaire
 * project at Ecole Normale Superieure de Lyon and by the equipe PEQUAN
 * at Universite Pierre et Marie Curie Paris 6.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/

execute("remezwrapper.sollya");
execute("upperbounds.sollya");
execute("vandercoeff.sollya");
execute("fpminimax.sollya");
execute("galoptimisation.sollya");
execute("symetries.sollya");
execute("inverse.sollya");

procedure targetErrorToImplementpolyType(err) {
	  var res;

	  if (abs(err) < 1b-101) then {
	     res = TD;
	  } else {
	    if (abs(err) < 1b-51) then {
	      res = DD;
	    } else {
	      res = D;	      
	    };
	  };

	  return res;
};

procedure myimplementpoly(l = ...) {
	  var res;
	  var myTarget, myVarFormat, myResFormat;
	  var oldDisplay, oldPrec;
	  
	  oldPrec = prec;
	  prec = 165!;

	  myTarget = l[2];
	  myVarFormat = l[3];	  
	  myResFormat = targetErrorToImplementpolyType(myTarget);
	  match myResFormat with 
	  	D  : {
			match (myVarFormat) with 
			      D  : { }
			      DD : {
					myTarget = 1b-54;
			      	   }
			      TD : {
					myTarget = 1b-103;
			      	   };		         
		     }
	        DD : {
			if (myVarFormat == TD) then {
			   myTarget = 1b-103;
			};
		     }
	        TD : { };		      

          oldDisplay = display;
	  display = dyadic!;
          match(length(l)) with 
	  	6 : { write("Calling implementpoly(",l[0],",",l[1],",",myTarget,",",myVarFormat,",",l[4],",",l[5],")\n"); }
		8 : { write("Calling implementpoly(",l[0],",",l[1],",",myTarget,",",myVarFormat,",",l[4],",",l[5],",",l[6],",",l[7],")\n"); }
		default : { };
          display = oldDisplay!;

	  res = match (length(l)) with
	  	6 : (implementpoly(l[0],l[1],myTarget,myVarFormat,l[4],l[5]))
		8 : (implementpoly(l[0],l[1],myTarget,myVarFormat,l[4],l[5],l[6],l[7]))
		default : (error);

          prec = oldPrec!;		    

	  return res;
};


procedure myfindzeros(func,dom) {
	  var zeros, numZeros, nz, minBound, maxBound, i, len, dist, z;
	  var oldPoints, valid, ya, yb;

	  oldPoints = points;
	  points = ((points - 1) * 2 + 1)!;

	  numZeros = mydirtyfindzeros(func,dom);
	  len = length(numZeros);
	  zeros = [||];
	  if ((len > 0) && (len < 500)) then {
	     	  dist = ((sup(dom) - inf(dom)) * diam)/2;
	  	  minBound = inf(dom);
	  	  for i from 0 to len-1 do {
		      if (i != len-1) then {
		      	maxBound = numZeros[i + 1] - dist;
		      } else {
		      	maxBound = sup(dom);
		      };
		      nz = numZeros[i];
		      z = [ max(minBound, nz - dist) ; min(maxBound, nz + dist) ];
		      zeros = zeros :. z;
		      minBound = maxBound;
	  	  };
		  valid = true;
		  for z in zeros do {
		      ya = mid(evaluate(func,inf(z)));
		      yb = mid(evaluate(func,sup(z)));
		      if (ya * yb > 0) then {
		      	 valid = false;
		      };
		  };
		  if (!valid) then {
		     zeros = findzeros(func,dom);
		  };
          } else {
	    	  if (len >= 500) then {
		    zeros = findzeros(func,dom);
		  } else {
		    zeros = [||];
		  };
	  };

	  points = oldPoints!;

	  return zeros;
};


/* Quickly checks if the infinite norm of func
   in dom is less than target

   Returns false if it is not
   Returns the infinite norm if it is

*/
procedure dirtycheckinfnorm(func,dom,target) {
	  var t, b, h, y, maxy;
	  var oldprec;
	  var res;
	  var infn;

	  oldprec = prec = ?;
	  prec = 20!;
	  t = inf(dom);
	  b = sup(dom);
	  h = round((b - t) / 64,12,RU);
	  maxy = 0;
	  while ((t <= b) && (maxy <= target)) do {
	  	maxy := abs(func(t));
		t = round(t + h,12,RU);
	  };
	  prec = oldprec!;

	  if ((maxy == maxy) && (maxy > target)) then
	      res = false
	  else {
	       infn = mydirtyinfnorm(func,dom);
	       if (infn > target) then {
	       	  write("Warning: dirtycheckinfnorm decides false case by dirtyinfnorm\n");
	       	  res = false;
	       } else res = infn;
 	  };

	  return res;
};


/* implementandcheck

   implements a polynomial in a domain for a given target error
   and checks whether the overall error is less than the target error

   approxerr may be false, in which case the procedure computes the infnorm

   Returns a list containing a boolean (works or not), a polynomial (the implemented one if works), an approx error and an evaluation error.

   The procedure may return false for problems with the implementation

*/
procedure implementandcheck(func,poly,dom,targeterr,targeterrimpl,approxerr,beta,variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName) {
	  var res;
	  var myapproxerr;
	  var q;
	  var implapproxerr;
	  var boundsList;
	  var evalerr;
	  var i;
	  var oldverb;
	  var gappaTime;

	  q = poly;

	  if (approxerr == false) then {
	    myapproxerr = mydirtyinfnorm(poly/func-1,dom);
	  } else {
	    myapproxerr = approxerr;
	  };
	  implapproxerr = myapproxerr;
	  evalerr = false;

	  // myapproxerr, targeterr;

	  res = (myapproxerr < targeterr);
	  if (res) then {
	     	q = myimplementpoly(poly,dom,targeterrimpl,variableFormat,polynomialName,implementationFile,honorcoeffprec,gappaFile);
		if (!(q == q)) then {
		   write("Something strange happened. The implementpoly command did not succeed\n");
		   oldverb = verbosity = ?;
		   verbosity = 2!;
	     	   q = myimplementpoly(poly,dom,targeterrimpl,variableFormat,polynomialName,implementationFile,honorcoeffprec,gappaFile);
		   verbosity = oldverb!;
		   q = poly;
		};
		if (horner(q) == horner(poly)) then {
		   implapproxerr = myapproxerr;
		} else {
		   implapproxerr = mydirtyinfnorm(q/func-1,dom);
		};
	        res = (implapproxerr < targeterr);
		if (res) then {
		   	write("boundsList = [|") > gappaOutputFile;
			gappaTime = time({
			                    bashexecute(gappaExecutable@" -Munconstrained < "@gappaFile@" 2>&1 | grep 'epsilon in' | sed -n 's/\\({[^}]*}\\)//g;p' | sed -n 's/epsilon in \\[//;p' | sed -n 's/\\]/,/;p' | sed -n 's/, /,\\n/;p' >> "@gappaOutputFile);
					 });
			wholeGappaTime := wholeGappaTime + gappaTime;
			print("0|];") >> gappaOutputFile;
			execute(gappaOutputFile);
			bashexecute("rm " @ gappaOutputFile);
			evalerr = 0;
			for i in boundsList do if (abs(i) > evalerr) then evalerr = abs(i);
			if (evalerr == 0) then evalerr := 1/0;

			if (abs(evalerr) > 1) then {
			     write("\tRe-running Gappa\n");
		   	     write("boundsList = [|") > gappaOutputFile;
			     gappaTime = time({
			                         bashexecute("cat "@gappaFile@" | sed -r 's/epsilon in /epsilon in ? #/g;' | "@gappaExecutable@" -Munconstrained 2>&1 | grep 'epsilon in' | sed -n 's/\\({[^}]*}\\)//g;p' | sed -n 's/epsilon in \\[//;p' | sed -n 's/\\]/,/;p' | sed -n 's/, /,\\n/;p' >> "@gappaOutputFile);
					      });
			     wholeGappaTime := wholeGappaTime + gappaTime;
			     print("0|];") >> gappaOutputFile;
			     execute(gappaOutputFile);
			     bashexecute("rm " @ gappaOutputFile);
			     evalerr = 0;
			     for i in boundsList do if (abs(i) > evalerr) then evalerr = abs(i);
			         if (evalerr == 0) then evalerr := 1/0;
                        };

			write("\tGappa determined evaluation error = 2^(",round(log2(evalerr),12,RU),")\n");
			if (abs(evalerr) > 1) then {
			   write("\tGappa file: ", gappaFile, "\n");
			};

			res = ((implapproxerr + evalerr + implapproxerr * evalerr) <= (targeterr * beta));
		};
	  };

	  if (res) then res = [|true, q, implapproxerr, evalerr|] else res = [| false, q, implapproxerr, evalerr|];

	  return res;
};


/* configToNumber

   Gives the number of a configuration under a permutation order

*/
procedure configToNumber(config,permut) {
	  var res, k, i, tt;

	  res = 0;
	  for k from length(config)-1 to 0 by -1 do {
	      i = config[permut[k]];
	      res = res * 3;
	      if (i == D) then
		tt = 0
	      else
		if (i == DD) then
			tt = 1
		else
			tt = 2;
	      res = res + tt;
	  };

	  return res;
};

/* numberToConfig

   Gives a configuration of a configuration number under a permutation order

*/
procedure numberToConfig(t,permut,numberMonomials) {
	var k, configur, j, dv, r, form;
	k = t;
	configur = [|1,...,numberMonomials|];
	j = 0;
	while (j < numberMonomials) do {
		dv := floor(k / 3);
		r := k - 3 * dv;
		if (r == 0) then
			form = D
		else
			if (r == 1) then
				form = DD
			else
				form = TD;
		configur[permut[j]] = form;
		k = dv;
		j := j + 1;
	};
	return configur;
};


procedure isHigherPrecisionConfig(config,bounds) {
	  var res;
	  var i, c, b;

	  if (length(config) != length(bounds)) then {
	     res = false;
	  } else {
	     res = true;
	     i = 0;
	     while ((i < length(bounds)) && res) do {
	     	   c = config[i];
		   b = bounds[i];
		   if (((c == D) && (b != D)) || ((c == DD) && (b == TD))) then res = false;
	     	   i := i + 1;
	     };
	  };
	  return res;
};

procedure isLowerPrecisionConfig(config,bounds) {
	  var res;
	  var i, c, b;

	  if (length(config) != length(bounds)) then {
	     res = false;
	  } else {
	     res = true;
	     i = 0;
	     while ((i < length(bounds)) && res) do {
	     	   c = config[i];
		   b = bounds[i];
		   if (((b == D) && (c != D)) || ((b == DD) && (c == TD))) then res = false;
	     	   i := i + 1;
	     };
	  };
	  return res;
};


procedure extraroundcoefficients(poly,monomials,configuration) {
	  var confli;
	  var i;

	  confli = [||];
	  for i from 0 to degree(poly) do confli = D.:confli;

	  for i from 0 to length(monomials) - 1 do {
	      confli[monomials[i]] = configuration[i];
	  };

	  return roundcoefficients(poly,confli);
};


/* implementconfigurations

   Based on func, pstar, lowerbounds, upperbounds and optimisationPermut
   tries to find the first polynomial in optimisationPermut order
   (with the least number of coefficients) that satisfies targeterr

   Uses fpminimax

   Returns [|true, poly, approxerr, implerr, pstar|] if a configuration has been found
   Returns [|false, bestpoly, bestapprox, bestimplerr, pstar |] if no configuration satisfies the target error
   Returns [|false, pstar, 0, 0, false, pstar|] if some other error occurs

*/
procedure implementconfigurations(func,pstar,dom,targeterr,beta,lowerbounds,upperbounds,optimisationPermut,
	                          variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName) {
          var ii;
	  var okay;
	  var numbercoefficients;
	  var res;
	  var approxerr;
	  var pointlist;
	  var d;
	  var monomials;
	  var symetrical;
	  var firstmonomial;
	  var bestpoly, bestapprox, bestimplerr;
	  var configuration;
	  var implresult;
	  var poly;
	  var targetlog;
	  var looparound, targeterrimpl;
	  var dci, dcii, polyRound;

	  okay = true;
	  numbercoefficients = 0;
	  for ii from 0 to degree(pstar) do if (coeff(pstar,ii) != 0) then numbercoefficients := numbercoefficients + 1;
	  if ((length(lowerbounds) != length(upperbounds)) || (numbercoefficients != length(lowerbounds))) then {
	     okay = false;
	     res = [| false, pstar, 0, 0, false, pstar |];
	  };

	  if (okay) then {
	     approxerr = mydirtyinfnorm(pstar/func-1,dom);

	     monomials = [||];
	     for ii from 0 to degree(pstar) do
	           if (coeff(pstar,ii) != 0) then monomials = monomials:.ii;

	     symetrical = true;
	     ii := length(monomials) - 1;
	     firstmonomial = head(monomials);
	     while ((ii >= 0) && symetrical) do {
	  	if (floor((monomials[ii] + firstmonomial) / 2) * 2 != (monomials[ii] + firstmonomial)) then
		   symetrical = false;
		ii := ii - 1;
	     };
	     if (symetrical) then {
	        if (-inf(dom) > sup(dom)) then
		   d = [1b-1075, -inf(dom)]
	        else
		   d = [1b-1075, sup(dom)];
	     } else {
	        d = dom;
	     };

	     pointlist = mydirtyfindzeros(pstar/func-1,d);

	     firstConfigNumber = configToNumber(lowerbounds,optimisationPermut);
	     lastConfigNumber = configToNumber(upperbounds,optimisationPermut);
	     t = firstConfigNumber;
	     found = false;
	     bestpoly = 0;
	     bestimplerr = 1000;
	     bestapproxerr = 1000;
	     ii = 1;
	     targetlog = round(log2(targeterr),12,RN);
	     while ((!found) && (t <= lastConfigNumber)) do {
	           // "Configuration t = ", t, ", lastConfigNumber = ", lastConfigNumber;
	     	   configuration = numberToConfig(t,optimisationPermut,numbercoefficients);
		   if (isHigherPrecisionConfig(configuration,lowerbounds) && isLowerPrecisionConfig(configuration,upperbounds)) then {
		      write("Trying configuration #",ii," ",configuration,":\n");

		      poly = fpminimaxwrapper(func,dom,monomials,pstar,pointlist,configuration);

		      if (poly != false) then {
		      	        dci = dirtycheckinfnorm(poly/func-1,dom,targeterr);
				if (dci == false) then {
				   polyRound = extraroundcoefficients(pstar,monomials,configuration);
				   dcii = dirtycheckinfnorm(polyRound/func-1,dom,targeterr);
				   if (dcii != false) then {
				      write("Warning: rounded Pstar better that fpminimax polynomial\n");
				      poly = polyRound;
				      dci = dcii;
				   };
				};

		      	       	if (dci != false) then {
		      	       	      looparound = true;
				      targeterrimpl = targeterr;
				      while (looparound && (targeterrimpl >= targeterr/16)) do {
		      		      	    implresult = implementandcheck(func,poly,dom,targeterr,targeterrimpl,dci,beta,
									   variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName);

					    // implresult[0], implresult[3];
				            if (implresult[0]) then
					       looparound = false
					    else {
					    	 if ((implresult[3] == false) || (implresult[3] == 1/0)) then
						    looparound = false
						 else
						    targeterrimpl := targeterrimpl / 2;
					    };
				      };
                                      if (implresult[0]) then {
				            found = true;
                                            bestpoly = poly;
					    bestimplerr = implresult[3];
					    bestapproxerr = implresult[2];
					    print("~~~degree = ", degree(poly));
					    write("\tfound: target = 2^(",targetlog,"), approx = 2^(",round(log2(bestapproxerr),12,RU),"), evaluat = 2^(",
                                                  round(log2(bestimplerr),12,RU),"), overall = 2^(",
						  round(log2(bestimplerr + bestapproxerr + bestimplerr * bestapproxerr),12,RU),")");
			              } else {
				            if (implresult[2] < bestapproxerr) then {
					       bestpoly = poly;
					       bestapproxerr = implresult[2];
					       bestimplerr = implresult[3];
                                            };
				            write("\tunusable: target = 2^(",targetlog,"), approx = 2^(",
                                                  round(log2(implresult[2]),12,RN),") (best approx = 2^(",
					          round(log2(bestapproxerr),12,RN),"))");
                                      };
                                } else {
				      write("\tunusable: target = 2^(",targetlog,")");
				};
		      } else {
		      	write("\tproblem with fpminimax");
		      };
		      write("\n");
		      ii := ii + 1;
		   };
	     	   t := t + 1;
	     };
	     res = [| found, bestpoly, bestapproxerr, bestimplerr, pstar |];
	  };

          return res;
};


/* implements a function by polynomial approximation in an interval centered in 0

   Returns

    [| true, poly, approxerr, implerr, pstar |] if everything is fine
    [| false, 0, 0, 0, 0 |] otherwise

    No test is made whether the interval is correctly centered in 0

*/
procedure implementcentered(func, dom, target, beta, variableFormat, galoptimizedMonomials, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName) {
	  var res;
	  var Pstar, upperbounds, lowerbounds, optimisationPermut;
	  var i, monomials;
	  var lowerboundsAndOptiPermut;
	  var k, l;

	  res = [| false, 0, 0, 0, 0 |];

	  Pstar = remezwrapper(func, dom, target, 3);

	  if (Pstar != false) then {

		monomials = [||];
		for i from 0 to degree(Pstar) do {
		    if (coeff(Pstar,i) != 0) then monomials = monomials:.i;
		};

		upperbounds = determineupperbounds(Pstar, func, dom, target, variableFormat, implementationFile);

		lowerboundsAndOptiPermut = determinelowerbounds(Pstar, func, dom, target);


		if (lowerboundsAndOptiPermut == false) then {

          	        lowerbounds = [||];
	                for i in upperbounds do {
	                   if (i == D) then
	                      lowerbounds = lowerbounds:.D
                           else
	                      if (i == DD) then
		                 lowerbounds = lowerbounds:.D
	                      else
                                 lowerbounds = lowerbounds:.DD;
                        };

                        optimisationPermut = [| 0, ..., length(upperbounds)-1 |];
                } else {
		        lowerbounds = lowerboundsAndOptiPermut[0];
			optimisationPermut = lowerboundsAndOptiPermut[1];

			for l from 0 to length(monomials) - 1 do {
			    if (listcontains(galoptimizedMonomials,monomials[l])) then {
			       lowerbounds[l] = D;
			    };
			};

                };

		if (length(lowerbounds) == length(upperbounds)) then {

		for k from 0 to length(lowerbounds) - 1 do {
		    if ((upperbounds[k] == D) && (lowerbounds[k] != D)) then upperbounds[k] = lowerbounds[k];
		    if ((upperbounds[k] == DD) && (lowerbounds[k] == TD)) then upperbounds[k] = lowerbounds[k];
		};

	        write("Chosen monomial base: ",monomials,"\n");
	        write("Lower bounds for precisions of coefficients: ",lowerbounds,"\n");
	        write("Upper bounds for precisions of coefficients: ",upperbounds,"\n");
	        write("Optimisation permutation: ",optimisationPermut,"\n");
	        write("\n");

                res = implementconfigurations(func,Pstar,dom,target,beta,lowerbounds,upperbounds,optimisationPermut,
	                                      variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable, polynomialName);
		};
          };

	  return res;
};



/* implements a function by polynomial approximation in a small interval

   Returns

    [| true, centerpoint, poly, approxerr, implerr |] if everything is fine
    [| false, 0, 0, 0, 0 |] otherwise

   The function to be implemented may have at most 1 zero in the domain.
   No test for this condition is made.

*/
procedure implementsmall(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName, defdom) {
	  var res;
	  var zerosInInterval, zerosInIntervalRaw, zr, midpoint, zerosInIntervalTemp, zerosInIntervalRaw2;
	  var smallestAbsZero;
	  var Pstar;
	  var okay;
	  var startmidpoint;
	  var shiftedFunc, shiftedDom;
	  var resImpl;
	  var oldprec, oldpoints, olddiam;
	  var galoptim;
	  var galoptimizedMonomials;
	  var PstarOrig;
	  var nrm;

	  write("implementsmall(",func,",", dom,",", target,",", beta,",", variableFormat,",", implementationFile,",", gappaFile,",", gappaOutputFile,",", gappaExecutable,",", polynomialName,",",defdom,")\n");

	  galoptimizedMonomials = [||];
	  okay = true;

	  if (inf(dom) * sup(dom) >= 0) then {
	       zerosInInterval = [||];
	       oldprec = (prec = ?);
	       prec = oldprec * 3!;
	       oldpoints = (points = ?);
	       points = oldpoints * 6!;
	       olddiam = (diam = ?);
	       diam = olddiam / 1b8!;
 	       zerosInIntervalRaw2 = myfindzeros(func,dom);
	       zerosInIntervalRaw = [||];
	       for zr in zerosInIntervalRaw2 do
	          zerosInIntervalRaw = zerosInIntervalRaw @(myfindzeros(func,zr));
	       for zr in zerosInIntervalRaw do
	          zerosInInterval = zerosInInterval @ (mydirtyfindzeros(func,zr));
	       prec = oldprec!;
	       points = oldpoints!;
	       diam = olddiam!;
	       zerosInIntervalTemp = sort(zerosInInterval);
	       zeroInInterval = [||];
	       for zr in zerosInIntervalTemp do zerosInInterval = zerosInInterval:.(mid(evaluate(D(x),zr)));
	       if (zerosInInterval != [||]) then {
	           smallestAbsZero = zerosInInterval[0];
	           for zr in zerosInInterval do
	     	       if (~abs(func(zr)) < ~abs(func(smallestAbsZero))) then smallestAbsZero = zr;
	           midpoint := D(smallestAbsZero);
	       } else {
	           symetrypoint = testEvenSymetry(func, dom, 1b-10, defdom);
		   if (symetrypoint != false) then {
		      write("Even symmetry dectected\n");
		      midpoint := D(symetrypoint);
		   } else {
		     nrm = mydirtyinfnorm(func, dom);
                     if (abs(func(inf(dom))) < 1b-12 * nrm) then midpoint := D(inf(dom)) else {
		     if (abs(func(sup(dom))) < 1b-12 * nrm) then midpoint := D(sup(dom)) else {
		     if (target < 1b-50) then {
		      PstarOrig = remezwrapper(func(x + D(mid(dom))), [inf(dom) - D(mid(dom));sup(dom) - D(mid(dom))], target, 3);
	              if (!(PstarOrig == false)) then {
	                 Pstar = simplifysafe(horner(simplifysafe(substitute(PstarOrig,(x - D(mid(dom)))))));
	                 startmidpoint := D(mid(dom));
			 galoptim = galoptimisation(Pstar,func,dom,target,startmidpoint);
	                 midpoint := D(galoptim[0]);
			 galoptimizedMonomials = galoptim[1];
	              } else {
	                 midpoint := D(mid(dom));
	              };
		      } else {
		      	 midpoint := D(mid(dom));
		      };
		      }; };
		   };
	       };

          } else {
	       midpoint = 0;
          };

	  if (okay) then {
	     write("Chosen midpoint = ",round(midpoint,53,RN)," = ");
	     printhexa(midpoint);

	     shiftedFunc = horner(func(x + midpoint));
	     shiftedDom = [inf(dom) - midpoint ; sup(dom) - midpoint];

	     write("The translated function is f = ",shiftedFunc,"\n");
	     write("The translated domain is dom = ",shiftedDom,"\n");

	     resImpl = implementcentered(shiftedFunc, shiftedDom, target, beta, variableFormat, galoptimizedMonomials,
	                                 implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName);

	     res = [| resImpl[0], midpoint, resImpl[1], resImpl[2], resImpl[3], resImpl[4] |];

	  } else {
	    res = [| false, 0, 0, 0, 0, 0 |];
	  };

	  return res;
};

procedure implementShifter(centerPoint, dom, variableFormat, outputFormat, polynomialName, functionName, implementationFile) {
	  var res;
	  var shifterCode, oldDisplay;
	  var sterbenzOkay;

	  res = { .okay = false };

	  /* Check if centerPoint is a double precision number in the domain
             and if Sterbenz' lemma will be verified for the whole domain */
	  if ((D(centerPoint) - centerPoint == 0) &&
              (centerPoint in dom)) then {
              sterbenzOkay = (((inf(dom) * sup(dom) > 0) && (inf(dom) * centerPoint > 0)) && ((abs(inf(dom)) >= abs(centerPoint)/2) && (abs(sup(dom)) <= 2 * abs(centerPoint))));
	      if (sterbenzOkay) then {
               res.okay = true;
	       oldDisplay = display;
	       display = decimal!;
	       shifterCode = "\n\n#define " @ functionName @ "_centerpoint " @ centerPoint;
	       display = oldDisplay!;
	       shifterCode = shifterCode @ "\n\nvoid "@functionName@"(";
	       shifterCode = shifterCode @ (match outputFormat with
                                                  D   : ( "double *res_resh, " )
                                                  DD  : ( "double *res_resh, double *res_resm, " )
                                                  TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                           );
               shifterCode = shifterCode @ (match variableFormat with
                                                  D   : ( "double x" )
                                                  DD  : ( "double xh, double xm" )
                                                  TD  : ( "double xh, double xm, double xl" )
                                           );
               shifterCode = shifterCode @ ") {\n";
               shifterCode = shifterCode @ (match variableFormat with
                                                  D   : ( "double t;\n\n" )
                                                  DD  : ( "double th, tm;\ndouble temp;\n\n" )
                                                  TD  : ( "double th, tm, tl;\ndouble temp;\n\n" )
                                           );
               shifterCode = shifterCode @ (match variableFormat with
                                                  D   : ( "t = x - " @ functionName @ "_centerpoint;" )
                                                  DD  : ( "temp = xh - " @ functionName @ "_centerpoint;\nAdd12(th,tm,temp,xm);" )
                                                  TD  : ( "temp = xh - " @ functionName @ "_centerpoint;\nRenormalize3(&th,&tm,&tl,temp,xm,xl);" )
                                           );
               shifterCode = shifterCode @ "\n\n";
	       shifterCode = shifterCode @ polynomialName @ "(";
	       shifterCode = shifterCode @ (match outputFormat with
                                                  D   : ( "res_resh, " )
                                                  DD  : ( "res_resh, res_resm, " )
                                                  TD  : ( "res_resh, res_resm, res_resl, " )
                                           );
               shifterCode = shifterCode @ (match variableFormat with
                                                  D   : ( "t" )
                                                  DD  : ( "th, tm" )
                                                  TD  : ( "th, tm, tl" )
                                           );
               shifterCode = shifterCode @ ");\n\n";
	       shifterCode = shifterCode @ "}\n";
	       write(shifterCode) >> implementationFile;
          } else {
	    write("Error: Sterbenz condition not fulfilled for argument center ", centerPoint, " and domain ", dom, "\n");
	  };
	  };

	  return res;
};

/* implements a function by polynomial approximation in a small interval
   while issuing appropriate range translation code if the interval
   is not centered in zero.

   Returns a structure that

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the approximation error
          * implerr      the implementation (round-off) error
          * centerpoint  the point the original interval got centered at
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         translation
          * poly         the polynomial that has been used
          * pstar        the best approximation polynomial used for
                         floating-point approximation

   The function to be implemented may have at most 1 zero in the domain.
   No test for this condition is made.

*/
procedure implementsmallwithcentering(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName, defdom) {
	  var res, resultat, outputFormat, resShifter;

	  resultat = { .okay = false };

	  write("Starting to implement f = ", func, " on dom = ", dom, " with polynomial approximation\n");

	  res = implementsmall(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName, defdom);

	  if (res[0]) then {
	     /* Get the information returned by the implementer function working on a small interval */
	     resultat.okay = true;
	     resultat.approxerr = res[3];
	     resultat.implerr = res[4];
	     resultat.poly = res[2];
	     resultat.pstar = res[5];
	     resultat.centerpoint = res[1];

	     /* Determine the output format of the implemented polynomial */
	     outputFormat = parse(bashevaluate("cat "@implementationFile@" | grep \"void "@polynomialName@"\" | sed -n 's/double x.*//g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, double \\*"@polynomialName@"_resm, double \\*"@polynomialName@"_resl, /TD/g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, double \\*"@polynomialName@"_resm, /DD/g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, /D/g;p'"));
	     resultat.outputformat = outputFormat;

	     /* Generate the code that shifts the domain with the centerpoint determined beforehand */
	     if (resultat.centerpoint != 0) then {
	       resultat.functionname = polynomialName@ "_shifter";
	       resShifter = implementShifter(resultat.centerpoint, dom, variableFormat, outputFormat, polynomialName, resultat.functionname, implementationFile);
	       if (!resShifter.okay) then {
	       	  resultat = { .okay = false };
	       };
	     } else {
	       resultat.functionname = polynomialName;
	     };
	  };

	  return resultat;
};

procedure splitList(l, i) {
	  var res;
	  var lA, lB, k, lenL;

	  lenL = length(l);
	  if ((i < 0) || (i >= lenL)) then {
	     res.lA = l;
	     res.lB = [||];
	  } else {
	    lA = [||];
	    for k from 0 to i - 1 do {
	    	lA = lA :. (l[k]);
	    };
	    lB = [||];
	    for k from i to lenL - 1 do {
	    	lB = lB :. (l[k]);
	    };
	    res.lA = lA;
	    res.lB = lB;
	  };

	  return res;
};

procedure generateRecursiveSplitter(splitPointName, domains, functionNames, outputFormats, variableFormat, globalOutputFormat) {
	  var resultat;
	  var lenDomains, lenFunctionNames, lenOutputFormats, splitterCode, middleIndex, res;
	  var splitPointA, splitPointB;
	  var temp;
	  var domainsLeft, domainsRight, functionNamesLeft, functionNamesRight, outputFormatsLeft, outputFormatsRight;
	  var oldDisplay, resLeft, resRight, myDefines;

	  resultat = { .okay = false };

	  lenDomains = length(domains);
	  lenFunctionNames = length(functionNames);
	  lenOutputFormats = length(outputFormats);

	  if ((lenDomains == lenFunctionNames) &&
	      (lenFunctionNames == lenOutputFormats) &&
	      (lenDomains != 0)) then {

	      if (lenDomains == 1) then {
	          resultat.okay = true;
		  resultat.defines = "";
		  splitterCode = functionNames[0] @ "(";
		  splitterCode = splitterCode @ (match (outputFormats[0]) with
		                                       D  :    ("res_resh, ")
                                                       DD :    ("res_resh, res_resm, ")
                                                       TD :    ("res_resh, res_resm, res_resl, ")
                                                );
                  splitterCode = splitterCode @ (match (variableFormat) with
                                                       D  :    ("xh")
                                                       DD :    ("xh, xm")
                                                       TD :    ("xh, xm, xl")
                                                );
                  splitterCode = splitterCode @ ");\n";
                  match (globalOutputFormat) with
                        TD : {
                                match (outputFormats[0]) with
                                      DD :  {
                                                splitterCode = splitterCode @ "*res_resl = 0.0;\n";
                                            }
                                      D  :  {
                                                splitterCode = splitterCode @ "*res_resm = 0.0;\n";
                                                splitterCode = splitterCode @ "*res_resl = 0.0;\n";
                                            }
                                      default : { };
                             }
                        DD : {
                                if (outputFormats[0] == D) then {
                                   splitterCode = splitterCode @ "*res_resm = 0.0;\n";
                                };
                             }
                        default : { };
	          resultat.splitterCode = splitterCode;
	      } else {
	      	  middleIndex = floor(lenDomains / 2);
		  splitPointA = inf(domains[middleIndex]);
		  splitPointB = sup(domains[middleIndex - 1]);
                  if (splitPointA == splitPointB) then {
		     temp = splitList(domains, middleIndex);
		     domainsLeft = temp.lA;
		     domainsRight = temp.lB;
		     temp = splitList(functionNames, middleIndex);
		     functionNamesLeft = temp.lA;
		     functionNamesRight = temp.lB;
		     temp = splitList(outputFormats, middleIndex);
		     outputFormatsLeft = temp.lA;
		     outputFormatsRight = temp.lB;
		     resLeft = generateRecursiveSplitter(splitPointName @ "_0", domainsLeft, functionNamesLeft, outputFormatsLeft, variableFormat, globalOutputFormat);
		     resRight = generateRecursiveSplitter(splitPointName @ "_1", domainsRight, functionNamesRight, outputFormatsRight, variableFormat, globalOutputFormat);
		     if (resLeft.okay && resRight.okay) then {
		         resultat.okay = true;
			 oldDisplay = display;
			 display = decimal!;
			 myDefines = "#define " @ splitPointName @ "_splitpoint " @ splitPointA @ "\n";
			 display = oldDisplay!;
			 splitterCode = "if ( xh < " @ splitPointName @ "_splitpoint ) {\n" @
                                        resLeft.splitterCode @ "} else {\n" @
                                        resRight.splitterCode @ "}\n";
			 resultat.defines = resLeft.defines @ myDefines @ resRight.defines;
			 resultat.splitterCode = splitterCode;
		     };
		  };
	      };
	  };

	  return resultat;
};


procedure checkIfElementsInListAllEqual(l) {
	  var res, c, ll, h;

	  if (l == [||]) then {
	     res = true;
	  } else {
	     res = true;
	     c = head(l);
	     ll = tail(l);
	     while (res && (ll != [||])) do {
	     	   h = head(ll);
		   ll = tail(ll);
		   if (h != c) then {
		      res = false;
		   };
	     };
	  };

	  return res;
};

/* Thanks to Sylvain Chevillard for the following interpolation routines */
dd = proc(u,v,n,ddTab) { var i,k; i:=v-u+1;  k:=u+(i-1)*(n+1-i/2); return(ddTab[k]); };

ddCompute = proc(X,Y) { var n,result,i,j;
                        n=length(X);
                        result=[||];
			for j from 0 to n-1 do result:=result:.Y[j];
                        for i from 2 to n do {
                          for j from 0 to n-i do {
                            b := dd(j+1, j+i-1, n, result);
                            a := dd(j, j+i-2, n, result);
                            result := result:.(~(  (b-a)/(X[j+i-1]-X[j])  ));
			  };
                        };
                        return result;
};

interpoleWithTab = proc(X,ddTab) { var n,p,i;
                                     p = 0;
                                     n = length(X)-1;
                                     for i from n to 1 by -1 do {
                                       p := simplify(horner((x-X[i-1])*(dd(0,i,n+1,ddTab)+p)));
                                     };
                                     p := simplify(horner(dd(0,0,n,ddTab) + p));
                                     return p;
};

interpole = proc(X,Y) { var ddTab;
                        ddTab = ddCompute(X,Y);
		//	print("***** in interpole, x = ", X, " y = ", Y);
                        return interpoleWithTab(X,ddTab);
};

/* End of the interpolation routines */



/* Computes the floating-point successor of X in double precision.
   Computes the floating-point successor of the double precision
   number nearest to X if X is not a double precision number.
*/
procedure succDouble(X) {
	  return round(D(X) + 1b-1076,D,RU);
};

/* Computes the floating-point predecessor of X in double precision.
   Computes the floating-point predecessor of the double precision
   number nearest to X if X is not a double precision number.
*/
procedure predDouble(X) {
	  return round(D(X) - 1b-1076,D,RD);
};


procedure checkReconstructionPolyOK(poly, domains, n) {
	  var res, N, dom, infpoly, suppoly, i, j, found, okay, newpoly, imageInterval, maxdelta, maxi, maxj;
	  "checkReconstructionPolyOK(", poly,", ", domains, ", ",  n, ");";
	  res = {.okay = false};
	  stop = false;
	  okay = true;
	  N = length(domains);
	  dom =  [inf(domains[0]), sup(domains[N-1])];
	  maxdelta = 0.0;
	  maxi = -1;

	  infpoly = poly(inf(dom));
	  suppoly = poly(sup(dom));
	  derivzeros = dirtyfindzeros(diff(poly), dom);	
	  //print("derivzeros = ", derivzeros);
	  "n = ", n;
	  i = 0; okay = true;
	  while (okay && i < N) do {
	      imageInterval  = dirtyEvaluateImage(poly, [succDouble(inf(domains[i])), predDouble(sup(domains[i]))]);
	      print("domains[i] = ", domains[i], "f(domains[i]) = ", imageInterval, imageInterval in [i-n, i+1-n]);
	      print("poly(inf(domains[i])) = ", ~poly(inf(domains[i])), " poly(sup(domains[i])) = ", ~poly(sup(domains[i])));
	    //  print("inf(imageInterval) = ", inf(imageInterval), " sup(imageInterval) = ", sup(imageInterval));
	    //  print("inf(imageInterval) >= i-n ", inf(imageInterval) >= i-n, " sup(imageInterval) < i + 1-n ", sup(imageInterval) < i + 1-n);
	      okay = okay && (inf(imageInterval) >= i -n) && (sup(imageInterval) < i + 1-n);
	      okay = okay && (poly(inf(domains[i])) >= i - n - 1) && (poly(sup(domains[i])) < i - n + 1); // to consider splitpoints
	      print("okay = ", okay);
	      i = i+1;
	  };	  
	  
	  if (! okay) then {
	     if (length(derivzeros) > 0) then {
	     	i = 0;
		j = 0;
		found = false;
		while (i < length(derivzeros)) do {
		      //"i = ", i, " derivzeros[i] = ", derivzeros[i], " poly(derivzeros[i]) = ", poly(derivzeros[i]);
		      j= 0;
		      while ( (j < N)  && (! (derivzeros[i] in domains[j])) /*&& (! (found))*/) do {	      
		      	    j = j + 1;
		      	  /* "j = ", j, " domains[j] = ", domains[j];
		      	   found = found  || (!(poly(derivzeros[i]) in [j - n, j + 1 - n]));
			   "found = ", found;
			   if (found && abs(j - n - 0.5 - poly(derivzeros[i])) > maxdelta) then {
			      maxdelta = abs(j - n - 0.5 - poly(derivzeros[i]));
			      maxi = i;
			      maxj = j;
			      print("maxdelta = ", ~maxdelta, " maxi = ", maxi, " maxj = ", maxj);
			   };			   
			   print("found = ", found, " maxi = ", maxi);
			   j = j + 1; */
		      };
		     // "after loop on domains j = ", j;
		      if (!(poly(derivzeros[i]) in [j - n, j + 1 - n])) then {
		      	 "maxdelta = ", maxdelta;			 
			 if (abs(j - n + 0.5 - poly(derivzeros[i])) > maxdelta) then {
			      maxdelta = abs(j - n - 0.5 - poly(derivzeros[i]));
			      maxi = i;
			      maxj = j;
			      print("maxdelta = ", ~maxdelta, " maxi = ", maxi, " maxj = ", maxj);
			   };	
		      };
		      i = i + 1;
		};
		if (maxdelta > 0) then {
		   res = {.okay = false, .addPoint = true, .xpoint = derivzeros[maxi], .ypoint = (-1) / (inf(domains[maxj]) - sup(domains[maxj])) * (derivzeros[maxi] - sup(domains[maxj])) + maxj  + 1 };
		} else {
		  res = {.okay = false, .addPoint = false};
		};
	     } else {
	       res = {.okay = false, .addPoint = false};
	     };	     
	  } else {
	    res = {.okay = true};
	  };
	  
	  "result in checkReconstruct = ", res;
	  return res;
};

procedure buildReconstructPoly(xpoints, ypoints, formatlist) {
	  var poly, oldprec, polyWithoutRounding, n, i;
	  
	  n = xpoints[0];
	  fn = ypoints[0];
	  for i from 1  to length(xpoints) - 1 do {
	      if (abs(xpoints[i]) < abs(n)) then {
	      	 n = xpoints[i];
		 fn = ypoints[i];
		 };
	  };
	  for i from 0  to length(xpoints) - 1 do {
	      ypoints[i] = ypoints[i] - fn;
	  };     
	  oldprec = prec;
	  prec = 600!;
	  poly = roundcoefficients(interpole(xpoints, ypoints), formatlist);	  
	  polyWithoutRounding = interpole(xpoints, ypoints);
	//  "polyWithoutRounding = ", polyWithoutRounding;
	  prec = oldprec!;
	  return {.poly = poly, .fn = fn};
};


procedure buildAndCheck(domains, name) {
	  var i, res, buildRes, checkRes, xpoints, ypoints, N;

	  res = {.okay = false, .name = name};
	  N = length(domains);
	  xpoints = [| |];
	  "direction = ", name;
	  if (name == "inner") then {
	     for i from 1 to N - 1 do {
	     	 xpoints = inf(domains[i]) .: xpoints; 
	     };
	     xpoints = revert(xpoints);	
	     ypoints = [| 1, ..., N - 1 |];
	     buildRes = buildReconstructPoly(xpoints, ypoints, [|D...|]);
	     //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])]);
	     //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])], postscript, "/home/kupriianova/metalibm/metalibm/reconstrunctPolyOK2");
	     res = checkReconstructionPolyOK(buildRes.poly, domains, buildRes.fn);
	     res.poly = buildRes.poly;
	     res.direction = name;	     
	  };
	  if (name == "left") then {
	    for i from 0 to N - 1 do {
	     	 xpoints = inf(domains[i]) .: xpoints; 
	     };
	     xpoints = revert(xpoints);	
	     ypoints = [| 0, ..., N - 1 |];
	     buildRes = buildReconstructPoly(xpoints, ypoints, [|D...|]);
	     //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])]);
	     res = checkReconstructionPolyOK(buildRes.poly, domains, buildRes.fn);
	     res.poly = buildRes.poly;
	     res.direction = name;
	  };
	  if (name == "right") then {
	     for i from 0 to N - 1 do {
	     	 xpoints = sup(domains[i]) .: xpoints; 
	     };
	     xpoints = revert(xpoints);	
	     ypoints = [| 1, ..., N  |];
	     buildRes = buildReconstructPoly(xpoints, ypoints, [|D...|]);
	     //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])]); 
	     //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])], postscript, "/home/kupriianova/metalibm/metalibm/reconstrunctPolyOK1");
	     res = checkReconstructionPolyOK(buildRes.poly, domains, buildRes.fn);
	     res.poly = buildRes.poly;
	     res.direction = name;
	  };
	  if (name == "all") then {
	     for i from 0 to N - 1 do {
	     	 xpoints = sup(domains[i]) .: xpoints; 
	     };
	     xpoints = revert(xpoints);	
	     xpoints = inf(domains[0]).:xpoints;
	     ypoints = [| 0, ..., N  |];
	     buildRes = buildReconstructPoly(xpoints, ypoints, [|D...|]);
	     //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])]);
	    // plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])], postscript, "/home/kupriianova/metalibm/metalibm/reconstrunctPolyJump");
	     res = checkReconstructionPolyOK(buildRes.poly, domains, buildRes.fn);
	     "after check reconstruct, all points";
	     res.poly = buildRes.poly;
	     res.direction = name;
	  };

	  return res;
};

/*	Builds a polynomial of degree not more than maxDegree for the given domains.
	The whole domain was split into subintervals, this polynomial approximates piecewise-constant function (steps) that gives the number of the subdomain.
 	If it's possible to build such a polynomial result.okay is true and the reconstructed polynomial is in result.poly
*/

procedure tryGeneratePolynomialSplitterReconstructionPolynomial(domains, maxDegree) {
	  var res, direction, N, tmpres, buildres, stablepoly, currdegree, xpoints, ypoints, stablepolydeg; 
	  //"tryGeneratePolynomialSplitterReconstructionPolynomial(", domains, ", ", maxDegree, ")";
	  direction = "inner"; 
	  stablepoly = 0;
	  stablepolydeg = 0;
	  res = {.okay = false};
	  N = length(domains);
	  tmpres = buildAndCheck(domains, direction);
	  "tmpres = ", tmpres;
	  currdegree = N - 3;
	  if (tmpres.okay) then {
	     stablepoly = tmpres.poly;
	     res = tmpres;
	  } else {
	    direction = "left";
	    tmpres = buildAndCheck(domains, direction);
	    "tmpres = ", tmpres;
	    currdegree = N - 2;
	    if (tmpres.okay) then {
	       stablepoly = tmpres.poly;
	       res = tmpres;
	    } else {
	      direction = "right";
	      tmpres = buildAndCheck(domains, direction);
	      currdegree = N - 1;
	      "tmpres = ", tmpres;
	      if (tmpres.okay) then {
	         "right stable";
	      	 stablepoly = tmpres.poly;
	       	 res = tmpres;	      
	      } else {	      	  
		  // right not okay
	          ypoints = [| 0, ... , N -1 |];		  
	  	  xpoints = [| |]; 
		  for i from (N - 1) to 0 by -1 do {
		      xpoints = sup(domains[i]).:xpoints;
		  };
	      	direction = "all";
		currdegree = N - 1;
		tmpres = buildAndCheck(domains, direction);
		"affter build and check call";
		ypoints = [| 0, ... , N |];
		"tmpres = ", tmpres;
		if (tmpres.okay) then {
		   "all stable";
		   stablepoly = tmpres.poly;
		   res = tmpres;
		   currdegree = N ;
		} else {
		  ypoints = [| 0, ... , N |];		  
	  	  xpoints = [| |]; 
		  for i from (N - 1) to 0 by -1 do {
		      xpoints = sup(domains[i]).:xpoints;
		  };
		  xpoints = (inf(domains[0])).:xpoints;

		  while (currdegree < maxDegree && (!(tmpres.okay) && (tmpres.addPoint))) do {
		  	currdegree = currdegree + 1;
  	
		  	xpoints = sort((tmpres.xpoint).:xpoints);
		  	ypoints = sort((tmpres.ypoint).:ypoints);
		  	buildres = buildReconstructPoly(xpoints, ypoints,  [|D...|]);
		  
		  	tmpres = checkReconstructionPolyOK(buildres.poly, domains, buildres.fn);
		  	"after adding a point tmpres = ", tmpres;		  
		  };
		  res = tmpres;
		  "stablepoly = ", stablepoly;
		  "currdegree = ", currdegree;
		  "(stablepoly != 0) ", (stablepoly != 0);
		  "(stablepoly != 0) ", (stablepoly != 0);
		  " (currdegree > stablepolydeg) ", (currdegree > stablepolydeg);

		  if ((stablepoly != 0) && (currdegree > stablepolydeg)) then {
		     res.poly = stablepoly;		    
		  };
		}; // else
	      };	    
	    }; // else left !OK
	  }; // else inner !OK
	  print("res = ", res);
	  return res;
};

/*
procedure tryGeneratePolynomialSplitterReconstructionPolynomial8(domains, maxDegree) {
	  var res, N, dom, currDegree, poly, stablepoly, i, buildres, checkRes, leftpoints, rightpoints, currPoints, ypoints;

	  res = {.okay  = false};
   	  N = length(domains);
	  dom =  [inf(domains[0]), sup(domains[N-1])];
	  if (maxDegree < N - 3) then {
	     print("there is no possible polynomial to build. Try to increase the maxDegree");
	     res = {.okay = false};
	  } else {
	    leftpoints = [| |];
	    rightpoints = [| |];
	    for i from 0 to N - 1 do {
	    	leftpoints = inf(domains[i]).:leftpoints;
	    	rightpoints = sup(domains[i]).:rightpoints;
	    };
	    leftpoints = revert(leftpoints);
	    rightpoints = revert(rightpoints);
	    currPoints = tail(leftpoints);

	    //test inner poly first
	    ypoints = [| 1, ..., N - 1 |];
	    buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
	    currDegree = N - 3;
	    poly = buildres.poly;
	    //plot(poly.:ypoints + buildres.fn, dom);
	    checkRes = checkReconstructionPolyOK(poly, domains, buildres.fn);
	    print("check Result for inner = ", checkRes);
	    if (checkRes.okay) then {
	       stablepoly = poly;
	       res = {.okay = true, .direction = "inner", .poly = stablepoly};
	    } else { 	   
	      	//try with leftpoly!
		currPoints = leftpoints;
		ypoints = [| 0, ... , N - 1|];
		buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
		currDegree = N - 2;		
		poly = buildres.poly;
	    	//plot(poly.:ypoints + buildres.fn, dom);
		checkRes = checkReconstructionPolyOK(poly, domains, buildres.fn);
		print("check Result for left = ", checkRes);
		if (checkRes.okay) then {
		   stablepoly = poly;
		   res = {.okay = true, .direction = "left", .poly = stablepoly};
		} else {
		  while (currDegree <= maxDegree && checkRes.addPoint && (!(checkRes.okay)) &&  (currDegree - N + 2 < 5)) do {
	      	    "!!i am adding points";
	      	    currPoints = sort(checkRes.xpoint.:currPoints);
		    ypoints = sort(checkRes.ypoint.:ypoints);
		    "curPoints = ", currPoints, " ypoints = ", ypoints;
		    currDegree = currDegree + 1;
		    buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
		    //plot((buildres.poly).:ypoints, dom);
		    checkRes = checkReconstructionPolyOK(buildres.poly, domains, buildres.fn); 	      	    
	      	  };
		  if (checkRes.okay) then {
		     stablepoly = buildres.poly;
		     res = {.okay = true, .direction = "leftWithAddPoints", .poly = stablepoly};
		  } else {
		    //try rightpoly
		    currPoints = rightpoints;
		    ypoints = [|1, ..., N|];
		    buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
		    currDegree = N - 2;		
		    poly = buildres.poly;
	    	    //plot(poly.:ypoints + buildres.fn, dom);
		    checkRes = checkReconstructionPolyOK(poly, domains, buildres.fn);
		    print("check Result for right = ", checkRes);	
		    
		    if (checkRes.okay) then {
		       stablepoly = poly;
		       res = {.okay = true, .direction = "left", .poly = stablepoly};
		    } else {
		    while (currDegree <= maxDegree && checkRes.addPoint && (!(checkRes.okay)) &&  (currDegree - N + 2 < 5)) do {
	      	    "!!i am adding points";
	      	    currPoints = sort(checkRes.xpoint.:currPoints);
		    ypoints = sort(checkRes.ypoint.:ypoints);
		    "curPoints = ", currPoints, " ypoints = ", ypoints;
		    currDegree = currDegree + 1;
		    buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
		    //plot((buildres.poly).:ypoints, dom);
		    checkRes = checkReconstructionPolyOK(buildres.poly, domains, buildres.fn); 	      	    
	      	  };
		  if (checkRes.okay) then {
		     stablepoly = buildres.poly;
		     res = {.okay = true, .direction = "rightWithAddPoints", .poly = stablepoly};
		  } else {
		    print("//all points");
		    currPoints = inf(dom).:rightpoints;
		    ypoints = [|0, ..., N|];
		    buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
		    currDegree = N - 1;		
		    poly = buildres.poly;
	    	    //plot(poly.:ypoints, dom);
		    checkRes = checkReconstructionPolyOK(poly, domains, buildres.fn);
		    print("check Result for all = ", checkRes);	
		     if (checkRes.okay) then {
		       stablepoly = poly;
		       res = {.okay = true, .direction = "all", .poly = stablepoly};
		    } else {
		      	 
		        while (currDegree <= maxDegree && checkRes.addPoint && (!(checkRes.okay)) &&  (currDegree - N + 2 < 5)) do {
	      	    	      "!!i am adding points";
	      	    	      currPoints = sort(checkRes.xpoint.:currPoints);
			      ypoints = sort(checkRes.ypoint.:ypoints);
		    	      "curPoints = ", currPoints, " ypoints = ", ypoints;
		    	      currDegree = currDegree + 1;
		    	      buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
		    	      //plot((buildres.poly).:ypoints, dom);
		    	      checkRes = checkReconstructionPolyOK(buildres.poly, domains, buildres.fn); 
	      	  	};
			if (checkRes.okay) then {
		       	   stablepoly = poly;
		       	   res = {.okay = true, .direction = "allWithPoints", .poly = stablepoly};
		    	};

		    };
		  };   

		  };

		};
	      	      
	      };
	    };

	  };

	  return res;	  
};
*/

procedure tryGeneratePolynomialSplitterReconstructionPolynomial2(domains, maxDegree) {
	  var res, continuesearch, poly, funcpoints, leftpoints, rightpoints, allpoints, N, oldprec, derivzeros, dom, polyOK, i, buildres, currPolyDegree; 

	  res = {.okay = false};
	  continuesearch = true;
  	  "tryGeneratePolynomialSplitterReconstructionPolynomial, domains = ", domains, " maxDegree = ", maxDegree;
	  
  	  N = length(domains);
	  dom =  [inf(domains[0]), sup(domains[N-1])];
	  "I am trying innerpoly";
	  
	  if (maxDegree < N - 1) then {
	     print("there is no possible polynomial to build. Try to increase the maxDegree");
	     res = {.okay = false};
	  } else {
	    leftpoints = [| |];
	    rightpoints = [| |];	    
	    //1. Start with the leftpoly built by innerpoints: for each splitpoint take the upper value
	    for domain in domains do {
	      leftpoints = inf(domain).:leftpoints;	
	      rightpoints = sup(domain).:rightpoints;	      
	    };
	    leftpoints = revert(leftpoints);	
	    rightpoints = revert(rightpoints);
	    funcpoints = [|1, ..., N - 1|];
	    buildres = buildReconstructPoly(tail(leftpoints), funcpoints, [|D...|]);
	    "buildres = ", buildres;
	    currPolyDegree = N - 3;
	    poly = buildres.poly;

//	    plot(poly.:funcpoints, dom);	    
	  
	    polyOK = checkReconstructionPolyOK(poly, domains, buildres.fn);
	    print("I returned res = ", polyOK);
	    if (polyOK.okay) then {
	       res = {.okay = true, .direction = "inner", .poly = poly};
	    } else {
	       // inner poly was not ok, need to add some point and recompute.
	       //I will try to add derivPoints
	      /* derivzeros = dirtyfindzeros(diff(poly), dom);
	      while (length(derivzeros) > 0 && currPolyDegree < maxDegree && (!(polyOK))) do {
	       	     derivzeros = dirtyfindzeros(diff(poly), dom);   
		     print("derivzeros = ", derivzeros);
		     leftpoints = derivzeros[0].:leftpoints;
		     
	       };
	       */

	       print("i will try to add the inf point and restart searching the polynomial");
	       funcpoints = [|0, ..., N - 1|];
	       buildres = buildReconstructPoly(leftpoints, funcpoints, [|D...|]); 
	       poly = buildres.poly;
	       //print("----dom  =", dom);	
	       //plot(poly.:funcpoints, dom);
	       polyOK = checkReconstructionPolyOK(poly, domains, buildres.fn);
	       print("I returned res = ", polyOK);
	       if (polyOK.okay) then {
	       	  //Don't know if .direction could be useful somewhere. Add it now just for fun.
	       	  res = {.okay = true, .direction = "left", .poly = poly};
	       } else {	       	 
	       	 //Try right poly here!
		 print("i am trying to build right polynomial");
		 funcpoints = [|1, ..., N|];
		 buildres = buildReconstructPoly(rightpoints, funcpoints, [|D...|]);
		 poly = buildres.poly;		 
		 //print("-----dom = ", dom);
		 //plot(poly.:funcpoints, dom);
		 polyOK = checkReconstructionPolyOK(poly, domains, buildres.fn);
		 print("I returned res = ", polyOK);
		 if (polyOK.okay) then {
		    res = {.okay = true, .direction = "right", .poly = poly};
		 } else {
		   //Full poly. Try to add all points and check
		   print("poly built by all points");
		   funcpoints = [| 0, ... , N |];
		   allpoints = inf(dom).:rightpoints;
		   buildres = buildReconstructPoly(allpoints, funcpoints, [|D...|]);		 
		   poly = buildres.poly;
		   //print("-----dom = ", dom);
		   //plot(poly.:funcpoints, dom);
		   polyOK = checkReconstructionPolyOK(poly/* + poly(buildres.n)*/, domains, buildres.fn);
		   print("I returned res = ", polyOK);
		   print("after checking full poly = ", polyOK);
		   if (polyOK.okay) then {
		      res = {.okay = true, .direction = "full", .poly = poly};
		   }; 
		 };		 
	       };
	    }; 
	  };	  
	  if (degree(poly) > maxDegree) then { //just to be sure
	     print("your poly degree was higher than maxDegreeReconstruction");
	     res = {.okay = false};
	  };
	  print("***res = ", res);
	  if (res.okay) then print("***degree(res.poly) = ", degree(res.poly));
	  return res;
};


procedure tryGeneratePolynomialSplitterReconstruction(functionName, domains, reducedFunctionNames, variableFormat, outputFormat, tempFile, maxDegree) {
	  var res;
	  var resPoly;

	  "#####tryGeneratePolynomialSplitterReconstruction, domains = ", domains;
	  res = { .okay = false };
	  resPoly = tryGeneratePolynomialSplitterReconstructionPolynomial(domains, maxDegree);	  
	  if (resPoly.okay) then {

	     "The reconstruction polynomial is ", resPoly.poly;
/*	     for domain in domains do {
	     	 print("---inf(domain) = ", inf(domain), " floor(poly(*)) = ", floor(D(resPoly.poly(inf(domain)))), " ceil(poly(*)) = ", ceil(D(resPoly.poly(inf(domain)))));
		 print("in predecessor poly = ", (D(resPoly.poly(predDouble(inf(domain))))));
		 print("in successor poly = ", (D(resPoly.poly(succDouble(inf(domain))))));
	     	 print("sup(domain) = ", sup(domain), " floor(poly(*)) = ", floor(D(resPoly.poly(sup(domain)))), " ceil(poly(*)) = ", ceil(D(resPoly.poly(inf(domain)))));
		 print("in predecessor poly = ", (D(resPoly.poly(predDouble(sup(domain))))));
		 print("in successor poly = ", (D(resPoly.poly(succDouble(sup(domain)))))); 
	     };*/
	  };
	  return res;
};


/* implements a function by polynomial approximation in small intervals
   obtained by cutting the interval at given points

   Returns a structure that

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the maximum approximation error
          * implerr      the maximum implementation (round-off) error
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         reduction

   The function to be implemented may have at most 1 zero in each sub-domain.
   No test for this condition is made.

*/
procedure implementwithdomainsplitlist(func, dom, splitPoints, minWidth, definitionDomain, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName, maxDegreeReconst) {
	  var resultat;
	  var okay, sp;
	  var mySplitPoints;
	  var approxerr, implerr, outputFormats, functionNames;
	  var domains, i, numberSplitPoints, myDom, mySuffix, myImplementationFile;
	  var res, implementationFiles, implFile, myOutputFormat, opF, myOutputFormatNum;
	  var myFunctionName, splitterCode, oldDisplay, recursiveSplitterRes, symmetrizedDom, recovered;
	  var doElseCase;
	  var resOpt;

	   write("implementwithdomainsplitlist(",func,",", dom,",", splitPoints,",", minWidth,",", definitionDomain,",", target,",", beta,",", variableFormat,",", implementationFile,",", gappaFile,",", gappaOutputFile,",", gappaExecutable,",", polynomialBaseName,",", maxDegreeReconst,")\n"); 

	  resultat = { .okay = false };

	  /* First of all, if no splitPoints are given, the domain is not
	     split and we can simply call implementsmallwithcentering
	  */
	  doElseCase = true;
	  if (splitPoints == [||]) then {
	     doElseCase = false;
	     resultat = implementsmallwithcentering(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName, definitionDomain);

	     if (!(resultat.okay)) then {
	     	/* The implementation did not work out.
		
		   We split the interval by "inventing" 
		   one or two split points.

		*/
		if (inf(dom) * sup(dom) < 0) then {
		   splitpoints = [| D(inf(dom) / 3), D(sup(dom) / 3) |];
		} else {
		   splitpoints = [| D(mid(dom)) |];
		};
		doElseCase = true;
	        resultat = { .okay = false };
	     };
	  };

	  if (doElseCase) then {
	  /* To start with, check if all splitPoints are doubles and
             if they are contained in the given domain
          */
	  okay = true;
	  for sp in splitPoints do {
	      okay = okay && ((D(sp) - sp == 0) && (sp in dom));
	  };
	  if (okay) then {
	     /* Now sort the split points by increasing order,
	     adding the bounds to the list */
	     mySplitPoints = sort(splitPoints @ [| inf(dom), sup(dom) |]);

	     /* While we succeed in implementing the subdomains,
	        cut out a new subdomain, generate function and
		file names and try implementation.
             */
	     approxerr = 0;
	     implerr = 0;
	     outputformats = [||];
  	     functionNames = [||];
	     domains = [||];
	     implementationFiles = [||];
	     numberSplitPoints = length(mySplitPoints);
	     myDomains = [||];
	     for i from 0 to numberSplitPoints - 2 do {
	     	 myDomains = myDomains :. ( [ mySplitPoints[i], mySplitPoints[i + 1] ] );
	     };
	     i = 0;
	     while ((okay) && (myDomains != [||])) do {
	     	   myDom = head(myDomains);
		   myDomains = tail(myDomains);
		   write("\nStarting implementation on subdomain ",myDom,"\n");
		   mySuffix = "_subdomain_" @ i ;
		   myImplementationFile = implementationFile @ mySuffix;
		   res = implementsmallwithcentering(func, myDom, target, beta, variableFormat, myImplementationFile, gappaFile @ mySuffix, gappaOutputFile @ mySuffix, gappaExecutable, polynomialBaseName @ mySuffix, definitionDomain);
		   if (res.okay) then { 
		      	 print("~~~subdom = ", myDom);
		         write("Subdomain ",myDom," done\n");
   		         domains = domains :. myDom;
		         implementationFiles = implementationFiles :. myImplementationFile;
			 approxerr = max(approxerr, abs(res.approxerr));
			 implerr = max(implerr, abs(res.implerr));
			 outputformats = outputformats :. (res.outputformat);
			 functionNames = functionNames :. (res.functionname);
			 i := i + 1;
		   } else {
		     if (abs(sup(myDom) - inf(myDom)) < minWidth) then {
		        write("Error on subdomain ",myDom,", the minimal domain width is too large\n");
		        okay = false;
	             } else {
		        recovered = false;
		        symmetrizedDom = myDom;
			if (inf(myDom) == 0) then {
			   symmetrizedDom = [-sup(myDom),sup(myDom)];
			};
			if (sup(myDom) == 0) then {
			   symmetrizedDom = [inf(myDom),-inf(myDom)];
			};
			if ((inf(myDom) == 0) || (sup(myDom) == 0)) then {
			   if (symmetrizedDom in definitionDomain) then {
			      write("Using symmetrized domain around 0 instead of original domain to exploit symmetries of the function\n");
			      res = implementsmallwithcentering(func, symmetrizedDom, target, beta, variableFormat, myImplementationFile, gappaFile @ mySuffix, gappaOutputFile @ mySuffix, gappaExecutable, polynomialBaseName @ mySuffix, definitionDomain);
      		              if (res.okay) then {
			      	 print("~~~subdom = ", myDom);
		                 write("Subdomain ",myDom," done\n");
   		                 domains = domains :. myDom;
		                 implementationFiles = implementationFiles :. myImplementationFile;
			         approxerr = max(approxerr, abs(res.approxerr));
			         implerr = max(implerr, abs(res.implerr));
			         outputformats = outputformats :. (res.outputformat);
			         functionNames = functionNames :. (res.functionname);
			         i := i + 1;
				 recovered = true;
		              };
			   };
			};

			if (!recovered) then {
			   write("Resplitting on subdomain ",myDom,"\n");
		           if (inf(myDom) * sup(myDom) < 0) then {
			      myDomains = [ inf(myDom) , D(inf(myDom) / 3) ] .: ( [ D(inf(myDom) / 3) , D(sup(myDom) / 3) ] .: ( [ D(sup(myDom) / 3) , sup(myDom) ] .: myDomains ));
			   } else {
			      myDomains = [ inf(myDom) , D(mid(myDom)) ] .: ( [ D(mid(myDom)) , sup(myDom) ] .: myDomains );
			   };
			};
		     };
		   };
	     };

	     /* Now generate the argument reduction code if
	        we succeeded in generating code for all
		subdomains and combine all files.
             */
	     if (okay) then {
	        oldDisplay = display;
		display = dyadic!;
	     	write("\n\n") > implementationFile;
                display = oldDisplay!;
		for implFile in implementationFiles do {
		    bashexecute("cat " @ implFile @ " >> " @ implementationFile);
		    bashexecute("rm " @ implFile);
		};
		write("\n\n") >> implementationFile;
		myOutputFormatNum = 1;
		for opF in outputformats do {
		    myOutputFormatNum = max(myOutputFormatNum,
                                            match opF with
                                                  D  : (1)
                                                  DD : (2)
                                                  TD : (3)
                                                  default : { okay = false; return 0; });
		};
		if (okay) then {
		   myOutputFormat = match myOutputFormatNum with 1 : (D) 2 : (DD) 3 : (TD);
                   myFunctionName = polynomialBaseName @ "_splitter";
		   splitterCode = "\n\n";
		   resOpt.okay = false;
		   if (checkIfElementsInListAllEqual(outputformats) && (outputformats != [||]) && (length(domains) >= 2) && (length(domains) <= maxDegreeReconst + 1) && (variableFormat == D)) then {
		      if (head(outputformats) == myOutputFormat) then {
		      	 resOpt = tryGeneratePolynomialSplitterReconstruction(myFunctionName, domains, functionNames, variableFormat, myOutputFormat, implementationFile @ ".splitter.temp.c", maxDegreeReconst);
		      };
		   };		   
		   if (resOpt.okay) then {
		      splitterCode = splitterCode @ resOpt.code @ "\n\n";
		      write(splitterCode) >> implementationFile;		      
		   } else {
		       recursiveSplitterRes = generateRecursiveSplitter(myFunctionName, domains, functionNames, outputformats, variableFormat, myOutputFormat);
		       if (!recursiveSplitterRes.okay) then okay = false;
		       if (okay) then {
		            splitterCode = splitterCode @ recursiveSplitterRes.defines;
             	            splitterCode = splitterCode @ "\n\nvoid "@myFunctionName@"(";
	       	            splitterCode = splitterCode @ (match myOutputFormat with
                   	                                         D   : ( "double *res_resh, " )
                                                                 DD  : ( "double *res_resh, double *res_resm, " )
                                                                 TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                                          );
                            splitterCode = splitterCode @ (match variableFormat with
                                                                 D   : ( "double xh" )
                                                                 DD  : ( "double xh, double xm" )
                                                                 TD  : ( "double xh, double xm, double xl" )
                                                          );
                            splitterCode = splitterCode @ ") {\n";
		            splitterCode = splitterCode @ recursiveSplitterRes.splitterCode;
                            splitterCode = splitterCode @ "}\n\n";
		            write(splitterCode) >> implementationFile;
                       };
                   };
		   if (okay) then {
		      resultat.okay = true;
		      resultat.approxerr = approxerr;
		      resultat.implerr = implerr;
		      resultat.outputformat = myOutputFormat;
		      resultat.functionname = myFunctionName;
		   };
		};
	     };
	  };
	  };

	  return resultat;
};

/* Compute an ordered list of points x_i in the given domain dom, such that 
   on all subdomains S_i created by these splitpoints func can be approximated
   with a relative error no greater than target with polynomials of degree no 
   greater than maxDegree. All subdomains S_i are larger in width than minWidth.

   In case of failure (no such splitting exists), return a structure containing 
   an element .okay that is equal to false.

   In case of success (a splitting has been found), return a structure containing
   an element .okay that is equal to false and an element .splitPoints that is 
   a list of the points x_i described above.

   Attention:

   - the list of points x_i must be ordered by increasing values
   - the x_i must be representable in double precision
   - the points in the list must be unique (there is no i != j, such that x_i = x_j)
   - the points must be in the interior of the given domain

   The list of split points that is returned may be empty iff the given function func
   can be approximated with a target error target using a polynomial of degree no greater
   that maxDegree on the whole domain dom.

   This special purpose procedure does not have to care about the
   Sterbenz condition to be fullfilled for the substraction to be
   performed on each subdomain S_i for range reduction.

   The purpose and particularity of this special procedure is to split the domain
   in such a way that the degree of the polynomials used on each subdomain is 
   maximal, i.e. that the subdomains are of maximum width. 

   The splitting to be returned is supposed to be optimized for that specificity.

   However, the procedure is not supposed to find an optimal splitting. This means
   greedy algorithms and heuristics are allowed if they are well explained.

   As the procedure will be called on almost every instance of a metalibm run,
   it should be pretty fast, even if this means that some opportunities for 
   optimizing the split points are left aside.

*/
procedure computeDomainSplittingOptimized(func, dom, maxDegree, target, minWidth) {
	  
	  var res;
	  var left, right, m, preSplitPoints, leftdeg, wholedomdeg;

	  "computeDomainSplittingOptimized(", func, ", ", dom, ", ", maxDegree, ", ", target, ", ", minWidth, ")";

	  res = {.okay = false};
	  /* The procedure checkIfSufficientDegreeOptimized(func, dom, maxDegree, target) is your friend 

	     It checks if func can be approximated over dom with a degree no greater than
	     maxDegree and a target error target.

	     The procedure returns a structure containing the following fields:

	     - .okay that indicates if the check was successful or if the procedure failed (which might sometimes happen)

	     - if .okay is equal to true, the structure contains a field .sufficientDegree that is either false or true
	       The field indicates whether or not approximation of func over dom with a degree no greater maxDegree 
	       is possible for a target error target.

	     - if .okay is true and .sufficientDegree is true, the structure contains a field .deg indicating (a good
               guess of) the degree that is needed to approximate func over dom with target error target.  
	  */

	  /* I return .deg as a list of degrees for the corresponding subdomains */

	  res = computeDomainSplittingOptimizedInner(func, dom, maxDegree, target, minWidth, [| |], [| |]);
//	  print("----- Optimized split before stub res=", res);
//	  res = { .okay = false };	//remove stub when everything is done
	  return res;
};

procedure computeDomainSplittingOptimizedInner(func, dom,  maxDegree, target, minWidth, currSplitPointsList, currDegreeList) {
	  var res, m, left, right, leftdeg, domdeg, currRes, found;

	 // "computeDomainSplittingOptimizedInner(", func, ", ", dom, ", ", maxDegree, ", ", target, ", ", minWidth, ", ", currSplitPointsList, ", ", currDegreeList, ")";
	  
	  domdeg = checkIfSufficientDegreeOptimized(func, dom,  maxDegree, target);
	  if (domdeg.okay == false) then {
  	     print("There was some error in checkIfSufficientDegreeOptimized on domain ", dom);
	     res = domdeg;
	  } else {
	    // case when domdeg.okay == true;	   
	    if (domdeg.sufficientDegree == true) then {
	       res = domdeg;
	       res.splitPoints = currSplitPointsList;
	       res.deg = currDegreeList :. domdeg.deg;
	    } else {   
	      if (sup(dom) - inf(dom) < 2 * minWidth) then {
	      	 print("Split is needed, But I can't do it, because the current interval is too small");
	      	 res =  { .okay = false };
	      } else {	      
	     //	print("---wanna compute split, I will try to divide current dom by 2 in order to find the largest left acceptable subdomain");
		found = false;
		m = D(mid(dom));	
		left = dom;
		while (!found &&  (sup(left) - inf(left)) >= 2*minWidth) do {
		      m = D(mid(left));		
		      left = [ inf(dom), m ];
		      right = [ m, sup(dom) ];
		      leftdeg = checkIfSufficientDegreeOptimized(func, left, maxDegree, target);
		      if (leftdeg.okay) then {
		      	 found = leftdeg.sufficientDegree;
		      } else {
		      	found = false;
		      };
		};	
		if (found) then {
		   print("---I've found the longest interval on the left");
		   currRes = tryToIncreaseSplit(func, left, right, maxDegree, target, minWidth);
		   print("---after moving the right border: ", currRes);
		   currSplitPointsList = currSplitPointsList :. currRes.splitPoint;
		   currDegreeList = currDegreeList :. currRes.deg;		       		      
		   res = currRes;
		   res.splitPoints = currSplitPointsList;
		   res.deg = currDegreeList;
		   right = [(currRes.splitPoint), sup(right)];  
		   if ((sup(right) - inf(right)) > 0) then {
		     		currRes = computeDomainSplittingOptimizedInner(func, right, maxDegree, target, minWidth, currSplitPointsList, currDegreeList);
				res.splitPoints = res.splitPoints @ currRes.splitPoints;
				res.deg = res.deg @ currRes.deg; 
				res = currRes;
		     };	
		 } else {
		   print("domain split: there has been some error");
		   res = {.okay = false};		
		};
	      };
	    }; // end "need a split"
	  }; // checkIfSufficient... for the whole domain returned .okay == true
	  return res;
};

procedure tryToIncreaseSplit(func, left, rest, maxDegree, target, minWidth) {
	  var res, leftdeg, delta, newleft;
	  
	  //"tryToIncreaseSplit(", func, ", ", left, ", ", rest, ", ", maxDegree, ", ", target, ", ", minWidth, ")";
	  // For this moment we are sure that there is an approximating polynomial on the left with a degree <= maxDegree,
	  // we are interested in the largest intervals, so we'll try to enlarge left.
	  // As on the previous steps before calling this function we have divided interval by 2 in order to get the left, we'll try to 
	  // enlarge our interval with a third of it

	  delta = round(((sup(left) - inf(left)) / 7), D, RD);
	  newleft = left; //[ inf(left), sup(left) + delta ];
	  leftdeg = checkIfSufficientDegreeOptimized(func, newleft,  maxDegree, target)!; 
	  while (delta > minWidth/2 && sup(newleft) < sup(rest) ) do {  	//I don't know how to bound delta, just for experiment it is minWidth. Sometimes changing this bound from 2*minWidth to 5*minWidth gives 10 more subdomains. The less is the bound, least domains we get.
	  	print("delta = ", delta);
	  	newleft = [ inf(newleft), sup(newleft) + delta ];
	  	leftdeg = checkIfSufficientDegreeOptimized(func, newleft,  maxDegree, target)!;
		while (leftdeg.okay && leftdeg.sufficientDegree) do {
		    newleft = [ inf(newleft), sup(newleft) + delta ];
	  	    leftdeg = checkIfSufficientDegreeOptimized(func, newleft,  maxDegree, target)!;  
		};
		if (leftdeg.okay == false) then {
		   delta = 0;
		   res = {.okay = false};
		} else {
		  newleft = [ inf(newleft), sup(newleft) - delta ];
	  	  leftdeg = checkIfSufficientDegreeOptimized(func, newleft,  maxDegree, target)!;  
		  delta = round(delta/2, D, RD);
		};
	  };
	  //print("leftdeg here is", leftdeg);
	  res = leftdeg;
	  res.splitPoint = D(sup(newleft));
	  //print("after new version of tryToIncrease, res = ", res);

	  return res;
};

procedure computeDomainSplitting(func, dom, maxDegree, target, minWidth, sterbenzNeeded) {
	  var resultat;
	  var poly;
	  var deg;
	  var subdomains, splitpoints, aSp, bSp, sd;
	  var res, recursiveSplitPoints, y, guess;
	  var midpoint;
	  var remezFunc, remezDom;
	  var zeros, t, z;
	  var oldDisplay;
	  var resOpt;

	  "computeDomainSplitting(", func, ", ", dom, ", ", maxDegree, ", ", target, ", ", minWidth, ", ", sterbenzNeeded, ") started";

	  resultat = { .okay = false };
	  deg = -1;

	  resOpt = { .okay = false };

	  if (abs(sup(dom) - inf(dom)) - minWidth >= 0) then {

	  if (((!(0 in dom)) &&
	      (!(dom in [(mid(dom) * 100)/199;(mid(dom)*199)/100]))) && sterbenzNeeded) then {
	      /* We have to split because the Sterbenz condition will
	         not be fulfilled for center points on this subdomain

		 We simultate the case with a dummy degree that is too huge
	       */
	       deg = maxDegree * 2;
	  } else {

	  if ((!(inf(dom) * sup(dom) < 0)) || (!sterbenzNeeded)) then {
	      resOpt = computeDomainSplittingOptimized(func, dom, maxDegree, target, minWidth);
	      // resOpt.okay = false;
	  };    	  

	  if (!resOpt.okay) then {

	  remezFunc = func;
	  remezDom = dom;
	  if (0 in evaluate(func,dom)) then {
	     y = evaluate(func, 0);
	     if (!((inf(y) <= 0) && (sup(y) >= 0))) then {
	     	/* func has a zero in dom but not in 0 */
		zeros = mydirtyfindzeros(func, dom);
		if (zeros != [||]) then {
		   /* I found zeros of func in dom,
		      let's look for the zero farthest
		      from 0
		   */
		   t = zeros[0];
		   for z in zeros do {
		       if (abs(z) > abs(t)) then t = z;
		   };
		   /* Now translate the function so
		      that it has a zero in 0
                   */
		   remezFunc = func(x + t);
		   remezDom = dom - t;
		};
	     };
	  };

	  if (0 in remezDom) then { y = evaluate(remezFunc, 0); } else { y = 1; };
	  if ((inf(y) <= 0) && (sup(y) >= 0)) then {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),x/remezFunc,maxDegree+2); };
	     guess = guess + 1;

	  /*   
	  oldDisplay = display;
	  display = dyadic!;
	  "guessdegreewrapperwithbound(",1,",",remezDom,",",abs(target),",",x/remezFunc,",",maxDegree+2,") = ", guess;
	  display = oldDisplay!;
	  */
	     
	  } else {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),1/remezFunc,maxDegree+2); };

	  /*
	  oldDisplay = display;
	  display = dyadic!;
	  "guessdegreewrapperwithbound(",1,",",remezDom,",",abs(target),",",1/remezFunc,",",maxDegree+2,") = ", guess;
	  display = oldDisplay!;
	  */


	  };

	  if ((guess == guess) && (guess != false)) then {
	          deg = inf(guess);
	  } else {
	  	  write("Computing a remez polynomial for ", func, " in ", dom, " with target ", target,"\n");
	  	  poly = simpleRemezWrapper(remezFunc, remezDom, target, 3);
		  if ((poly == poly) && (poly != false)) then {
		     deg = degree(poly);
		  };
          };

	  };

	  };

	  if (resOpt.okay) then {
	     resultat = resOpt;
	  } else {

	  // "computeDomainSplitting: dom = ", dom, ", needed degree = ", deg;

	     if (deg >= 0) then {
	     	if (deg <= maxDegree) then {
		   resultat.okay = true;
		   resultat.splitPoints = [||];
		} else {
		   if (inf(dom) * sup(dom) < 0) then {
		      aSp = D(inf(dom)/3);
		      bSp = D(sup(dom)/3);
		      splitpoints = [| aSp , bSp |];
		      subdomains = [| [ inf(dom) , aSp ], [ aSp, bSp ], [ bSp, sup(dom) ] |];
		   } else {
		      aSp = D(mid(dom));
		      splitpoints = [| aSp |];
		      subdomains = [| [ inf(dom), aSp ], [ aSp, sup(dom) ] |];
		   };
		   okay = true;
		   recursiveSplitPoints = [||];
		   while ((okay) && (subdomains != [||])) do {
		   	 sd = head(subdomains);
			 subdomains = tail(subdomains);
			 res = computeDomainSplitting(func, sd, maxDegree, target, minWidth, sterbenzNeeded);
			 if (res.okay) then {
			    recursiveSplitPoints = recursiveSplitPoints @ (res.splitPoints);
			 } else {
			   okay = false;
			 };
		   };
		   if (okay) then {
		      resultat.okay = true;
		      resultat.splitPoints = recursiveSplitPoints @ splitpoints;
		   };
	     	};
	     };

	  };

	  };

	  "computeDomainSplitting(", func, ", ", dom, ", ", maxDegree, ", ", target, ", ", minWidth, ", ", sterbenzNeeded, ") finished, returning ", resultat;

	  return resultat;
};

procedure checkIfPropagatedErrorLessThan(func, dom, argEps, maxEps) {
	  var a, b, sa, sb, st, subdom;
	  var im, eps;
	  var fp;
	  var okay;

	  fp = diff(func);

	  a = inf(dom);
	  b = sup(dom);
	  st = (b-a)/100;

	  sa = a;
	  sb = sa + st;
	  okay = true;
	  while (okay && (sb <= b)) do {
	      subdom = [sa; sb];
	      im = subdom * argEps * evaluate(fp, subdom) / evaluate(func, subdom);
	      eps = sup(abs(im));
	      if (eps > abs(maxEps)) then {
	      	 okay = false;
	      };
	      sa = sb;
	      sb = sb + st;
	  };

	  return okay;
};

/* implements a function by polynomial approximation in small intervals
   that are automatically computed using a maximum polynomial degree
   indication

   Returns a structure that

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the maximum approximation error
          * implerr      the maximum implementation (round-off) error
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         reduction

   The function to be implemented may have at most 1 zero in each sub-domain.
   No test for this condition is made.

*/
procedure implementwithdomainsplitting(func, dom, maxDegree, minWidth, definitionDomain, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName, maxDegreeReconst) {
	  var resultat, res, splitPoints, myTarget, sterbenzNeeded, shiftEps, currDom, currDeg;

	  /* write("implementwithdomainsplitting(",func,",", dom,",", maxDegree,",", minWidth,",", definitionDomain,",", target,",", beta,",", variableFormat,",", implementationFile,",", gappaFile,",", gappaOutputFile,",", gappaExecutable,",", polynomialBaseName,",", maxDegreeReconst, ")\n"); */

	  sterbenzNeeded = true;
	  myTarget = target;

	  /* Check if we actually need to enforce Sterbenz condition 
	     on the sub-domain midpoints.
	  */

	  if ((variableFormat == D) &&
	      (abs(target) > 1b-50) && 
	      ((!(0 in dom)) &&
	      (!(dom in [(mid(dom) * 100)/199;(mid(dom)*199)/100])))) then {
	      /* First do a quick check if the perturbation affects the error by no more than a
	         quarter of the target error 
              */
	      if (checkIfPropagatedErrorLessThan(func, dom, 1b-53, 1/4 * abs(target))) then {
	      	     sterbenzNeeded = false;
		     myTarget = 1/4 * abs(target);
	      } else {
	          /* Bound the amount of final error added when adding one double precision 
                     rounding-error upon shifting 
	          */
	          shiftEps = abs(1b-53 * computeAmplification(func,dom,1b-53));

	          /* If that shifting error and a quarter of the target
	             error combined are less than the target error, do no longer 
		     try to get Sterbenz condition fullfilled.
                  */
	          if (shiftEps + 1/4 * abs(target) + shiftEps * 1/4 * abs(target) <= abs(target)) then {
	      	     sterbenzNeeded = false;
		     myTarget = 1/4 * abs(target);
	          };
              };
          };

	  /* In certain cases, the function so well contracts the relative error 
	     than even if zero is in the domain we can afford an extra reduction error.
	  */
	  if (sterbenzNeeded) then {
	     if (checkIfPropagatedErrorLessThan(func, dom, 1b-53, 1/4 * abs(target))) then {
	         sterbenzNeeded = false;
		 myTarget = 1/4 * abs(target);
	     };
	  };

	  resultat = { .okay = false };

	  res = computeDomainSplitting(func, dom, maxDegree, myTarget, minWidth, sterbenzNeeded);

	  print(" in func implementwithdomainsplitlist, computeDomSplitting = ", res);

	  if (res.okay) then {
	     splitPoints = sort(res.splitPoints);

	     write("The domain will first be split at the following points(", length(splitPoints) + 1, "): ", splitPoints, "\n");
	   /*  print("The corresponding degrees are: ");
	     currDom = dom;
	     for spPoint in splitPoints do {
	     	 currDom = [inf(currDom), spPoint];
		 currDeg = checkIfSufficientDegreeInner(func, currDom, maxDegree, target, sterbenzNeeded)!;
		 print("domain = ", currDom, " size =  ", (sup(currDom) - inf(currDom)), " degree = ", currDeg);
		 currDom = [spPoint];
	     };
	     currDom = [inf(currDom), sup(dom)];
	     currDeg = checkIfSufficientDegreeInner(func, currDom, maxDegree, target, sterbenzNeeded)!;
	     print("domain = ", currDom, " size =  ", (sup(currDom) - inf(currDom)), " degree = ", currDeg);*/

	     print("in func implementwithdomainsplitlist, splitPoints = ", splitPoints);

	     res = implementwithdomainsplitlist(func, dom, splitPoints, minWidth, definitionDomain, myTarget, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName, maxDegreeReconst);

	     if (res.okay) then {
	     	resultat = res;
	     };

	  } else {
	    write("Could not compute a domain splitting\n");
	  };

	  print(" in function implementwithdomainsplitting, resultat = ", resultat);
	  return resultat;
};


procedure tryImplementationThroughDomainSplitting(problemdef, parametrization) {
	  var result, definitionDomain;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default } } : {
				                definitionDomain = problemdef.dom;
						match (problemdef) with
                                                      { .definitionDomain = default } : { definitionDomain = problemdef.definitionDomain; }
                                                      default : { };
					        result = implementwithdomainsplitting(problemdef.func,
						                                      problemdef.dom,
                                                                                      parametrization.maxDegree,
                                                                                      parametrization.minWidth,
										      definitionDomain,
                                                                                      problemdef.target,
                                                                                      parametrization.beta,
                                                                                      problemdef.variableFormat,
                                                                                      parametrization.implementationFile,
										      parametrization.gappaFile,
										      parametrization.gappaOutputFile,
										      parametrization.gappaExecutable,
										      parametrization.functionBasename, 
										      parametrization.maxDegreeReconstruction);
					}
                default : { };

	  return result;
};

procedure checkIfSufficientDegreeInner(func, dom, maxDegree, target, sterbenzNeeded) {
	  var resultat;
	  var poly;
	  var deg;
	  var y, guess;
	  var remezFunc, remezDom;
	  var zeros, t, z;

	  "checkIfSufficientDegreeInner(",func,",", dom,",", maxDegree,",", target,",", sterbenzNeeded,") started";

	  resultat = { .okay = false };
	  deg = -1;

	  if (((!(0 in dom)) &&
	      (!(dom in [(mid(dom) * 100)/199;(mid(dom)*199)/100]))) && 
	      sterbenzNeeded) then {
	      /* We have to split because the Sterbenz condition will
	         not be fulfilled for center points on this subdomain

		 We simultate the case with a dummy degree that is too huge
	       */
	       deg = maxDegree * 2;

	  } else {

	  remezFunc = func;
	  remezDom = dom;
	  if (0 in evaluate(func,dom)) then {
	     y = evaluate(func, 0);
	     if (!((inf(y) <= 0) && (sup(y) >= 0))) then {
	     	/* func has a zero in dom but not in 0 */
		zeros = mydirtyfindzeros(func, dom);
		if (zeros != [||]) then {
		   /* I found zeros of func in dom,
		      let's look for the zero farthest
		      from 0
		   */
		   t = zeros[0];
		   for z in zeros do {
		       if (abs(z) > abs(t)) then t = z;
		   };
		   /* Now translate the function so
		      that it has a zero in 0
                   */
		   remezFunc = func(x + t);
		   remezDom = dom - t;
		};
	     };
	  };

	  "in checkIfSufficientDegreeInner: now launching the guessdegree";

	  if (0 in remezDom) then { y = evaluate(remezFunc, 0); } else { y = 1; };
	  if ((inf(y) <= 0) && (sup(y) >= 0)) then {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),x/remezFunc,maxDegree+2); };
	     guess = guess + 1;
	  } else {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),1/remezFunc,maxDegree+2); };
	  };

	  if ((guess == guess) && (guess != false)) then {
	          deg = inf(guess);
	  } else {
	  	  write("Computing a remez polynomial for ", func, " in ", dom, " with target ", target,"\n");
	  	  poly = simpleRemezWrapper(remezFunc, remezDom, target, 3);
		  if ((poly == poly) && (poly != false)) then {
		     deg = degree(poly);
		  };
          };

	  };

	     if (deg >= 0) then {
	     	if (deg <= maxDegree) then {
		   resultat.okay = true;
		   resultat.sufficientDegree = true;
		   resultat.deg = deg;
		} else {
		   resultat.okay = true;
		   resultat.sufficientDegree = false;
	     	};
	     };

	  "checkIfSufficientDegreeInner(",func,",", dom,",", maxDegree,",", target,",", sterbenzNeeded,") finished, returning ", resultat;

	  return resultat;
};

procedure checkIfSufficientDegree(func, dom, maxDegree, target) {
	  return checkIfSufficientDegreeInner(func, dom, maxDegree, target, true);
};

procedure checkIfSufficientDegreeOptimized(func, dom, maxDegree, target) {
	  return checkIfSufficientDegreeInner(func, dom, maxDegree, target, false);
};

procedure tryDetectSymmetry(func, dom, target) {
	  var res, testfunc, zerosUpper, zerosLower, myDom, yA, yB;

	  res = { .okay = false };

	  myDom = [0; min(sup(dom), -inf(dom))];
	  testfunc = simplifysafe((func/(func(-x))) - 1);
	  yA = evaluate(testfunc + target, min(sup(dom), -inf(dom)) / 2);
	  yB = evaluate(testfunc - target, min(sup(dom), -inf(dom)) / 2);
	  if ((inf(yA) > 0) && (sup(yB) < 0)) then {
	  	  zerosUpper = mydirtyfindzeros(testfunc + target, myDom);
	  	  zerosLower = mydirtyfindzeros(testfunc - target, myDom);
          } else {
	          zerosUpper = [| 0 |];
		  zerosLower = [| 0 |];
	  };

	  if ((zerosUpper == [||]) && (zerosLower == [||])) then {
	     res.okay = true;
	     res.evenSymmetry = true;
	  } else {
	     testfunc = simplifysafe((func/(-func(-x))) - 1);
  	     yA = evaluate(testfunc + target, min(sup(dom), -inf(dom)) / 2);
	     yB = evaluate(testfunc - target, min(sup(dom), -inf(dom)) / 2);
	     if ((inf(yA) > 0) && (sup(yB) < 0)) then {
	  	  zerosUpper = mydirtyfindzeros(testfunc + target, myDom);
	  	  zerosLower = mydirtyfindzeros(testfunc - target, myDom);
             } else {
	          zerosUpper = [| 0 |];
		  zerosLower = [| 0 |];
	     };

	     if ((zerosUpper == [||]) && (zerosLower == [||])) then {
	        res.okay = true;
	        res.evenSymmetry = false;
	     };
	  };

	  return res;
};

procedure tryImplementationThroughSymmetryDetectionAroundZero(problemdef, parametrization) {
	  var result, splitPoints, needToDetectSymmetry, res, evenSymmetry, myDom, oppositeOnNegative;
	  var suffix, myProblemdef, myParametrization, origDefDom, symmetryCode, dom;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default } } : {

				       dom = problemdef.dom;

				       /* Start with a test if zero is actually inside the domain */
				       if (sup(problemdef.dom) * inf(problemdef.dom) < 0) then {

				       /* Continue with a test if the domain actually needs
                                          to be split in order to stay below the maximum
					  polynomial degree
				        */
				       needToDetectSymmetry = true;
				       res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                               if (res.okay) then {
   	                                   if (res.sufficientDegree) then needToDetectSymmetry = false;
				       } else {
				           needToDetectSymmetry = false;
				       };

				       if (needToDetectSymmetry) then {

				            /* Try to detect a symmetry of func around 0 */
					    res = tryDetectSymmetry(problemdef.func, problemdef.dom, problemdef.target * 13/32);

					    if (res.okay) then {
					       /* If we detected a symmetry */
					       if (res.evenSymmetry) then {
					       	  write("Detected an even symmetry\n");
					       } else {
					          write("Detected an odd symmetry\n");
					       };
					       /* Now compute the reduced domain and determine
					          when we have to compute the opposite of the argument.
					       */
                                               if (-inf(dom) < sup(dom)) then {
					           myDom = [ 0, sup(dom) ];
						   oppositeOnNegative = true;
					       } else {
					           myDom = [ inf(dom), 0 ];
						   oppositeOnNegative = false;
					       };
					       evenSymmetry = res.evenSymmetry;
					       write("The subdomain after range reduction for symmetry is: ", myDom, "\n");

					       /* Now call the implementer recursively on the reduced domain */
					       suffix = "_symmetrical";
					       myProblemdef = problemdef;
					       myProblemdef.dom = myDom;
					       myProblemdef.target = problemdef.target * 13/32;
					       origDefDom = dom;
					       match (problemdef) with { .definitionDomain = default } : {
					                       if (origDefDom in problemdef.definitionDomain) then {
                                                                  origDefDom = problemdef.definitionDomain;
                                                               }; }
                                                                       default : {};
					       myProblemdef.definitionDomain = origDefDom;
					       myParametrization = parametrization;
					       myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					       myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					       myParametrization.functionBasename = parametrization.functionBasename @ suffix;
					       myParametrization.minWidth = (sup(myDom) - inf(myDom)) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
					       myParametrization.argumentReduced = true;

					       res = tryImplementation(myProblemdef, myParametrization);

					       if (res.okay) then {
					       	  /* The implementation worked on the subdomain

						     Now generate the reduction code.

						  */
						  symmetryCode = "";
						  symmetryCode = symmetryCode @ "\n\nvoid "@parametrization.functionBasename@"(";
						  symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                       D   : ( "double *res_resh, " )
                                                                                       DD  : ( "double *res_resh, double *res_resm, " )
                                                                                       TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                                                                );
                                                  symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                       D   : ( "double xh" )
                                                                                       DD  : ( "double xh, double xm" )
                                                                                       TD  : ( "double xh, double xm, double xl" )
                                                                                );
                                                  symmetryCode = symmetryCode @ ") {\n";
						  if (evenSymmetry) then {
						     if (oppositeOnNegative) then {
						     	symmetryCode = symmetryCode @ "if (xh < 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     } else {
						     	symmetryCode = symmetryCode @ "if (xh > 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     };
						  } else {
						     symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                          D   : ( "double sym_res_resh;" )
                                                                                          DD  : ( "double sym_res_resh, sym_res_resm;" )
                                                                                          TD  : ( "double sym_res_resh, sym_res_resm, sym_res_resl;" )
                                                                                   );
						     symmetryCode = symmetryCode @ "\n";
						     if (oppositeOnNegative) then {
						     	symmetryCode = symmetryCode @ "if (xh < 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                             D   : ( "&sym_res_resh, " )
                                                                                             DD  : ( "&sym_res_resh, &sym_res_resm, " )
                                                                                             TD  : ( "&sym_res_resh, &sym_res_resm, &sym_res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						        symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                             D   : ( "*res_resh = -sym_res_resh;" )
                                                                                             DD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm;" )
                                                                                             TD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm; *res_resl = -sym_res_resl;" )
                                                                                      );
						        symmetryCode = symmetryCode @ "\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     } else {
						     	symmetryCode = symmetryCode @ "if (xh > 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                             D   : ( "&sym_res_resh, " )
                                                                                             DD  : ( "&sym_res_resh, &sym_res_resm, " )
                                                                                             TD  : ( "&sym_res_resh, &sym_res_resm, &sym_res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						        symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                             D   : ( "*res_resh = -sym_res_resh;" )
                                                                                             DD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm;" )
                                                                                             TD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm; *res_resl = -sym_res_resl;" )
                                                                                      );
						        symmetryCode = symmetryCode @ "\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     };
						  };
						  symmetryCode = symmetryCode @ "}\n";
						  write(symmetryCode) >> parametrization.implementationFile;
						  result = res;
						  result.functionname = parametrization.functionBasename;
					       };
					    };
				       };
				       };
				     }
                default : { };

	  return result;
};

procedure tryDetectExponentialArgRed(func, dom, target) {
	  var result, base, a, b, c, d, ratio, oldPrec, testfunc;
	  var y, zerosUpper, zerosLower;

	  result = { .okay = false };

	  /* We have to detect if func behaves in dom
	     like

	     base^x for some unknown base

	     We say that func behaves like base^x
	     if

	     base^x = func * (1 + eps) with abs(eps) <= target.

	     We start by computing a possible base
	     as

	     base = exp((log(f(c+d)/f(c))/d))

	     with

	       - d = b - a                  if b - a < 5
	         c = a

	       - d = 5                      otherwise
                 c = max(a, (a+b)/2 - 2.5)

             where dom = [a;b]

	     We can stop trying if f(c+d)/f(c) is
	     negative.
	  */
	  a = inf(dom);
	  b = sup(dom);
	  if ((0 in dom) && (max(-a,b) > 5))then {
	     if (-a > b) then {
	     	c = -5;
		d = 5;
	     } else {
	        c = 0;
		d = 5;
	     };
	  } else {
	  	  if (b - a < 5) then {
	  	     d = b - a;
		     c = a;
	  	  } else {
	     	     d = 5;
	             c = max(a, (a + b)/2 - 2.5);
	          };
	  };
	  ratio = func(c + d) / func(c);

	  if (~ratio > 0) then {
	     /* Here, f(c + d) / f(c) is positive

	        So we can compute a presumed base
		as

		base = exp(log(ratio)/d)

		where ratio = f(c + d) / f(c)

		We need to perform this evaluation
		with an accuracy of at least the
		double of the prevailing precision
		as the rest of the argument reduction
		code must receive a pretty accurate
		base.

	     */
	     oldPrec = prec;
	     prec = max(2 * prec, ceil(-log2(abs(target))) * 3)!;
	     base := exp(log(ratio) / d);
	     prec = oldPrec!;

	     /* Now we have to check if base^x effectively approximates func with
	        an accuracy of target
	     */
	     testfunc = simplifysafe((base^x)/func - 1);
	     y = evaluate(testfunc, [mid(dom)]);
	     if (y in [-target, target]) then {
	  	  zerosUpper = mydirtyfindzeros(testfunc + target, dom);
	  	  zerosLower = mydirtyfindzeros(testfunc - target, dom);

		  if ((zerosUpper == [||]) && (zerosLower == [||])) then {
		      if (base != 1) then {
		      	              result.okay = true;
		      		      result.exponentialFunc = base^x;
				      result.exponentialBase = base;
		      };
	          };
             };
	  };
	  return result;
};

procedure tryGenerateExponentialArgumentReduction(base, dom, functionName, polynomialFunctionName, outputformat, polynomialVariableFormat, variableFormat, argRedTarget, reconstructTableTarget, tableWidth) {
	  var result, code, table, okay, variableDeclarations, reductionCode, reconstructionCode;
	  var oldDisplay, tableFormat, i, tblEntry, tblEntryExact, logBaseOfTwoFormat, logBaseOfTwoExact;

	  result = { .okay = false };
	  okay = true;

	  table = "\n";
	  oldDisplay = display;
	  display = decimal!;
	  if (tableWidth > 0) then {
	        if (3/8 * reconstructTableTarget < 1b-107) then tableFormat = TD
                else if (3/8 * reconstructTableTarget < 1b-53) then tableFormat = DD
		else tableFormat = D;
	  	table = table @ "static const double " @ functionName @ "_twoPower_Index_Hi[" @ (~(2^tableWidth)) @ "] = {\n";
		for i from 0 to 2^tableWidth - 1 do {
		    tblEntryExact = 2^(i * 2^(-tableWidth));
		    tblEntry = simplifysafe(D(tblEntryExact));
		    table = table @ " " @ tblEntry;
		    if (i != 2^tableWidth - 1) then table = table @ ",";
		    table = table @ "\n";
		};
		table = table @ "};\n\n";
		if ((tableFormat == DD) || (tableFormat == TD)) then {
	           table = table @ "static const double " @ functionName @ "_twoPower_Index_Mi[" @ (~(2^tableWidth)) @ "] = {\n";
		   for i from 0 to 2^tableWidth - 1 do {
		       tblEntryExact = 2^(i * 2^(-tableWidth));
		       tblEntry = simplifysafe(D(tblEntryExact - D(tblEntryExact)));
		       table = table @ " " @ tblEntry;
		       if (i != 2^tableWidth - 1) then table = table @ ",";
		       table = table @ "\n";
		   };
		   table = table @ "};\n\n";
		};
	        if (tableFormat == TD) then {
	           table = table @ "static const double " @ functionName @ "_twoPower_Index_Lo[" @ (~(2^tableWidth)) @ "] = {\n";
		   for i from 0 to 2^tableWidth - 1 do {
		       tblEntryExact = 2^(i * 2^(-tableWidth));
		       tblEntry = simplifysafe(D(tblEntryExact - (D(tblEntryExact) + D(tblEntryExact - D(tblEntryExact)))));
		       table = table @ " " @ tblEntry;
		       if (i != 2^tableWidth - 1) then table = table @ ",";
		       table = table @ "\n";
		   };
		   table = table @ "};\n\n";
		};
          };

	  table = table @ "#define " @ functionName @ "_argred_log2_of_base_times_two_to_w " @ (simplifysafe(D(log2(base) * 2^tableWidth))) @ "\n";

	  if (argRedTarget * 2^(-tableWidth - 2) < 1b-106) then logBaseOfTwoFormat = TD
	  else if (argRedTarget * 2^(-tableWidth - 2) < 1b-53) then logBaseOfTwoFormat = DD
	  else logBaseOfTwoFormat = D;

	  logBaseOfTwoExact = -2^(-tableWidth) * log(2)/log(base);
	  table = table @ "#define " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi " @ (simplifysafe(D(logBaseOfTwoExact))) @ "\n";
	  if ((logBaseOfTwoFormat == DD) || (logBaseOfTwoFormat == TD)) then {
	     table = table @ "#define " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_mi " @ (simplifysafe(D(logBaseOfTwoExact - D(logBaseOfTwoExact)))) @ "\n";
	  };
	  if (logBaseOfTwoFormat == TD) then {
	     table = table @ "#define " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_lo " @ (simplifysafe(D(logBaseOfTwoExact - (D(logBaseOfTwoExact) + D(logBaseOfTwoExact - D(logBaseOfTwoExact)))))) @ "\n";
	  };

	  table = table @ "#define " @ functionName @ "_argred_shifter 6755399441055744.0\n";
	  table = table @ "#define " @ functionName @ "_argred_w " @ tableWidth @ "\n";
	  table = table @ "#define " @ functionName @ "_argred_idx_mask " @ (simplifysafe(2^tableWidth - 1)) @ "ull\n";
	  table = table @ "#define " @ functionName @ "_argred_lower_32_bits 0xffffffffull\n";
	  display=oldDisplay!;

	  variableDeclarations = "\n";
	  reductionCode = "\n";
	  reconstructionCode = "\n";

 	  variableDeclarations = variableDeclarations @ "double t;\n";
	  reductionCode = reductionCode @ "t = xh * " @ functionName @ "_argred_log2_of_base_times_two_to_w;\n";
 	  variableDeclarations = variableDeclarations @ "double shifted_t;\n";
	  reductionCode = reductionCode @ "shifted_t = t + " @ functionName @ "_argred_shifter;\n";
 	  variableDeclarations = variableDeclarations @ "double mAsDouble;\n";
	  reductionCode = reductionCode @ "mAsDouble = shifted_t - " @ functionName @ "_argred_shifter;\n";
 	  variableDeclarations = variableDeclarations @ "db_number argRedCaster;\n";
 	  variableDeclarations = variableDeclarations @ "int mAsInt;\n";
	  reductionCode = reductionCode @ "argRedCaster.d = shifted_t;\n";
	  reductionCode = reductionCode @ "mAsInt = (int) (argRedCaster.l & " @ functionName @ "_argred_lower_32_bits);\n";
 	  variableDeclarations = variableDeclarations @ "int E;\n";
	  reductionCode = reductionCode @ "E = mAsInt >> " @ functionName @ "_argred_w;\n";
 	  variableDeclarations = variableDeclarations @ "int E1;\n";
	  reductionCode = reductionCode @ "E1 = E >> 1;\n";
 	  variableDeclarations = variableDeclarations @ "int E2;\n";
	  reductionCode = reductionCode @ "E2 = E - E1;\n";
 	  variableDeclarations = variableDeclarations @ "int idx;\n";
	  reductionCode = reductionCode @ "idx = mAsInt & " @ functionName @ "_argred_idx_mask;\n";

	  match (logBaseOfTwoFormat) with
	  	D  : {
		        variableDeclarations = variableDeclarations @ "double rescaled_m_hi;\n";
	                reductionCode = reductionCode @ "rescaled_m_hi = mAsDouble * " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi;\n";
		     }
		DD : {
		        variableDeclarations = variableDeclarations @ "double rescaled_m_hi;\n";
		        variableDeclarations = variableDeclarations @ "double rescaled_m_mi;\n";
	                reductionCode = reductionCode @ "Mul122(&rescaled_m_hi, &rescaled_m_mi, mAsDouble, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_mi);\n";
	             }
		TD : {
		        variableDeclarations = variableDeclarations @ "double rescaled_m_hi;\n";
		        variableDeclarations = variableDeclarations @ "double rescaled_m_mi;\n";
		        variableDeclarations = variableDeclarations @ "double rescaled_m_lo;\n";
	                reductionCode = reductionCode @ "Mul133(&rescaled_m_hi, &rescaled_m_mi, &rescaled_m_lo, mAsDouble, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_mi, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_lo);\n";
	             };

	  match (logBaseOfTwoFormat) with
	  	D  : {
		          match (variableFormat) with
			  	D  : {
				         match (polynomialVariableFormat) with
					       D  : {
	                                                reductionCode = reductionCode @ "zh = xh + rescaled_m_hi;\n";
					       	    }
					       DD : {
	                                                reductionCode = reductionCode @ "zh = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "zm = 0.0;\n";
					       	    }
					       TD : {
	                                                reductionCode = reductionCode @ "zh = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "zm = 0.0;\n";
	                                                reductionCode = reductionCode @ "zl = 0.0;\n";
					       	    };
				     }
			  	DD : {
				         match (polynomialVariableFormat) with
					       D  : {
	                                                reductionCode = reductionCode @ "zh = (xh + rescaled_m_hi) + xm;\n";
					       	    }
					       DD : {
					                variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,xm);\n";
					       	    }
					       TD : {
					                variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,xm);\n";
                                                        reductionCode = reductionCode @ "zl = 0.0;\n";
					       	    };
				     }
			  	TD : {
				         match (polynomialVariableFormat) with
					       D  : {
	                                                reductionCode = reductionCode @ "zh = (xh + rescaled_m_hi) + (xm + xl);\n";
					       	    }
					       DD : {
					                variableDeclarations = variableDeclarations @ "double tempArgRed1;\n";
					                variableDeclarations = variableDeclarations @ "double tempArgRed2;\n";
	                                                reductionCode = reductionCode @ "tempArgRed1 = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "tempArgRed2 = xm + xl;\n";
	                                                reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed1,tempArgRed2);\n";
					       	    }
					       TD : {
					                variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
					                variableDeclarations = variableDeclarations @ "double tempArgRed_hi;\n";
					                variableDeclarations = variableDeclarations @ "double tempArgRed_mi;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
	                                                reductionCode = reductionCode @ "Add12Cond(tempArgRed_hi,tempArgRed_mi,tempArgRed,xm);\n";
                                                        reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed_hi,tempArgRed_mi,xl);\n";
					       	    };
				     };
		     }
		DD : {
		          match (variableFormat) with
			  	D  : {
				         match (polynomialVariableFormat) with
					       D  : {
	                                                reductionCode = reductionCode @ "zh = (xh + rescaled_m_hi) + rescaled_m_mi;\n";
					       	    }
					       DD : {
					       	        variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
						        reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,rescaled_m_mi);\n";
					       	    }
					       TD : {
					       	        variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
						        reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,rescaled_m_mi);\n";
						        reductionCode = reductionCode @ "zl = 0.0;\n";
					       	    };
				     }
			  	DD : {
				         match (polynomialVariableFormat) with
					       D  : {
	                                                reductionCode = reductionCode @ "tempArgRed = ((xh + rescaled_m_hi) + xm) + rescaled_m_mi;\n";
					       	    }
					       DD : {
					                reductionCode = reductionCode @ "Add22(&zh,&zm,xh,xm,rescaled_m_hi,rescaled_m_mi);\n";
					       	    }
					       TD : {
					       	        variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Add12Cond(tempArgRed2_hi,tempArgRed2_lo,xm,rescaled_m_hi);\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed,tempArgRed2_hi,tempArgRed2_lo);\n";
					       	    };
				     }
			  	TD : {
				         match (polynomialVariableFormat) with
					       D  : {
					                reductionCode = reductionCode @ "tempArgRed = (((xh + rescaled_m_hi) + xm) + rescaled_m_mi) + xl;\n";
					       	    }
					       DD : {
					       	        variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,xl);\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
					       	    }
					       TD : {
					       		variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed4;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,xl);\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed3_hi,&tempArgRed3_mi,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
							reductionCode = reductionCode @ "tempArgRed4 = tempArgRed3_lo + tempArgRed2_lo;\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed3_hi,tempArgRed3_mi,tempArgRed4);\n";
					       	    };
				     };
	             }
		TD : {
		          match (variableFormat) with
			  	D  : {
				         match (polynomialVariableFormat) with
					       D  : {
	                                                reductionCode = reductionCode @ "zh = ((xh + rescaled_m_hi) + rescaled_m_mi) + rescaled_m_lo;\n";
					       	    }
					       DD : {
							variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed2,tempArgRed,rescaled_m_mi,rescaled_m_lo);\n";
					       	    }
					       TD : {
							variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed,rescaled_m_mi,rescaled_m_lo);\n";
					       	    };
				     }
			  	DD : {
				         match (polynomialVariableFormat) with
					       D  : {
	                                                reductionCode = reductionCode @ "zh = (((xh + rescaled_m_hi) + xm) + rescaled_m_mi) + rescaled_m_lo;\n";
					       	    }
					       DD : {
					       		variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed4;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed5;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,rescaled_m_lo);\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed3_hi,&tempArgRed3_mi,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
							reductionCode = reductionCode @ "tempArgRed4 = tempArgRed3_lo + tempArgRed2_lo;\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed5,tempArgRed3_hi,tempArgRed3_mi,tempArgRed4);\n";
					       	    }
					       TD : {
					       		variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed4;\n";
	                                                reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,rescaled_m_lo);\n";
							reductionCode = reductionCode @ "Renormalize3(&tempArgRed3_hi,&tempArgRed3_mi,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
							reductionCode = reductionCode @ "tempArgRed4 = tempArgRed3_lo + tempArgRed2_lo;\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed3_hi,tempArgRed3_mi,tempArgRed4);\n";
					       	    };
				     }
			  	TD : {
				         match (polynomialVariableFormat) with
					       D  : {
	                                                reductionCode = reductionCode @ "zh = ((((xh + rescaled_m_hi) + xm) + rescaled_m_mi) + xl) + rescaled_m_lo;\n";
					       	    }
					       DD : {
							variableDeclarations = variableDeclarations @ "double tempArgRed_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed_lo;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed2;\n";
							reductionCode = reductionCode @ "Add33(&tempArgRed_hi,&tempArgRed_mi,&tempArgRed_lo,xh,xm,xl,rescaled_m_hi,rescaled_m_mi,rescaled_m_lo);\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed2,tempArgRed_hi,tempArgRed_mi,tempArgRed_lo);\n";
					       	    }
					       TD : {
							variableDeclarations = variableDeclarations @ "double tempArgRed_hi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed_mi;\n";
							variableDeclarations = variableDeclarations @ "double tempArgRed_lo;\n";
							reductionCode = reductionCode @ "Add33(&tempArgRed_hi,&tempArgRed_mi,&tempArgRed_lo,xh,xm,xl,rescaled_m_hi,rescaled_m_mi,rescaled_m_lo);\n";
							reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed_hi,tempArgRed_mi,tempArgRed_lo);\n";
					       	    };
				     };
	             };

	  if (tableWidth > 0) then {
          match (outputformat) with
                D  : {
			match (tableFormat) with
			      D  : {
					variableDeclarations = variableDeclarations @ "double table_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "tableTimesPoly_hi = table_hi * poly_resh;\n";
			      	   }
			      DD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_lo;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr2;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul12(&tempReconstr_hi,&tempReconstr_lo,table_hi,poly_resh);\n";
					reconstructionCode = reconstructionCode @ "tempReconstr2 = table_mi * poly_resh;\n";
					reconstructionCode = reconstructionCode @ "tableTimesPoly_hi = tempReconstr_hi + (tempReconstr_lo + tempReconstr2);\n";
			      	   }
		              TD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
				        variableDeclarations = variableDeclarations @ "double table_lo;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_lo;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr2_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr2_lo;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr3_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr3_lo;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr4;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_lo = " @ functionName @ "_twoPower_Index_Lo[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul12(&tempReconstr_hi,&tempReconstr_lo,table_hi,poly_resh);\n";
					reconstructionCode = reconstructionCode @ "Mul12(&tempReconstr2_hi,&tempReconstr2_lo,table_mi,poly_resh);\n";
					reconstructionCode = reconstructionCode @ "Add12Cond(tempReconstr3_hi,tempReconstr3_lo,tempReconstr_lo,tempReconstr2_hi);\n";
					reconstructionCode = reconstructionCode @ "tempReconstr4 = table_lo * poly_resh;\n";
					reconstructionCode = reconstructionCode @ "tableTimesPoly_hi = (((tempReconstr4 + tempReconstr2_lo) + tempReconstr3_lo) + tempReconstr3_hi) + tempReconstr_hi;\n";
			      	   };
		     }
                DD : {
		        match (tableFormat) with
			      D  : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul122(&tableTimesPoly_hi,&tableTimesPoly_mi,table_hi,poly_resh,poly_resm);\n";
			      	   }
			      DD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul22(&tableTimesPoly_hi,&tableTimesPoly_mi,table_hi,table_mi,poly_resh,poly_resm);\n";
			      	   }
		              TD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
				        variableDeclarations = variableDeclarations @ "double table_lo;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_hi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_mi;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr_lo;\n";
					variableDeclarations = variableDeclarations @ "double tempReconstr2;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_lo = " @ functionName @ "_twoPower_Index_Lo[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul233(&tempReconstr_hi,&tempReconstr_mi,&tempReconstr_lo,poly_resh,poly_resm,table_hi,table_mi,table_lo);\n";
					reconstructionCode = reconstructionCode @ "Renormalize3(&zh,&zm,&tempReconstr2,tempReconstr_hi,tempReconstr_mi,tempReconstr_lo);\n";
			      	   };
                     }
                TD : {
			match (tableFormat) with
			      D  : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_lo;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul133(&tableTimesPoly_hi,&tableTimesPoly_mi,&tableTimesPoly_lo,table_hi,poly_resh,poly_resm,poly_resl);\n";
			      	   }
			      DD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_lo;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul233(&tableTimesPoly_hi,&tableTimesPoly_mi,&tableTimesPoly_lo,table_hi,table_mi,poly_resh,poly_resm,poly_resl);\n";
			      	   }
		              TD : {
				        variableDeclarations = variableDeclarations @ "double table_hi;\n";
				        variableDeclarations = variableDeclarations @ "double table_mi;\n";
				        variableDeclarations = variableDeclarations @ "double table_lo;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
					variableDeclarations = variableDeclarations @ "double tableTimesPoly_lo;\n";
					reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
					reconstructionCode = reconstructionCode @ "table_lo = " @ functionName @ "_twoPower_Index_Lo[idx];\n";
					reconstructionCode = reconstructionCode @ "Mul33(&tableTimesPoly_hi,&tableTimesPoly_mi,&tableTimesPoly_lo,table_hi,table_mi,table_lo,poly_resh,poly_resm,poly_resl);\n";
			      	   };
                     };
          };

	  variableDeclarations = variableDeclarations @ "db_number twoE1;\n";
	  reconstructionCode = reconstructionCode @ "twoE1.l = E1 + 1023ll;\n";
	  reconstructionCode = reconstructionCode @ "twoE1.l <<= 52;\n";
	  variableDeclarations = variableDeclarations @ "db_number twoE2;\n";
	  reconstructionCode = reconstructionCode @ "twoE2.l = E2 + 1023ll;\n";
	  reconstructionCode = reconstructionCode @ "twoE2.l <<= 52;\n";

	  if (tableWidth > 0) then {
          match (outputformat) with
                D  : {
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_hi = twoE1.d * tableTimesPoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1tablePoly_hi;\n";
		     }
		DD : {
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_hi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_mi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_hi = twoE1.d * tableTimesPoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_mi = twoE1.d * tableTimesPoly_mi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1tablePoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1tablePoly_mi;\n";
		     }
		TD : {
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_hi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_mi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1tablePoly_lo;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_hi = twoE1.d * tableTimesPoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_mi = twoE1.d * tableTimesPoly_mi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1tablePoly_lo = twoE1.d * tableTimesPoly_lo;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1tablePoly_hi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1tablePoly_mi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resl = twoE2.d * twoE1tablePoly_lo;\n";
		     };
          } else {
          match (outputformat) with
                D  : {
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_hi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_hi = twoE1.d * poly_resh;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1Poly_hi;\n";
		     }
		DD : {
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_hi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_mi;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_hi = twoE1.d * poly_resh;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_mi = twoE1.d * poly_resm;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1Poly_hi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1Poly_mi;\n";
		     }
		TD : {
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_hi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_mi;\n";
		         variableDeclarations = variableDeclarations @ "double twoE1Poly_lo;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_hi = twoE1.d * poly_resh;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_mi = twoE1.d * poly_resm;\n";
			 reconstructionCode = reconstructionCode @ "twoE1Poly_lo = twoE1.d * poly_resl;\n";
			 reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1Poly_hi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1Poly_mi;\n";
			 reconstructionCode = reconstructionCode @ "*res_resl = twoE2.d * twoE1Poly_lo;\n";
		     };
	  };

	  code = "\n";
	  code = code @ "void " @ functionName @ "(";
	  code = code @ (match outputformat with
                               D   : ( "double *res_resh, " )
                               DD  : ( "double *res_resh, double *res_resm, " )
                               TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                        );
          code = code @ (match variableFormat with
                               D   : ( "double xh" )
                               DD  : ( "double xh, double xm" )
                               TD  : ( "double xh, double xm, double xl" )
                        );
          code = code @ ") {\n";
          code = code @ (match polynomialVariableFormat with
                               D   : ( "double zh;" )
                               DD  : ( "double zh, zm;" )
                               TD  : ( "double zh, zm, zl;" )
                        );
          code = code @ "\n";
          code = code @ (match outputformat with
                               D   : ( "double poly_resh;" )
                               DD  : ( "double poly_resh, poly_resm;" )
                               TD  : ( "double poly_resh, poly_resm, poly_resl;" )
                        );
          code = code @ "\n";
	  code = code @ variableDeclarations @ "\n";
	  code = code @ reductionCode @ "\n";
          code = code @ polynomialFunctionName @ "(";
          code = code @ (match outputformat with
                               D   : ( "&poly_resh, " )
                               DD  : ( "&poly_resh, &poly_resm, " )
                               TD  : ( "&poly_resh, &poly_resm, &poly_resl, " )
                        );
          code = code @ (match polynomialVariableFormat with
                               D   : ( "zh" )
                               DD  : ( "zh, zm" )
                               TD  : ( "zh, zm, zl" )
                        );
          code = code @ ");\n";
	  code = code @ reconstructionCode @ "\n";
          code = code @ "}\n";

	  if (okay) then {
	     result.code = table @ code;
	     result.okay = true;
	  };

	  return result;
};

procedure tryImplementationThroughArgumentReductionExponential(problemdef, parametrization) {
	  var result, needArgumentReduction, res, myTableWidth, base, myDom, reducedFunc;
	  var doNotPerformExponentialArgRed, argRedTarget, myVariableFormat, myProblemdef, myParametrization;
	  var suffix, origDefDom, resArgRed;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default,
				       .tableIndexWidth = default } } : {

				       /* Test if we may perform this type of argument
				          reduction
				       */
				       doNotPerformExponentialArgRed = false;
				       match (parametrization) with
				             { .doNotPerformExponentialArgRed = true } : { doNotPerformExponentialArgRed = true; }
					     default : { };

				       if (!doNotPerformExponentialArgRed) then {
				           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
					      polynomial degree
				           */
				           needArgumentReduction = true;
				           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                                   if (res.okay) then {
   	                                       if (res.sufficientDegree) then needArgumentReduction = false;
				           } else {
				               needArgumentReduction = false;
				           };

				           if (needArgumentReduction) then {
				       	      /* Here, we need to detect if we can use
					         the exponential argument reduction
					         for the given function
					      */

					      res = tryDetectExponentialArgRed(problemdef.func, problemdef.dom, problemdef.target * 1/8);

					      if (res.okay) then {
					         /* Here we can use the argument reduction for (res.exponentialBase)^x = res.exponentialFunc

					            We start by computing the range of the reduced argument.

						    We have

						    base^x = 2^k * a^(x - k * log(2)/log(base))

						    where k is computed as

						    k = 2^(-w) * nearestint(x * log2(base) * 2^w)

						    where w is the table index width.

						    Hence the reduced argument z = x - k * log(2)/log(base)
						    varies in the domain

						    myDom = [ -2^(-w-1) * log(2)/log(base) ; 2^(-w-1) * log(2)/log(base) ]
					         */
					         base = res.exponentialBase;
					         reducedFunc = res.exponentialFunc;
		                                 write("Detected possible argument reduction as base^x, where base is approximately: ", round(base,24,RN), "\n");
					         myTableWidth = parametrization.tableIndexWidth;
					         if (myTableWidth < 0) then myTableWidth = 0;

					         myDom = [ -2^(-myTableWidth-1) * log(2)/log(base);
					                    2^(-myTableWidth-1) * log(2)/log(base)];

					         write("The reduced argument domain is ", myDom, "\n");

				                 /* Now we have to check if the "argument reduction"
					            actually reduces the size of the argument range.
						    If not, base is too small for our table size
						    and we'd better apply some other technique.
				                 */
					         if (sup(myDom) - inf(myDom) < sup(problemdef.dom) - inf(problemdef.dom)) then {
					     	    /* Now we can try to implement our reduced function.
						       We have to add a marker to the parametrization
						       in order not to re-perform an argument reduction
						       of the same type.

						       To do so, we have to determine the precision
						       needed for the reduced argument.

						       It is pretty easy to show that the amplified
                                                       forward error of the argument reduction eps2
						       can be expressed as

						       eps2 = base^(eps1 * z) - 1

						       where z is the reduced argument and eps1 is
						       the relative error on the reduced argument.
						       In order to keep eps2 at 1/8 * target, eps1
						       must hence be bounded by

						       abs(eps1) <= min( abs(log(1 - 1/8 * target) / log(base^inf(myDom))),
						                         abs(log(1 - 1/8 * target) / log(base^sup(myDom))),
						                         abs(log(1 + 1/8 * target) / log(base^inf(myDom))),
						                         abs(log(1 + 1/8 * target) / log(base^sup(myDom))) )
						    */
						    argRedTarget = min( abs(log(1 - 1/8 * (problemdef.target)) / log(base^inf(myDom))),
						                        abs(log(1 - 1/8 * (problemdef.target)) / log(base^sup(myDom))),
						                        abs(log(1 + 1/8 * (problemdef.target)) / log(base^inf(myDom))),
						                        abs(log(1 + 1/8 * (problemdef.target)) / log(base^sup(myDom))) );

					            write("The maximum error allowed for argument reduction is 2^(", round(log2(argRedTarget),12,RN), ")\n");
						    if (argRedTarget < 1b-102) then myVariableFormat = TD
						    else if (argRedTarget < 1b-51) then myVariableFormat = DD
						    else myVariableFormat = D;
						    if (problemdef.variableFormat == TD) then myVariableFormat = TD
						    else if (problemdef.variableFormat == DD) then myVariableFormat = DD;
						    write("This means the reduced argument will be represented on a ", myVariableFormat, "\n");

						    myProblemdef.func = reducedFunc;
						    myProblemdef.dom = myDom;
						    myProblemdef.target = 1/8 * (problemdef.target);
						    myProblemdef.variableFormat = myVariableFormat;
						    suffix = "_exp_arg_red";
					            origDefDom = problemdef.dom;
					            match (problemdef) with { .definitionDomain = default } : {
					                                         if (origDefDom in problemdef.definitionDomain) then {
                                                                                    origDefDom = problemdef.definitionDomain;
                                                                                 }; }
                                                                            default : {};
					            myProblemdef.definitionDomain = origDefDom;
					            myParametrization = parametrization;
					            myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					            myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					            myParametrization.functionBasename = parametrization.functionBasename @ suffix;
						    myParametrization.doNotPerformExponentialArgRed = true;
						    myParametrization.minWidth = (sup(myDom) - inf(myDom)) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
					            myParametrization.argumentReduced = true;

					            res = tryImplementation(myProblemdef, myParametrization);

						    if (res.okay) then {
						       write("Implementation of the approximation on the reduced domain worked, generating argument reduction and tables\n");
						       resArgRed = tryGenerateExponentialArgumentReduction(base, problemdef.dom, parametrization.functionBasename,
						                                                           res.functionname, res.outputformat, myVariableFormat, problemdef.variableFormat,
													   argRedTarget, 1/8 * (problemdef.target), myTableWidth);

						       if (resArgRed.okay) then {
						          write("Argument reduction code correctly generated\n");
						          write(resArgRed.code) >> parametrization.implementationFile;
							  result.okay = true;
	                                                  result.approxerr = res.approxerr;
							  result.implerr = res.implerr;
							  result.outputformat = res.outputformat;
						          result.functionname = parametrization.functionBasename;
						       } else {
                                                          write("No argument reduction code could be generated\n");
						       };
						    };
					         };
					      };
				           };
				         };
				     }
                default : { };

	  return result;
};

procedure dirtyEvaluateImageInner(f,dom) {
	  var fDiff, zeros, z, fmin, fmax, y;
	  var yInt, res;
	  var oldPoints, oldPrec;

	  //"dirtyEvaluateImageInner(", f, ", ", dom, ")";

	  yInt = evaluate(f,dom);

	  if ((inf(yInt) == inf(yInt)) &&
	      (sup(yInt) == sup(yInt)) &&
	      (sup(abs(yInt)) != infty)) then {
	      fDiff = diff(f);
	      oldPoints = points;
	      oldPrec = prec;
	      zeros = (mydirtyfindzeros(fDiff,dom)) :. (sup(dom));
	      points = oldPoints!;
	      prec = oldPrec!;
	      fmin = inf(evaluate(f,inf(dom)));
	      fmax = sup(evaluate(f,inf(dom)));
	      for z in zeros do {
	      	  y = evaluate(f,z);		  
	      	  if (inf(y) < fmin) then fmin = inf(y);
	      	  if (sup(y) > fmax) then fmax = sup(y);
	      };
	      res = [ fmin; fmax ];
          } else {
	      res = yInt;
	  };

	  return res;
};

procedure intervalHull(I,J) {
	  return [ min(inf(I), inf(J)); max(sup(I), sup(J)) ];
};

procedure dirtyEvaluateImage(f,dom) {
	  var res;

	  if ((0 in dom) && (dom != [0])) then {
	       if (inf(dom) <= -1b-1074) then {
	           if (sup(dom) >= 1b-1074) then {
	                   res = intervalHull(intervalHull(
                                                           dirtyEvaluateImageInner(f,[inf(dom);-1b-1074]),
		                                           dirtyEvaluateImageInner(f,[0])),
		                              dirtyEvaluateImageInner(f,[1b-1074;sup(dom)]));
                   } else {
	                   res = intervalHull(dirtyEvaluateImageInner(f,[inf(dom);-1b-1074]),
		                              dirtyEvaluateImageInner(f,[0]));
		   };
	       } else {
	           if (sup(dom) >= 1b-1074) then {
	                   res = intervalHull(dirtyEvaluateImageInner(f,[1b-1074; sup(dom)]),
		                              dirtyEvaluateImageInner(f,[0]));

                   } else {
		     	   res = dirtyEvaluateImageInner(f,[0]);
		   };
	       };
	  } else {
	    res = dirtyEvaluateImageInner(f,dom);
	  };

	  return res;
};



procedure tryDetectExponentialBehaviorArgRed(func, dom, maxReducRatio) {
	  var result, base, a, b, c, d, ratio, oldPrec, testfunc;
	  var yOrig, yReduc, widthOrig, withReduc, reducRatio;
	  var testfuncjustone;

	  result = { .okay = false };

	  /* We have to detect if func behaves in dom
	     like

	     base^x for some unknown base

	     We say that func behaves like base^x
	     if

	     base^x = func * (1 + eps) with abs(eps) <= target.

	     We start by computing a possible base
	     as

	     base = exp((log(f(c+d)/f(c))/d))

	     with

	       - d = b - a                  if b - a < 5
	         c = a

	       - d = 5                      otherwise
                 c = max(a, (a+b)/2 - 2.5)

             where dom = [a;b]

	     We can stop trying if f(c+d)/f(c) is
	     negative.
	  */
	  a = inf(dom);
	  b = sup(dom);
	  if ((0 in dom) && (max(-a,b) > 5))then {
	     if (-a > b) then {
	     	c = -5;
		d = 5;
	     } else {
	        c = 0;
		d = 5;
	     };
	  } else {
	  	  if (b - a < 5) then {
	  	     d = b - a;
		     c = a;
	  	  } else {
	     	     d = 5;
	             c = max(a, (a + b)/2 - 2.5);
	          };
	  };
	  ratio = func(c + d) / func(c);

	  if (~ratio > 0) then {
	     /* Here, f(c + d) / f(c) is positive

	        So we can compute a presumed base
		as

		base = exp(log(ratio)/d)

		where ratio = f(c + d) / f(c)

		We need to perform this evaluation
		with an accuracy of at least the
		double of the prevailing precision
		as the rest of the argument reduction
		code must receive a pretty accurate
		base.

	     */
	     oldPrec = prec;
	     prec = max(2 * prec, ceil(-log2(abs(target))) * 3)!;
	     base := exp(log(ratio) / d);
	     prec = oldPrec!;

	     /* Now check if dividing the given function by
	        base^x reduces the output domain for the factor g(x):

		f(x) = base^x * g(x).
             */
 	     testfunc = simplifysafe(func/(base^x));
	     yOrig = dirtyEvaluateImage(func,dom);
	     yReduc = dirtyEvaluateImage(testfunc,dom);
	     widthOrig = sup(yOrig) - inf(yOrig);
	     widthReduc = sup(yReduc) - inf(yReduc);
	     reducRatio = widthReduc / widthOrig;

	     if (reducRatio <= maxReducRatio) then {
	     	/* Now check if the divided function is not 
		   just 1 or something really close. 
		   If this were the case, we do not 
		   really have an argument reduction 
		   as we can always multiply by 1 without
		   any change in the problem set.
		*/
		testfuncjustone = false; 
		if (sup(abs(yReduc - 1)) <= 2^(-(prec/2))) then {
		   testfuncjustone = true;
		};
		
		if (!testfuncjustone) then {
	     	    result.okay = true;
		    result.g = base^x;
		    result.h = testfunc;
		    result.ratio = reducRatio;
		};
	     };
	  };
	  return result;
};

procedure tryDetectLogarithmicBehaviorArgRed(func, dom, maxReducRatio) {
	  var result, testfunc;
	  var yOrig, yReduc, widthOrig, withReduc, reducRatio;
	  var testfuncjustone;

	  result = { .okay = false };

	  /* Dividing by a logarithm is only possible if the
	     domain only contains (strictly) positive numbers.
	  */
	  if (inf(dom) > 0) then {	  

	     /* Just check if dividing the given function by
	        log(x) reduces the output domain for the factor g(x):

		f(x) = log2(x) * g(x).
             */
 	     testfunc = simplifysafe(func/log2(x));
	     yOrig = dirtyEvaluateImage(func,dom);
	     yReduc = dirtyEvaluateImage(testfunc,dom);
	     widthOrig = sup(yOrig) - inf(yOrig);
	     widthReduc = sup(yReduc) - inf(yReduc);
	     reducRatio = widthReduc / widthOrig;

	     if ((reducRatio == reducRatio) && (abs(reducRatio) != infty) && (reducRatio <= maxReducRatio)) then {
	     	/* Now check if the divided function is not 
		   just 1 or something really close. 
		   If this were the case, we do not 
		   really have an argument reduction 
		   as we can always multiply by 1 without
		   any change in the problem set.
		*/
		testfuncjustone = false; 
		if (sup(abs(yReduc - 1)) <= 2^(-(prec/2))) then {
		   testfuncjustone = true;
		};
		
		if (!testfuncjustone) then {
	     	    result.okay = true;
		    result.g = log2(x);
		    result.h = testfunc;
		    result.ratio = reducRatio;
		};
	     };
	  };
	  return result;
};

procedure tryDetectPoweringBehaviorArgRed(func, dom, maxReducRatio) {
	  var result, a, b, c, sign, testfunc;
	  var yOrig, yReduc, widthOrig, withReduc, reducRatio;
	  var testfuncjustone;
	  var yReducA, yReducB;

	  result = { .okay = false };

	  /* We have to detect if func behaves in dom
	     like

	     x^c for some constant c

	     We start by computing a possible constant c
	     as

	     c = log(abs(f(b)/f(a)))/log(abs(b/a))

	     where a, b are chosen as follows:

	     * if sup(dom) == 0, a = 2/3 * inf(dom), b = 1/3 * inf(dom)
	     * otherwise:
	          - if inf(dom) == 0, a = 1/3 * sup(dom), b = 2/3 * sup(dom)
		  - otherwise:
	               + if inf(dom) != -sup(dom), a = inf(dom), b = sup(dom)
	               + otherwise: a = inf(dom)/2, b = sup(dom)

	  */
	  if (sup(dom) == 0) then {
	     a = 2/3 * inf(dom);
	     b = 1/3 * inf(dom);
	  } else {
	     if (inf(dom) == 0) then {
	     	a = 1/3 * sup(dom);
		b = 2/3 * sup(dom);
	     } else {
	        if (inf(dom) != -sup(dom)) then {
		  a = inf(dom);
		  b = sup(dom);
		} else {
		  a = inf(dom)/2;
		  b = sup(dom);
		};
	     };
	  };

	  if ((a != 0) && (~func(a) != 0)) then {
	      oldPrec = prec;
	      prec = max(2 * prec, ceil(-log2(abs(target))) * 4)!;
	      c = log(abs(func(b)/func(a)))/log(abs(b/a));
	      if ((~abs(c)) - 1b-1000 < 0) then {
	      	 c = 0;
	      } else {
	         c := c;
	      };
	      c = round(c,floor(prec/2),RN);
	      prec = oldPrec!;

	      if ((c == c) && (abs(c) != infty) && (c > 0) && (c != 2) && (c != 1)) then {
	         /* Now we have to check if sign * x^c effectively approximates func with

		    We still have to determine sign: we just take the sign of func(a) * a.

	         */

		 if ((~func(a)) * a < 0) then sign = -1 else sign = 1;
	         testfunc = simplifysafe(func/(sign * x^c));

		 yOrig = dirtyEvaluateImage(func,dom);
		 if ((0 in dom) && (func(0) == 0)) then {
		      if (inf(dom) == 0) then {
		      	 yReduc = dirtyEvaluateImage(testfunc,[1b-1075; sup(dom)]);
		      } else {
		      	if (sup(dom) == 0) then {
		      	   yReduc = dirtyEvaluateImage(testfunc,[inf(dom); -1b-1075]);
			} else {
		             yReducA = dirtyEvaluateImage(testfunc,[inf(dom);-1b-1075]);
		      	     yReducB = dirtyEvaluateImage(testfunc,[1b-1075;sup(dom)]);
		      	     yReduc = [ min(inf(yReducA), inf(yReducB)) ; max(sup(yReducA), sup(yReducB)) ];
			};
		      };
		 } else {
	              yReduc = dirtyEvaluateImage(testfunc,dom);
		 };

	         widthOrig = sup(yOrig) - inf(yOrig);
	         widthReduc = sup(yReduc) - inf(yReduc);
	         reducRatio = widthReduc / widthOrig;

	         if ((reducRatio == reducRatio) && (abs(reducRatio) != infty) && (reducRatio <= maxReducRatio)) then {
	     	    /* Now check if the divided function is not 
		       just 1 or something really close. 
		       If this were the case, we do not 
		       really have an argument reduction 
		       as we can always multiply by 1 without
		       any change in the problem set.
		    */
		    testfuncjustone = false; 
		    if (sup(abs(yReduc - 1)) <= 2^(-(prec/2))) then {
		       testfuncjustone = true;
		    };
		
		    if (!testfuncjustone) then {
	     	        result.okay = true;
		        result.g = (sign * x^c);
		        result.h = testfunc;
		        result.ratio = reducRatio;
		    };
	         };
	      };
	  };

	  return result;
};

procedure tryDetectParamountBehaviorArgRed(func, dom, maxReducRatio) {
	  var detectors, result, res, detector, okay;
	  var best;

	  detectors = [| 
                         tryDetectExponentialBehaviorArgRed, 
	                 tryDetectLogarithmicBehaviorArgRed,
			 tryDetectPoweringBehaviorArgRed 
		      |];

	  result = { .okay = false };
	  okay = false;	  

	  for detector in detectors do {
		res = detector(func, dom, maxReducRatio);

		if (res.okay) then {
		   if (okay) then {
		     if (abs(res.ratio) < abs(best.ratio)) then {
		     	best = res;
		     };
		   } else {
		     best = res;
		   };
		   okay = true;
		};
	  };

	  if (okay) then {
	     result = best;
	  };

	  return result;
};

procedure tryImplementationThroughArgumentReductionWithParamountBehavior(problemdef, parametrization) {
	  var result, needArgumentReduction, res, myTableWidth, base, myDom, reducedFunc;
	  var argRedTarget, myVariableFormat, myProblemdef, myParametrization;
	  var suffix, origDefDom, resArgRed, doNotPerformParamountBehaviorArgRed, g, h, res2, myOutputFormat;
	  var implementationcode;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default,
				       .tableIndexWidth = default,
				       .minimalReductionRatio = default } } : {

				       /* Test if we may perform this type of argument
				          reduction
				       */
				       doNotPerformParamountBehaviorArgRed = false;
				       match (parametrization) with
					     { .doNotPerformParamountBehaviorArgRed = true } : { doNotPerformParamountBehaviorArgRed = true; }
					     default : { };

				       if (!doNotPerformParamountBehaviorArgRed) then {
				           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
					      polynomial degree
				           */
				           needArgumentReduction = true;
				           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                                   if (res.okay) then {
   	                                       if (res.sufficientDegree) then needArgumentReduction = false;
				           } else {
				               needArgumentReduction = false;
				           };

				           if (needArgumentReduction) then {
				       	      /* Here, we need to detect if we can use
					         the exponential argument reduction
					         for the given function
					      */

					      res = tryDetectParamountBehaviorArgRed(problemdef.func, problemdef.dom, (1 / parametrization.minimalReductionRatio));

					      if (res.okay) then {
					      	 write("Argument reduction detection detected that the function can be split into f = g * h with\n");
						 write("    g(x) = ", res.g, " and\n");
						 write("    h(x) = ", res.h, "\n");
						 g = res.g;
						 h = res.h;

						 write("Trying to implement g\n");
						 myProblemdef.func = g;
						 myProblemdef.dom = problemdef.dom;
						 myProblemdef.target = 1/8 * (problemdef.target);
						 myProblemdef.variableFormat = problemdef.variableFormat;
						 suffix = "_paramount_behav_split_g";
					         origDefDom = problemdef.dom;
					         match (problemdef) with { .definitionDomain = default } : {
					                                      if (origDefDom in problemdef.definitionDomain) then {
                                                                                 origDefDom = problemdef.definitionDomain;
                                                                              }; }
                                                                         default : {};
					         myProblemdef.definitionDomain = origDefDom;
					         myParametrization = parametrization;
					         myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					         myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					         myParametrization.functionBasename = parametrization.functionBasename @ suffix;
						 myParametrization.doNotPerformParamountBehaviorArgRed = true;

					         res = tryImplementation(myProblemdef, myParametrization);

						 if (res.okay) then {
						    write("Subfunction g correctly implemented\n");

						    write("Trying to implement h\n");
						    myProblemdef.func = h;
						    myProblemdef.dom = problemdef.dom;
						    myProblemdef.target = 1/8 * (problemdef.target);
						    myProblemdef.variableFormat = problemdef.variableFormat;
						    suffix = "_paramount_behav_split_h";
					            origDefDom = problemdef.dom;
					            match (problemdef) with { .definitionDomain = default } : {
					                                         if (origDefDom in problemdef.definitionDomain) then {
                                                                                    origDefDom = problemdef.definitionDomain;
                                                                                 }; }
                                                                            default : {};
					            myProblemdef.definitionDomain = origDefDom;
					            myParametrization = parametrization;
					            myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					            myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					            myParametrization.functionBasename = parametrization.functionBasename @ suffix;
						    /* myParametrization.doNotPerformParamountBehaviorArgRed = true; */
						    myParametrization.implementationFile = parametrization.implementationFile @ "_subfunction_h";

					            res2 = tryImplementation(myProblemdef, myParametrization);

						    if (res2.okay) then {
						       write("Subfunction h correctly implemented\n");

						       bashexecute("cat " @ parametrization.implementationFile @ "_subfunction_h >> " @ parametrization.implementationFile);
						       bashexecute("rm " @ parametrization.implementationFile @ "_subfunction_h");
						       myOutputFormat = res.outputformat;
						       match (res2.outputformat) with
						       	     D  : { }
							     DD : { if (myOutputFormat == D) then myOutputFormat = DD; }
							     TD : { myOutputFormat = TD; };
						       implementationcode = "\n";
						       implementationcode = implementationcode @ "void " @ parametrization.functionBasename @ "(";
						       implementationcode = implementationcode @ (match myOutputFormat with
						       			    		       	 	D  : ( "double *res_resh, " )
													DD : ( "double *res_resh, double *res_resm, " )
													TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
						       implementationcode = implementationcode @ (match problemdef.variableFormat with
						       			    		       	 	D  : ( "double xh" )
													DD : ( "double xh, double xm" )
													TD : ( "double xh, double xm, double xl"));
				                       implementationcode = implementationcode @ ") {\n";
						       match (res.outputformat) with
						       	     D  : {
									implementationcode = implementationcode @ "double res_g_resh;\n";
							     	  }
						       	     DD : {
									implementationcode = implementationcode @ "double res_g_resh;\n";
									implementationcode = implementationcode @ "double res_g_resm;\n";
							     	  }
						       	     TD : {
									implementationcode = implementationcode @ "double res_g_resh;\n";
									implementationcode = implementationcode @ "double res_g_resm;\n";
									implementationcode = implementationcode @ "double res_g_resl;\n";
							     	  };
						       match (res2.outputformat) with
						       	     D  : {
									implementationcode = implementationcode @ "double res_h_resh;\n";
							     	  }
						       	     DD : {
									implementationcode = implementationcode @ "double res_h_resh;\n";
									implementationcode = implementationcode @ "double res_h_resm;\n";
							     	  }
						       	     TD : {
									implementationcode = implementationcode @ "double res_h_resh;\n";
									implementationcode = implementationcode @ "double res_h_resm;\n";
									implementationcode = implementationcode @ "double res_h_resl;\n";
							     	  };
						       implementationcode = implementationcode @ "\n";
						       implementationcode = implementationcode @ res.functionname @ "(";
						       implementationcode = implementationcode @ (match (res.outputformat) with
						       			    		       	 	D  : ( "&res_g_resh, " )
													DD : ( "&res_g_resh, &res_g_resm, " )
													TD : ( "&res_g_resh, &res_g_resm, &res_g_resl, "));
						       implementationcode = implementationcode @ (match (problemdef.variableFormat) with
						       			    		       	 	D  : ( "xh" )
													DD : ( "xh, xm" )
													TD : ( "xh, xm, xl" ));
						       implementationcode = implementationcode @ ");\n";
                                                       implementationcode = implementationcode @ res2.functionname @ "(";
						       implementationcode = implementationcode @ (match (res2.outputformat) with
						       			    		       	 	D  : ( "&res_h_resh, " )
													DD : ( "&res_h_resh, &res_h_resm, " )
													TD : ( "&res_h_resh, &res_h_resm, &res_h_resl, "));
						       implementationcode = implementationcode @ (match (problemdef.variableFormat) with
						       			    		       	 	D  : ( "xh" )
													DD : ( "xh, xm" )
													TD : ( "xh, xm, xl" ));
						       implementationcode = implementationcode @ ");\n";
						       match (myOutputFormat) with
						       	     D  : {
									implementationcode = implementationcode @ "*res_resh = res_g_resh * res_h_resh;\n";
                                                                  }
						             DD : {
									match (res.outputformat) with
									      D  : {
											implementationcode = implementationcode @ "Mul122(res_resh,res_resm,res_g_resh,res_h_resh,res_h_resm);\n";
									      	   }
								              DD : {
											match (res2.outputformat) with
											      D  : {
											      	        implementationcode = implementationcode @ "Mul122(res_resh,res_resm,res_h_resh,res_g_resh,res_g_resm);\n";
												   }
										              DD : {
											                implementationcode = implementationcode @ "Mul22(res_resh,res_resm,res_g_resh,res_g_resm,res_h_resh,res_h_resm);\n";
												   };
									      	   };
							          }
							     TD : {
									match (res.outputformat) with
									      D  : {
									      		implementationcode = implementationcode @ "Mul133(res_resh,res_resm,res_resl,res_g_resh,res_h_resh,res_h_resm,res_h_resl);\n";
									      	   }
									      DD : {
									      		implementationcode = implementationcode @ "Mul233(res_resh,res_resm,res_resl,res_g_resh,res_g_resm,res_h_resh,res_h_resm,res_h_resl);\n";
									      	   }
									      TD : {
											match (res2.outputformat) with
											      D  : {
											      	        implementationcode = implementationcode @ "Mul133(res_resh,res_resm,res_resl,res_h_resh,res_g_resh,res_g_resm,res_g_resl);\n";
											      	   }
											      DD : {
											      	        implementationcode = implementationcode @ "Mul233(res_resh,res_resm,res_resl,res_h_resh,res_h_resm,res_g_resh,res_g_resm,res_g_resl);\n";
											      	   }
											      TD : {
											      	        implementationcode = implementationcode @ "Mul33(res_resh,res_resm,res_resl,res_h_resh,res_h_resm,res_h_resl,res_g_resh,res_g_resm,res_g_resl);\n";
											      	   };
									      	   };
							     	  };
						       implementationcode = implementationcode @ "}\n";
						       write(implementationcode) >> parametrization.implementationFile;
						       result = res;
						       result.outputformat = myOutputFormat;
						       result.functionname = parametrization.functionBasename;
						    } else {
						      write("Could not implement subfunction h\n");
						    };
						 } else {
						   write("Could not implement subfunction g\n");
						 };
					      };
				           };
				         };
				     }
                default : { };

	  return result;
};

procedure tryImplementationConstant(problemdef, parametrization) {
	  var result, func, dom, target, ya, yb, yc, myConst, testfunc, oldPrec;
	  var y, zerosUpper, zerosLower, myConstHi, myConstMi, myConstLo, myConstFormat;
	  var implementation, oldDisplay;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default
				     } } : {
				       func = problemdef.func;
				       dom = problemdef.dom;
				       target = problemdef.target;
				       oldPrec = prec;
				       prec = max(prec, -floor(log2(target)) * 4)!;
				       ya = mid(evaluate(func,inf(dom)));
				       yb = mid(evaluate(func,sup(dom)));
				       yc = mid(evaluate(func,mid(dom)));
				       myConst := (ya + yb + yc) / 3;
				       prec = oldPrec!;
				       if ((abs(ya - yb) <= abs(ya * 1/4 * target)) &&
				       	   (abs(ya - yc) <= abs(ya * 1/4 * target)) &&
					   (abs(yb - yc) <= abs(yb * 1/4 * target))) then {
					  testfunc = simplifysafe((myConst/func) - 1);
          	                          y = evaluate(testfunc, [mid(dom)]);
	                                  if (y in [-1/4 * target, 1/4 * target]) then {
	  	                             zerosUpper = mydirtyfindzeros(testfunc + 1/4 * target, dom);
	  	                             zerosLower = mydirtyfindzeros(testfunc - 1/4 * target, dom);

		                             if ((zerosUpper == [||]) && (zerosLower == [||])) then {
		  			     	write("Trying to replace the given function by the constant ", myConst, "\n");
						myConstHi = simplifysafe(D(myConst));
						myConstMi = simplifysafe(D(myConst - myConstHi));
						myConstLo = simplifysafe(D(myConst - (myConstHi + myConstMi)));
						if (abs(1/4 * target) < 1b-107) then {
						   myConstFormat = TD;
						   if (myConstLo == 0) then {
						      myConstFormat = DD;
						      if (myConstMi == 0) then {
						      	 myConstFormat = D;
						      };
						   };
						} else {
						  if (abs(1/4 * target) < 1b-53) then {
						    myConstFormat = DD;
						    if (myConstMi == 0) then {
						       myConstFormat = D;
						    };
						  } else {
						    myConstFormat = D;
						  };
						};

						implementation = "\n";
						oldDisplay = display;
						display = decimal!;
						match myConstFormat with
						      D  : {
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_hi " @ myConstHi @ "\n";
						           }
						      DD : {
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_hi " @ myConstHi @ "\n";
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_mi " @ myConstMi @ "\n";
						           }
						      TD : {
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_hi " @ myConstHi @ "\n";
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_mi " @ myConstMi @ "\n";
								implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_lo " @ myConstLo @ "\n";
						           };
						implementation = implementation @ "\n";
						display = oldDisplay!;
						implementation = implementation @ "void " @ parametrization.functionBasename @ "(";
						match myConstFormat with
						      D  : {
						      	     implementation = implementation @ "double *res_resh, ";
							   }
						      DD : {
						      	     implementation = implementation @ "double *res_resh, double *res_resm, ";
							   }
						      TD : {
						      	     implementation = implementation @ "double *res_resh, double *res_resm, double *res_resl, ";
							   };
						match problemdef.variableFormat with
						      D  : {
							     implementation = implementation @ "double xh";
							   }
						      DD : {
							     implementation = implementation @ "double xh, double xm";
							   }
						      TD : {
							     implementation = implementation @ "double xh, double xm, double xl";
							   };
					        implementation = implementation @ ") {\n";
						match myConstFormat with
						      D  : {
						      	     implementation = implementation @ "*res_resh = " @ parametrization.functionBasename @ "_const_hi;\n";
							   }
						      DD : {
						      	     implementation = implementation @ "*res_resh = " @ parametrization.functionBasename @ "_const_hi;\n";
						      	     implementation = implementation @ "*res_resm = " @ parametrization.functionBasename @ "_const_mi;\n";
							   }
						      TD : {
						      	     implementation = implementation @ "*res_resh = " @ parametrization.functionBasename @ "_const_hi;\n";
						      	     implementation = implementation @ "*res_resm = " @ parametrization.functionBasename @ "_const_mi;\n";
						      	     implementation = implementation @ "*res_resl = " @ parametrization.functionBasename @ "_const_lo;\n";
							   };
					        implementation = implementation @ "}\n\n";
						write(implementation) > parametrization.implementationFile;
						result.okay = true;
						myFinalConst = match myConstFormat with
						 	       	     D  : (myConstHi)
								     DD : (myConstHi + myConstMi)
								     TD : (myConstHi + myConstMi + myConstLo);
						result.approxerr = mydirtyinfnorm(myFinalConst/func - 1,dom);
						result.implerr = 0;
         					result.outputformat = myConstFormat;
          					result.functionname = parametrization.functionBasename;
				             };
				          };
				       };
				     }
                default : { };

	  return result;
};

procedure computeAmplification(func,dom,maxeps) {
	  var fp, fs, condf, theta, res;

	  fp = diff(func);
	  fs = diff(fp);
	  cond = simplifysafe(x * (fp/func));
	  theta = simplifysafe((x^2)/func);

	  res = dirtyEvaluateImage(cond,dom) +
	        [-abs(maxeps);abs(maxeps)] * dirtyEvaluateImage(theta,dom) * dirtyEvaluateImage(fs,[inf(dom) * (1 - abs(maxeps));sup(dom) * (1 + abs(maxeps))]);

          // "func = ", func, ", dom = ", dom, ", maxeps = ", maxeps, ", alpha = ", sup(abs(res));

	  return sup(abs(res));
};

/* Computes the maximum error res in the argument X = x * (1 + res) of func
   such that func(X) = func(x) * (1 + eps) with abs(eps) <= maxeps.

   This function works only if func(x) = exp(x).

*/
procedure computeNeededAccuracyOfArgumentSpecialCaseExponential(func, dom, maxeps) {
	  var res, subdoms, d, domcut, subdomsPrime, reseps, teps;

	  res = { .okay = false };

	  if (func == exp(x)) then {
	     subdoms = [| dom |];
	     domcut = true;
	     while (domcut) do {
	     	   domcut = false;
		   subdomsPrime = [||];
		   for d in subdoms do {
		       if (0 in d) then {
		       	  subdomsPrime = [inf(d); 0] .: [0; sup(d)] .: subdomsPrime;
			  domcut = true;
		       } else {
		       	  if (sup(d) > 1) then {
			     if (inf(d) > 1) then {
			     	subdomsPrime = d .: subdomsPrime;
			     } else {
			        subdomsPrime = [inf(d); 1] .: [1; sup(d)] .: subdomsPrime;
			     };
			  } else {
                             if (inf(d) < -1) then {
			       if (sup(d) < -1) then {
                                 subdomsPrime = d .: subdomsPrime;
			       } else {
                                 subdomsPrime = [inf(d); -1] .: [-1; sup(d)] .: subdomsPrime;
			       };
			     } else {
			       subdomsPrime = d .: subdomsPrime;
			     };
			  };
		       };
		   };
		   subdoms = subdomsPrime;
	     };
	     

	     reseps = 1;
	     for d in subdoms do {
	     	 if (mid(d) > 0) then {
		    if (sup(d) > 0) then {
		      teps = min(abs(log1p(-maxeps)/sup(d)), abs(log1p(maxeps)/sup(d)));
		    } else {
		      teps = 1;
		    };
		 } else {
		    if (inf(d) < 0) then {
		      teps = min(abs(log1p(-maxeps)/inf(d)), abs(log1p(maxeps)/inf(d)));
		    } else {
		      teps = 1;
		    };
		 };
		 if (abs(teps) > 1) then teps = 1;
		 reseps = min(reseps, abs(teps));
	     };
	  
	     res = { .okay = true, .res = reseps };
	  };

	  return res;
};

/* Computes the maximum error res in the argument X = x * (1 + res) of func
   such that func(X) = func(x) * (1 + eps) with abs(eps) <= maxeps.

   This function works only if func(x) = a^x, with a a positive real.

*/
procedure computeNeededAccuracyOfArgumentSpecialCaseGeneralExponential(func, dom, maxeps) {
	  var res;

	  res = { .okay = false };

	  match (func) with 
	       a^x     : { 
                             if (a > 0) then {
	                        res = computeNeededAccuracyOfArgumentSpecialCaseExponential(exp(x), dom * log(a), maxeps);
                             };
	                 }
               default : {
	                 };
	  
	  return res;
};

/* Computes the maximum error res in the argument X = x * (1 + res) of func
   such that func(X) = func(x) * (1 + eps) with abs(eps) <= maxeps.

   This function works on special cases only.
*/
procedure computeNeededAccuracyOfArgumentSpecialCases(func, dom, maxeps) {
	  var res, r, found, cNAOASC;
	  var computeNeededAccuracyOfArgumentSpecialCasesList;

	  computeNeededAccuracyOfArgumentSpecialCasesList = [|
                computeNeededAccuracyOfArgumentSpecialCaseExponential,
                computeNeededAccuracyOfArgumentSpecialCaseGeneralExponential
	  |];

	  res = { .okay = false };

	  while ((!res.okay) && (computeNeededAccuracyOfArgumentSpecialCasesList != [||])) do {
	  	cNAOASC = head(computeNeededAccuracyOfArgumentSpecialCasesList);
		res = cNAOASC(func, dom, maxeps);
	  	computeNeededAccuracyOfArgumentSpecialCasesList = tail(computeNeededAccuracyOfArgumentSpecialCasesList);
	  };

	  return res;
};

/* Computes the maximum error res in the argument X = x * (1 + res) of func
   such that func(X) = func(x) * (1 + eps) with abs(eps) <= maxeps.
*/
procedure computeNeededAccuracyOfArgument(func, dom, maxeps) {
	  var res, okay, alpha, newres;
	  var specialRes;

	  specialRes = computeNeededAccuracyOfArgumentSpecialCases(func, dom, maxeps);

	  if (specialRes.okay) then {
	     res = specialRes.res;
	  } else {
	  
	      res = 1b-1;
	      okay = false;

	      while (!okay) do {
	  	    alpha = abs(computeAmplification(func, dom, res));
		    newres = abs(maxeps) * 1/alpha;
		    if (newres > 1b-1) then newres = 1b-1;
		    if ((newres >= 1/2 * res) || (newres == 0)) then {
		      if (newres == 0) then res = 1b-165;
		      okay = true;
		    } else {
		      res = newres;
		    };
	      };

	      if (res > 0) then {
	  	      okay = false;
	  	      while (!okay) do {
	  	  	    alpha = abs(computeAmplification(func, dom, res));
			    if (alpha * res > abs(maxeps)) then {
		   	       okay = true;
			    } else {
		   	       res = 2 * res;
		   	       if (res > 1) then okay = true;
			    };
	  	      };
	  	      res = 1/2 * res;
              };

	      alpha = abs(computeAmplification(func, dom, res));
	      if (alpha * res > abs(maxeps)) then {
	         res = 0;
	      };

	  };

	  return res;
};

procedure computeNeededAccuracyOfArgumentTrisect(func, dom, maxeps, minWidth) {
	  var res, w, a, b;

	  res = computeNeededAccuracyOfArgument(func, dom, maxeps);
	   
	  a = inf(dom);
	  b = sup(dom);
	  w = b - a;	  

	  if ((res == 0) && (w > minWidth)) then {
	      
	      res = min( computeNeededAccuracyOfArgumentTrisect(func, [a; a + 1/3 * w], maxeps, minWidth),
	                 computeNeededAccuracyOfArgumentTrisect(func, [a + 1/3 * w; a + 2/3 * w], maxeps, minWidth),
			 computeNeededAccuracyOfArgumentTrisect(func, [a + 2/3 * w; b], maxeps, minWidth));

	  }; 

	  return res;
};

procedure computeNeededAccuracyOfArgumentWorkHard(func, dom, maxeps) {
	  var res;

	  res = computeNeededAccuracyOfArgumentTrisect(func, dom, maxeps, (sup(dom) - inf(dom)) / 2187);
	  
	  return res;
};

procedure tryImplementationThroughSquaring(problemdef, parametrization) {
	  var result, splitPoints, needToDetectSymmetry, res;
	  var g, func, myDom, epsRed, redArgFormat, myProblemdef, myParametrization;
	  var variableDeclarations, reductionCode, implementationCode;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default } } : {

				       /* Start with a test if zero is actually inside the domain */
				       if (sup(problemdef.dom) * inf(problemdef.dom) < 0) then {

				       /* Continue with a test if the domain actually needs
                                          to be split in order to stay below the maximum
					  polynomial degree
				        */
				       needToDetectSymmetry = true;
				       res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                               if (res.okay) then {
   	                                   if (res.sufficientDegree) then needToDetectSymmetry = false;
				       } else {
				           needToDetectSymmetry = false;
				       };

				       if (needToDetectSymmetry) then {

				            /* Try to detect a symmetry of func around 0 */
					    res = tryDetectSymmetry(problemdef.func, problemdef.dom, problemdef.target * 1/8);

					    if (res.okay) then {
					       /* If we detected a symmetry, check if it
					          is an even symmetry
					       */
					       if (res.evenSymmetry) then {
					       	  /* Here, we have detected an even symmetry

						     We continue by computing the amplification
						     alpha of a reduction error eps by the function

						     g(x) = f(sqrt(x))

						     This indicates us the following:

						     g(x^2 * (1 + eps)) =
						       = g(x^2) * (1 + alpha * eps)
						       = f(sqrt(x^2)) * (1 + alpha * eps)
						       = f(x) * (1 + alpha * eps)

						  */
						  func = problemdef.func;
						  g = simplifysafe(func(sqrt(x)));
						  myDom = [0;(max(inf(problemdef.dom),sup(problemdef.dom)))^2];
						  alpha = computeAmplification(g,myDom,1b-53);
						  write("The amplification factor of the even function is approximately ", round(alpha,12,RN), " = 2^(", round(log2(alpha),12,RN),")\n");

						  /* Now determine a bound epsRed on the error of the reduced argument */
						  match (problemdef.variableFormat) with
						  	D  : {
								if (1b-53 * alpha < 1/8 * problemdef.target) then {
								   epsRed = 1b-53;
								   redArgFormat = D;
								} else {
								   epsRed = 0;
								   redArgFormat = DD;
								};
							     }
						  	DD : {
								if (1b-102 * alpha < 1/8 * problemdef.target) then {
								   epsRed = 1b-102;
								   redArgFormat = DD;
								} else {
								   epsRed = 1b-150;
								   redArgFormat = TD;
								};
							     }
						  	TD : {
								epsRed = 1b-150;
								redArgFormat = TD;
							     };

						  /* Now check if we can do the target error with that argument
						     reduction
						  */
						  if (epsRed * alpha < 1/8 * problemdef.target) then {
						     write("Trying to implement the function with a squaring of the argument on the first place\n");
						     write("The \"reduced\" argument will be represented on a ", redArgFormat, "\n");
						     write("The reduced function is ", g, "\n");
						     write("It will be implemented on ", myDom, "\n");

						     myProblemdef.func = g;
						     myProblemdef.dom = myDom;
						     myProblemdef.target = 1/8 * (problemdef.target);
						     myProblemdef.variableFormat = redArgFormat;
						     suffix = "_squaring";
					             myProblemdef.definitionDomain = myDom;
					             myParametrization = parametrization;
					             myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					             myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					             myParametrization.functionBasename = parametrization.functionBasename @ suffix;
						     myParametrization.minWidth = (sup(myDom) - inf(myDom)) * 1/2;

						     res = tryImplementation(myProblemdef, myParametrization);

						     if (res.okay) then {
						       write("The subfunction has been correctly implemented\n");

						       /* Now generate the reduction code */
						       variableDeclarations = "\n";
						       reductionCode = "\n";

						       match (redArgFormat) with
						       	     D  : {
									variableDeclarations = variableDeclarations @ "double zh;\n";
								  }
						       	     DD : {
									variableDeclarations = variableDeclarations @ "double zh;\n";
									variableDeclarations = variableDeclarations @ "double zm;\n";
								  }
						       	     TD : {
									variableDeclarations = variableDeclarations @ "double zh;\n";
									variableDeclarations = variableDeclarations @ "double zm;\n";
									variableDeclarations = variableDeclarations @ "double zl;\n";
								  };

						       match (redArgFormat) with
						       	     D  : {
									reductionCode = reductionCode @ "zh = xh * xh;\n";
							          }
						       	     DD : {
									match (problemdef.variableFormat) with
									      D  : {
											reductionCode = reductionCode @ "Mul12(&zh,&zm,xh,xh);\n";
									      	   }
									      DD : {
											reductionCode = reductionCode @ "Mul22(&zh,&zm,xh,xm,xh,xm);\n";
									      	   };
							          }
						       	     TD : {
							     	        match (problemdef.variableFormat) with
									      DD : {
											reductionCode = reductionCode @ "Mul23(&zh,&zm,&zl,xh,xm,xh,xm);\n";
									      	   }
									      TD : {
											reductionCode = reductionCode @ "Mul33(&zh,&zm,&zl,xh,xm,xl,xh,xm,xl);\n";
									      	   };

							          };

						       reductionCode = reductionCode @ (res.functionname) @ "(";
						       reductionCode = reductionCode @ (match (res.outputformat) with
						       		       		        D  : ( "res_resh, " )
											DD : ( "res_resh, res_resm, " )
											TD : ( "res_resh, res_resm, res_resl, " ));
						       reductionCode = reductionCode @ (match (redArgFormat) with
						       		       		       	      D  : ( "zh" )
											      DD : ( "zh, zm" )
											      TD : ( "zh, zm, zl" ));
						       reductionCode = reductionCode @ ");\n";

						       implementationCode = "\n";
						       implementationCode = implementationCode @ "void " @ parametrization.functionBasename @ "(";
						       implementationCode = implementationCode @ (match (res.outputformat) with
						       			    		       	 	D  : ( "double *res_resh, " )
													DD : ( "double *res_resh, double *res_resm, " )
													TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
						       implementationCode = implementationCode @ (match (problemdef.variableFormat) with
						       			    		       	 	D  : ( "double xh" )
													DD : ( "double xh, double xm" )
													TD : ( "double xh, double xm, double xl" ));
						       implementationCode = implementationCode @ ") {\n";
						       implementationCode = implementationCode @ variableDeclarations @ "\n" @ reductionCode @ "\n}\n";

						       write(implementationCode) >> parametrization.implementationFile;
						       result.approxerr = res.approxerr;
						       result.implerr = (1 + abs(res.implerr)) * (1 + abs(epsRed * alpha)) * (1 + abs(1/8 * problemdef.target)) - 1;
         					       result.outputformat = res.outputformat;
          					       result.functionname = parametrization.functionBasename;
						       result.okay = true;
						     } else {
						       write("Could not implement the subfunction\n");
						     };
						  };
					       };
					    };
				       };
				       };
				     }
                default : { };

	  return result;
};

procedure tryDetectLogarithmArgRed(func, dom, target) {
	  var result, base, a, b, c, d, ratio, oldPrec, testfunc;
	  var y, zerosUpper, zerosLower;

	  result = { .okay = false };

	  /* We have to detect if func behaves in dom
	     like

	     log(x)/log(base)

	     We say that func behaves like log(x)/log(base)
	     if

	     log(x)/log(base) = func * (1 + eps) with abs(eps) <= target.

	     We start by computing a possible base
	     as

	     base = exp()

             where dom = [a;b]

	     We can stop trying if the interval contains zero
	     or any negative number.

	  */
	  a = inf(dom);
	  b = sup(dom);
	  if (a > 0) then {
   	      oldPrec = prec;
	      prec = max(2 * prec, ceil(-log2(abs(target))) * 4)!;
	      base := exp((log(b) - log(a))/(func(b) - func(a)));
	      prec = oldPrec!;

	      /* Now we have to check if log(x)/log(base) effectively approximates func with
	         an accuracy of target
	      */
	      testfunc = simplifysafe((log(x)/log(base))/func - 1);
	      y = evaluate(testfunc, mid(dom));
	      if (y in [-target, target]) then {
	     	  zerosUpper = mydirtyfindzeros(testfunc + target, dom);
	  	  zerosLower = mydirtyfindzeros(testfunc - target, dom);

		  if ((zerosUpper == [||]) && (zerosLower == [||])) then {
		      if (base != 1) then {
		      	              result.okay = true;
		      		      result.logarithmicFunc = simplifysafe(log(x)/log(base));
				      result.logarithmBase = base;
		      };
	          };
              };
	  };
	  return result;
};

procedure tryImplementationThroughArgumentReductionLogarithm(problemdef, parametrization) {
	  var result, needArgumentReduction, res, base, func, w, minM, maxM, meanM, r;
	  var doNotPerformLogarithmArgRed, reciprocalTable, oldDisplay, logTableHi, logTableMi, logTableLo;
	  var minZ, maxZ, logR, logRHi, logRMi, logRLo, reducedDom, alpha, g, minAbsLogM;
	  var reductionMultiplicationError, multiplicationOnDouble, reductionErrBound;
	  var reducedArgumentFormat, poundDefines, variableDeclarations, reductionCode, reconstructionCode;
	  var outputFormat, rcprLog2, rcprLog2Hi, rcprLog2Mi, rcprLog2Lo, implementationCode;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default,
				       .tableIndexWidth = default } } : {

				       /* Test if we may perform this type of argument
				          reduction
				       */
				       doNotPerformLogarithmArgRed = false;
				       match (parametrization) with
				             { .doNotPerformLogarithmArgRed = true } : { doNotPerformLogarithmArgRed = true; }
					     default : { };

				       /* Check also if the table index width is large enough for the
				          argument reduction used for logarithms
				       */
				       if ((!doNotPerformLogarithmArgRed) && (parametrization.tableIndexWidth > 2)) then {
				           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
					      polynomial degree
				           */
				           needArgumentReduction = true;
				           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                                   if (res.okay) then {
   	                                       if (res.sufficientDegree) then needArgumentReduction = false;
				           } else {
				               needArgumentReduction = false;
				           };

				           if (needArgumentReduction) then {
				       	      /* Here, we need to detect if we can use
					         the logarithm argument reduction
					         for the given function
					      */

					      res = tryDetectLogarithmArgRed(problemdef.func, problemdef.dom, problemdef.target * 1/8);

					      if (res.okay) then {
					      	 write("Detected that the given function can be replaced with a logarithm with a base that approximately is ", round(res.logarithmBase,53,RN), "\n");
						 func = res.logarithmicFunc;
						 base = res.logarithmBase;

						 /* We know that we can implement the given function as

						    func(x) = log2(x)/log2(base) = log2(2^E * m)/log2(base) =
						            = (E + log2(m))/log2(base) =
							    = E * 1/log2(base) + log(m)/log(base) =
							    = E * 1/log2(base) + log(m * r * 1/r)/log(base)
							    = E * 1/log2(base) + (log(m * r) + log(1/r))/log(base)
							    = E * 1/log2(base) + log(1/r)/log(base) + log(m * r - 1 + 1)/log(base)
							    = E * 1/log2(base) + log(1/r)/log(base) + log1p(m * r - 1)/log(base)
							    = E * 1/log2(base) + log(1/r)/log(base) + log1p(z)/log(base)

					            with z = m * r - 1

						    The values r and log(1/r)/log(base) are read in tables, indexed
						    with the first w mantissa bits of m. Here, w is the table width.
						    If the index is above some value (approx. sqrt(2)) the exponent
						    of m gets adjusted so that m finally always stays in
						    1/sqrt < m < sqrt(2).
						    The value r approximates 1/m up to w bits (approximately,
						    the precise value of the error gets computed below).
						    We round the values of r to w+2 bits, which makes
						    error analysis easier.

						    With a loop, we go now over all indices to the table for
						    r and determine:
						      * the value of r
						      * the minimum and maximum value of m for that index
						      * the minimum and maximum z = m * r - 1 for that index
						 */
						 w = parametrization.tableIndexWidth;

						 maxindex.determined = false;
						 maxindex.index = 0;
						 minZ = 5;
						 maxZ = -5;
						 minAbsLogM = 5;
						 reciprocalTable = "static const double " @ (parametrization.functionBasename) @ "_rcpr_tbl[" @ (~(2^w + 1)) @ "] = {\n";
						 logTableHi = "static const double " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_hi[" @ (~(2^w + 1)) @ "] = {\n";
						 logTableMi = "static const double " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_mi[" @ (~(2^w + 1)) @ "] = {\n";
						 logTableLo = "static const double " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_lo[" @ (~(2^w + 1)) @ "] = {\n";
						 oldDisplay = display;
						 display = decimal!;
						 for i from 0 to 2^w do {
						     minM = 1 + (i - 0.5) * 2^(-w);
						     maxM = 1 + (i + 0.5) * 2^(-w);
						     meanM = (minM + maxM) / 2;
						     minM = max(minM, 1);
						     maxM = min(maxM, 2);
						     r = round(~(1/meanM),w+2,RN);
						     if (meanM >= sqrt(2)) then {
						     	rAdjusted = r * 2;
							if (!maxindex.determined) then {
							   maxindex.determined = true;
							   maxindex.index = i;
							};
						     } else {
						       rAdjusted = r;
						     };
						     minZ = min(minZ, minM * r - 1, maxM * r - 1);
						     maxZ = max(maxZ, minM * r - 1, maxM * r - 1);
						     reciprocalTable = reciprocalTable @ "   " @ r;
						     if (i != 2^w) then {
						     	reciprocalTable = reciprocalTable @ ",";
						     };
						     reciprocalTable = reciprocalTable @ "\n";
						     logR = -log(rAdjusted) / log(base);
						     logRHi = D(logR);
						     logRMi = D(logR - logRHi);
						     logRLo = D(logR - (logRHi + logRMi));
						     logTableHi = logTableHi @ "   " @ logRHi;
						     logTableMi = logTableMi @ "   " @ logRMi;
						     logTableLo = logTableLo @ "   " @ logRLo;
						     if (i != 2^w) then {
						     	logTableHi = logTableHi @ ",";
						     	logTableMi = logTableMi @ ",";
						     	logTableLo = logTableLo @ ",";
						     };
						     logTableHi = logTableHi @ "\n";
						     logTableMi = logTableMi @ "\n";
						     logTableLo = logTableLo @ "\n";

						     if (abs(r) != 2^(nearestint(log2(abs(r))))) then {
						     	minAbsLogM = min(minAbsLogM, inf(abs(log([minM;maxM])/log(base))));
						     };
						 };
						 reciprocalTable = reciprocalTable @ "};\n";
						 logTableHi = logTableHi @ "};\n";
						 logTableMi = logTableMi @ "};\n";
						 logTableLo = logTableLo @ "};\n";
					         display = oldDisplay!;
						 reducedDom = [minZ;maxZ];

						 /* Now check if the width of the domain
						    after argument reduction is really
						    smaller than the one of the original
						    domain.
						 */
						 if (sup(reducedDom) - inf(reducedDom) < sup(problemdef.dom) - inf(problemdef.dom)) then {
						    /* Now compute an upper bound on the amplification factor alpha by which a relative
						       error on the reduced argument is amplified by the reduced function
						       log(1 + x)/log(base). This yields the target error on the argument reduction.
						    */
						    g = simplifysafe(log1p(x)/log(base));
						    alpha = computeAmplification(g,reducedDom,1b-53);
						    reductionTargetError = problemdef.target * 1/8 * 1/abs(alpha);

						    /* The argument reduction z = m * r - 1 is subject to cancellation
						       at the substraction of 1, as m * r is approximately 1 due
						       to r ~ 1/m.

						       There are two cases for the multiplication:

						       (i)  The multiplication is always exact as it is performed with
						            a Fast2Mul. So the only error comes from the subtraction
							    or the truncation of the reduced argument to a D, DD or TD.

						       (ii) The multiplication is performed on double precision only.
						            In the case when r is not an integer power of 2, there
							    is some relative multiplication error that gets amplified
							    by the cancellation at the subtraction.

							    We have (for E = 0 -- the other cases are simpler):

							    log(x) = log(2^E * m) = E + log(1/r) + log(m * r - 1 + 1) =
							           = log(1/r) + log(m * r - 1 + 1)

						            and hence

							    log(m * r * (1 + eps) - 1 + 1) = log(m) * (1 + 1/log(m) * log(1 + eps))

							    Here, log(1 + eps) behaves like eps and 1/log(m) like an amplification
							    factor.

						        So, we determine the overall error 1/log(m) * log(1 + eps) for
							abs(eps) <= 1b-53 and abs(1/log(m)) = 1/minAbsLogM.

							If this error is less than 1/8 * problemdef.target, we can perform
							the multiplication on a double, otherwise we have to perform it
							with a Fast2Mul.

						    */
						    reductionMultiplicationError = 1/minAbsLogM * sup(abs(log1p([-1b-53;1b-53])/log(base)));

						    if (reductionMultiplicationError <= problemdef.target * 1/8) then {
						       multiplicationOnDouble = true;
						       reductionErrBound = reductionMultiplicationError;
						       reducedArgumentFormat = D;
						    } else {
						       multiplicationOnDouble = false;
						       if (abs(reductionTargetError) < 1b-102) then {
						       	 reducedArgumentFormat = TD;
						       } else {
						       	 if (abs(reductionTargetError) < 1b-52) then {
							    reducedArgumentFormat = DD;
							    reductionErrBound = 1b-102 * computeAmplification(g,reducedDom,1b-102);
							 } else {
							    reducedArgumentFormat = D;
							    reductionErrBound = 1b-53 * computeAmplification(g,reducedDom,1b-53);
							 };
						       };
						    };
						    if ((!multiplicationOnDouble) && (problemdef.variableFormat == D)) then {
						       reducedArgumentFormat = DD;
						       reductionErrBound = 0;
						    };

						    /* Now generate the code for the argument reduction */
						    poundDefines = "\n";
						    variableDeclarations = "\n";
						    reductionCode = "\n";
						    reconstructionCode = "\n";

						    /* Decompose x = 2^E * m, compute the index to the tables and if the
						       variable format is wider than double precision, compute
						       a scaling to the middle and lower components
						    */
						    variableDeclarations = variableDeclarations @ "db_number argRedCaster;\n";
						    variableDeclarations = variableDeclarations @ "int E;\n";
						    variableDeclarations = variableDeclarations @ "int index;\n";
						    reductionCode = reductionCode @ "argRedCaster.d = xh;\n";
						    if (inf(abs(problemdef.dom)) < 0x0010000000000000) then {
						      reductionCode = reductionCode @ "E = 0;\n";
						      reductionCode = reductionCode @ "if (argRedCaster.l < 0x0010000000000000) {\n";
						      reductionCode = reductionCode @ "argRedCaster.d *= 9007199254740992.0;\n";						     
						      reductionCode = reductionCode @ "E -= 53;\n";
						      reductionCode = reductionCode @ "}\n";
						      reductionCode = reductionCode @ "E += (int) ((argRedCaster.l >> 52) - 1023ll);\n";
						    } else {
						      reductionCode = reductionCode @ "E = (int) ((argRedCaster.l >> 52) - 1023ll);\n";
						    };
						    if (problemdef.variableFormat != D) then {
						       variableDeclarations = variableDeclarations @ "db_number scaleCaster;\n";
						       variableDeclarations = variableDeclarations @ "double scale;\n";
						       if (inf(abs(problemdef.dom)) < 0x0010000000000000) then {
						           reductionCode = reductionCode @ "scaleCaster.l = 1023 - (E >= -1023 ? E : -1023);\n";
						       } else {
						           reductionCode = reductionCode @ "scaleCaster.l = 1023 - E;\n";
                                                       };
						       reductionCode = reductionCode @ "scaleCaster.l <<= 52;\n";
						       reductionCode = reductionCode @ "scale = scaleCaster.d;\n";
						    };
						    reductionCode = reductionCode @ "index = (int) ((argRedCaster.l & 0x000fffffffffffffull) >> (52 - " @ (parametrization.functionBasename) @ "_tablewidth - 1));\n";
						    oldDisplay = display;
						    display = decimal!;
						    poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_tablewidth " @ w @ "\n";
						    poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_maxindex " @ (maxindex.index) @ "\n";
						    display = oldDisplay!;
						    reductionCode = reductionCode @ "index = (index + 1) >> 1;\n";
						    reductionCode = reductionCode @ "if (index >= " @ (parametrization.functionBasename) @ "_maxindex) E++;\n";
						    variableDeclarations = variableDeclarations @ "double ed;\n";
						    reductionCode = reductionCode @ "ed = (double) E;\n";
						    reductionCode = reductionCode @ "argRedCaster.l = (argRedCaster.l & 0x800fffffffffffffull) | 0x3ff0000000000000ull;\n";
						    variableDeclarations = variableDeclarations @ "double m;\n";
						    reductionCode = reductionCode @ "m = argRedCaster.d;\n";

						    /* Read r in reciprocal table */
						    variableDeclarations = variableDeclarations @ "double r;\n";
						    reductionCode = reductionCode @ "r = " @ (parametrization.functionBasename) @ "_rcpr_tbl[index];\n";

						    /* Generate z = m * r - 1 for the different precisions */
						    if (multiplicationOnDouble) then {
						       variableDeclarations = variableDeclarations @ "double zh;\n";
						       match (problemdef.variableFormat) with
						       	     D  : {
						                      reductionCode = reductionCode @ "zh = m * r - 1.0;\n";
							     	  }
						       	     DD : {
						                      reductionCode = reductionCode @ "zh = (m * r - 1.0) + ((scale * xm) * r);\n";
							     	  }
						       	     TD : {
								      variableDeclarations = variableDeclarations @ "double rxmh, rxml, sxm;\n";
                                                                      reductionCode = reductionCode @ "sxm = scale * xm;\n";
								      reductionCode = reductionCode @ "Mul12(&rxmh, &rxml, r, sxm);\n";
								      reductionCode = reductionCode @ "zh = ((m * r - 1.0) + rxmh) + (rxml + scale * xl);\n";
							     	  };
						    } else {
						      match reducedArgumentFormat with
						      	    D  : {
              						              variableDeclarations = variableDeclarations @ "double zh;\n";
								      variableDeclarations = variableDeclarations @ "double mrh, mrl;\n";
								      reductionCode = reductionCode @ "Mul12(&mrh,&mrl,m,r);\n";
								      match (problemdef.variableFormat) with
								      	    D  : {
										     reductionCode = reductionCode @ "zh = (mrh - 1.0) + mrl;\n";
									       	 }
								      	    DD : {
									             variableDeclarations = variableDeclarations @ "double sxm;\n";
										     variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
										     reductionCode = reductionCode @ "zh = (((mrh - 1.0) + mrl) + rxmh) + rxml;\n";
									       	 }
								      	    TD : {
										     variableDeclarations = variableDeclarations @ "double sxm;\n";
										     variableDeclarations = variableDeclarations @ "double sxl;\n";
										     variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
										     variableDeclarations = variableDeclarations @ "double rxlh, rxll;\n";
										     variableDeclarations = variableDeclarations @ "double temph, templ;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "sxl = scale * xl;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxlh,&rxll,r,sxl);\n";
                                                                                     reductionCode = reductionCode @ "Add12Cond(temph,templ,rxml,rxlh);\n";
										     reductionCode = reductionCode @ "zh = ((((mrh - 1.0) + mrl) + rxmh) + temph) + templ;\n";
									       	 };
							       	 }
						      	    DD : {
              						              variableDeclarations = variableDeclarations @ "double zh;\n";
              						              variableDeclarations = variableDeclarations @ "double zm;\n";
								      variableDeclarations = variableDeclarations @ "double mrh, mrl;\n";
								      reductionCode = reductionCode @ "Mul12(&mrh,&mrl,m,r);\n";
								      match (problemdef.variableFormat) with
								      	    D  : {
										     variableDeclarations = variableDeclarations @ "double temp;\n";
									             reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
										     reductionCode = reductionCode @ "Add12(zh,zm,temp,mrl);\n";
									       	 }
								      	    DD : {
										     variableDeclarations = variableDeclarations @ "double sxm;\n";
										     variableDeclarations = variableDeclarations @ "double temp;\n";
										     variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
										     variableDeclarations = variableDeclarations @ "double temp2h, temp2l;\n";
										     variableDeclarations = variableDeclarations @ "double temp3;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
										     reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
										     reductionCode = reductionCode @ "Add12(temp2h,temp2l,temp,mrl);\n";
										     reductionCode = reductionCode @ "temp3 = temp2l + sxm;\n";
										     reductionCode = reductionCode @ "Add12(zh,zm,temp2h,temp3);\n";
									       	 }
								      	    TD : {
										     variableDeclarations = variableDeclarations @ "double sxm;\n";
										     variableDeclarations = variableDeclarations @ "double sxl;\n";
										     variableDeclarations = variableDeclarations @ "double temp;\n";
										     variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
										     variableDeclarations = variableDeclarations @ "double rxlh, rxll;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "sxl = scale * xl;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxlh,&rxll,r,sxm);\n";
										     reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
										     variableDeclarations = variableDeclarations @ "double temp1h, temp1l;\n";
										     variableDeclarations = variableDeclarations @ "double temp2h, temp2l;\n";
										     variableDeclarations = variableDeclarations @ "double temp3h, temp3l;\n";
										     variableDeclarations = variableDeclarations @ "double temp4h, temp4l;\n";
										     variableDeclarations = variableDeclarations @ "double templo;\n";
										     reductionCode = reductionCode @ "Add12(temp1h,temp1l,temp,mrl);\n";
										     reductionCode = reductionCode @ "Add12Cond(temp2h,temp2l,temp1l,rxmh);\n";
										     reductionCode = reductionCode @ "Add12(temp3h,temp3l,temp1h,temp2h);\n";
										     reductionCode = reductionCode @ "Add12Cond(temp4h,temp4l,rxml,rxlh);\n";
										     reductionCode = reductionCode @ "templo = temp3l + (temp2l + (temp4h + (temp4l + rxll)));\n";
										     reductionCode = reductionCode @ "Add12(zh,zm,temp3h,templo);\n";
									       	 };
							       	 }
						      	    TD : {
              						              variableDeclarations = variableDeclarations @ "double zh;\n";
              						              variableDeclarations = variableDeclarations @ "double zm;\n";
								      variableDeclarations = variableDeclarations @ "double zl;\n";
								      variableDeclarations = variableDeclarations @ "double mrh, mrl;\n";
								      reductionCode = reductionCode @ "Mul12(&mrh,&mrl,m,r);\n";
								      match (problemdef.variableFormat) with
								      	    D  : {
										     variableDeclarations = variableDeclarations @ "double temp;\n";
									             reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
										     reductionCode = reductionCode @ "Add12(zh,zm,temp,mrl);\n";
										     reductionCode = reductionCode @ "zl = 0.0;\n";
									       	 }
								      	    DD : {
										     variableDeclarations = variableDeclarations @ "double sxm;\n";
										     variableDeclarations = variableDeclarations @ "double temp;\n";
										     variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
										     variableDeclarations = variableDeclarations @ "double temp2h, temp2m, temp2l;\n";
										     variableDeclarations = variableDeclarations @ "double temp3;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
										     reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
										     reductionCode = reductionCode @ "Renormalize3(&temp2h,&temp2m,&temp2l,temp,mrl,rxmh);\n";
										     reductionCode = reductionCode @ "temp3 = temp2l + rxml;\n";
										     reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,temp2h,temp2m,temp3);\n";
									       	 }
								      	    TD : {
										     variableDeclarations = variableDeclarations @ "double sxm;\n";
										     variableDeclarations = variableDeclarations @ "double sxl;\n";
										     variableDeclarations = variableDeclarations @ "double temp;\n";
										     variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
										     variableDeclarations = variableDeclarations @ "double rxlh, rxll;\n";
										     variableDeclarations = variableDeclarations @ "double temp1h, temp1l;\n";
										     variableDeclarations = variableDeclarations @ "double temp2h, temp2m, temp2l;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "sxl = scale * xl;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxlh,&rxll,r,sxm);\n";
										     reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
										     reductionCode = reductionCode @ "Add12Cond(temp1h,temp1l,rxml,rxlh);\n";
										     reductionCode = reductionCode @ "Renormalize3(&temp2h,&temp2m,&temp2l,temp,mrl,rxmh);\n";
										     reductionCode = reductionCode @ "temp3 = temp2l + (temp1h + (temp1l + rxll));\n";
										     reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,temp2h,temp2m,temp3);\n";
									       	 };
							       	 };
						    };

						    /* Now produce the code for the reduced function log(1 + z)/log(base) */
						    myProblemdef.func = g;
						    myProblemdef.dom = reducedDom;
						    myProblemdef.target = 1/8 * (problemdef.target);
						    myProblemdef.variableFormat = reducedArgumentFormat;
						    suffix = "_log_arg_red";
					            origDefDom = problemdef.dom - 1;
					            match (problemdef) with { .definitionDomain = default } : {
					                                         if (origDefDom in problemdef.definitionDomain) then {
                                                                                    origDefDom = problemdef.definitionDomain;
                                                                                 }; }
                                                                            default : {};
					            myProblemdef.definitionDomain = origDefDom;
					            myParametrization = parametrization;
					            myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					            myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					            myParametrization.functionBasename = parametrization.functionBasename @ suffix;
						    myParametrization.doNotPerformLogarithmArgRed = true;
						    myParametrization.minWidth = (sup(reducedDom) - inf(reducedDom)) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
					            myParametrization.argumentReduced = true;

					            res = tryImplementation(myProblemdef, myParametrization);

						    if (res.okay) then {
						        /* The implementation of the reduced function has succeeded.
							   Now produce the code for the reconstruction
							*/
						        outputFormat = res.outputformat;
							oldDisplay = display;
							display = decimal!;
							rcprLog2 = 1/log2(base);
							rcprLog2Hi = D(rcprLog2);
							rcprLog2Mi = D(rcprLog2 - rcprLog2Hi);
							rcprLog2Lo = D(rcprLog2 - (rcprLog2Hi + rcprLog2Mi));
							match outputFormat with
							      D  : {
									poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi " @ rcprLog2Hi @ "\n";
									poundDefines = poundDefines @ "\n" @ logTableHi @ "\n";
									variableDeclarations = variableDeclarations @ "double polyHi;\n";
									variableDeclarations = variableDeclarations @ "double tableHi;\n";
									variableDeclarations = variableDeclarations @ "double scaledExpoHi;\n";
									variableDeclarations = variableDeclarations @ "double logMHi;\n";
									reconstructionCode = reconstructionCode @ "tableHi = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_hi[index];\n";
									reconstructionCode = reconstructionCode @ "scaledExpoHi = ed * " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi;\n";
									reconstructionCode = reconstructionCode @ "logMHi = tableHi + polyHi;\n";
									reconstructionCode = reconstructionCode @ "*res_resh = scaledExpoHi + logMHi;\n";
							      	   }
							      DD : {
									poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi " @ rcprLog2Hi @ "\n";
									poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_mi " @ rcprLog2Mi @ "\n";
									poundDefines = poundDefines @ "\n" @ logTableHi @ "\n";
									poundDefines = poundDefines @ "\n" @ logTableMi @ "\n";
									variableDeclarations = variableDeclarations @ "double polyHi;\n";
									variableDeclarations = variableDeclarations @ "double polyMi;\n";
									variableDeclarations = variableDeclarations @ "double tableHi;\n";
									variableDeclarations = variableDeclarations @ "double tableMi;\n";
									variableDeclarations = variableDeclarations @ "double scaledExpoHi;\n";
									variableDeclarations = variableDeclarations @ "double scaledExpoMi;\n";
									variableDeclarations = variableDeclarations @ "double logMHi;\n";
									variableDeclarations = variableDeclarations @ "double logMMi;\n";
									reconstructionCode = reconstructionCode @ "tableHi = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_hi[index];\n";
									reconstructionCode = reconstructionCode @ "tableMi = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_mi[index];\n";
									reconstructionCode = reconstructionCode @ "Mul122(&scaledExpoHi,&scaledExpoMi,ed," @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi," @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_mi);\n";
									reconstructionCode = reconstructionCode @ "Add22(&logMHi,&logMMi,tableHi,tableMi,polyHi,polyMi);\n";
									reconstructionCode = reconstructionCode @ "Add22(res_resh,res_resm,scaledExpoHi,scaledExpoMi,logMHi,logMMi);\n";
							      	   }
							      TD : {
									poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi " @ rcprLog2Hi @ "\n";
									poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_mi " @ rcprLog2Mi @ "\n";
									poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_lo " @ rcprLog2Lo @ "\n";
									poundDefines = poundDefines @ "\n" @ logTableHi @ "\n";
									poundDefines = poundDefines @ "\n" @ logTableMi @ "\n";
									poundDefines = poundDefines @ "\n" @ logTableLo @ "\n";
									variableDeclarations = variableDeclarations @ "double polyHi;\n";
									variableDeclarations = variableDeclarations @ "double polyMi;\n";
									variableDeclarations = variableDeclarations @ "double polyLo;\n";
									variableDeclarations = variableDeclarations @ "double tableHi;\n";
									variableDeclarations = variableDeclarations @ "double tableMi;\n";
									variableDeclarations = variableDeclarations @ "double tableLo;\n";
									variableDeclarations = variableDeclarations @ "double scaledExpoHi;\n";
									variableDeclarations = variableDeclarations @ "double scaledExpoMi;\n";
									variableDeclarations = variableDeclarations @ "double scaledExpoLo;\n";
									variableDeclarations = variableDeclarations @ "double logMHi;\n";
									variableDeclarations = variableDeclarations @ "double logMMi;\n";
									variableDeclarations = variableDeclarations @ "double logMLo;\n";
									reconstructionCode = reconstructionCode @ "tableHi = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_hi[index];\n";
									reconstructionCode = reconstructionCode @ "tableMi = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_mi[index];\n";
									reconstructionCode = reconstructionCode @ "tableLo = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_lo[index];\n";
									reconstructionCode = reconstructionCode @ "Mul133(&scaledExpoHi,&scaledExpoMi,&scaledExpoLo,ed," @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi," @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_mi," @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_lo);\n";
									reconstructionCode = reconstructionCode @ "Add33(&logMHi,&logMMi,&logMLo,tableHi,tableMi,tableLo,polyHi,polyMi,polyLo);\n";
									reconstructionCode = reconstructionCode @ "Add33(res_resh,res_resm,res_resl,scaledExpoHi,scaledExpoMi,scaledExpoLo,logMHi,logMMi,logMLo);\n";
							      	   };
							display = oldDisplay!;

							/* Now emit the code */
							implementationCode = "\n";
							implementationCode = implementationCode @ poundDefines @ "\n" @ reciprocalTable @ "\n";
						        implementationCode = implementationCode @ "void " @ parametrization.functionBasename @ "(";
						        implementationCode = implementationCode @ (match (outputFormat) with
						       	 		    		       	 	 D  : ( "double *res_resh, " )
													 DD : ( "double *res_resh, double *res_resm, " )
													 TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
						        implementationCode = implementationCode @ (match (problemdef.variableFormat) with
						       			    		       	 	 D  : ( "double xh" )
													 DD : ( "double xh, double xm" )
													 TD : ( "double xh, double xm, double xl" ));
						        implementationCode = implementationCode @ ") {\n";
						        implementationCode = implementationCode @ variableDeclarations @ "\n" @ reductionCode @ "\n";
							implementationCode = implementationCode @ (res.functionname) @ "(";
							implementationCode = implementationCode @ (match (outputFormat) with
									     			  	 D  : ( "&polyHi, " )
													 DD : ( "&polyHi, &polyMi, " )
													 TD : ( "&polyHi, &polyMi, &polyLo, "));
							implementationCode = implementationCode @ (match reducedArgumentFormat with
									     			  	 D  : ( "zh" )
													 DD : ( "zh, zm" )
													 TD : ( "zh, zm, zl"));
							implementationCode = implementationCode @ ");\n";
							implementationCode = implementationCode @ "\n" @ reconstructionCode @ "\n";
							implementationCode = implementationCode @ "\n}\n";

						        write(implementationCode) >> parametrization.implementationFile;
						        result.approxerr = res.approxerr;
						        result.implerr = (1 + abs(res.implerr)) * (1 + abs(1/2 * problemdef.target)) - 1;    // TODO
         					        result.outputformat = outputFormat;
          					        result.functionname = parametrization.functionBasename;
						        result.okay = true;
					            } else {
						      write("Could not implement the subfunction ", g, " over ", reducedDom);
						    };
						 };
					      };
				           };
				         };
				     }
                default : { };

	  return result;
};

procedure tryDetectPoweringArgRed(func, dom, target) {
	  var result, a, b, c, sign;
	  var testfunc, y, zerosUpper, zerosLower;

	  result = { .okay = false };

	  /* We have to detect if func behaves in dom
	     like

	     x^c for some constant c

	     We say that func behaves like x^c
	     if

	     x^c = func * (1 + eps) with abs(eps) <= target.

	     We start by computing a possible constant c
	     as

	     c = log(abs(f(b)/f(a)))/log(abs(b/a))

	     where a, b are chosen as follows:

	     * if sup(dom) == 0, a = 2/3 * inf(dom), b = 1/3 * inf(dom)
	     * otherwise:
	          - if inf(dom) == 0, a = 1/3 * sup(dom), b = 2/3 * sup(dom)
		  - otherwise:
	               + if inf(dom) != -sup(dom), a = inf(dom), b = sup(dom)
	               + otherwise: a = inf(dom)/2, b = sup(dom)

	  */
	  if (sup(dom) == 0) then {
	     a = 2/3 * inf(dom);
	     b = 1/3 * inf(dom);
	  } else {
	     if (inf(dom) == 0) then {
	     	a = 1/3 * sup(dom);
		b = 2/3 * sup(dom);
	     } else {
	        if (inf(dom) != -sup(dom)) then {
		  a = inf(dom);
		  b = sup(dom);
		} else {
		  a = inf(dom)/2;
		  b = sup(dom);
		};
	     };
	  };

	  if ((a != 0) && (~func(a) != 0)) then {
	      oldPrec = prec;
	      prec = max(2 * prec, ceil(-log2(abs(target))) * 4)!;
	      c = log(abs(func(b)/func(a)))/log(abs(b/a));
	      if (abs(c) - 1b-1000 < 0) then {
	      	 c = 0;
	      } else {
	         c := c;
	      };
	      c = round(c,floor(prec/2),RN);
	      prec = oldPrec!;

	      if ((c == c) && (abs(c) != infty) && (c > 0) && (c != 2) && (c != 1)) then {
	         /* Now we have to check if sign * x^c effectively approximates func with
	            an accuracy of target

		    We still have to determine sign: we just take the sign of func(a) * a.

	         */

		 if ((~func(a)) * a < 0) then sign = -1 else sign = 1;
	         testfunc = simplifysafe((sign * x^c)/func - 1);

	         y = evaluate(testfunc, mid(dom));
	         if (y in [-target, target]) then {

		    if ((0 in dom) && (func(0) == 0)) then {
		       if (inf(dom) == 0) then {
	  	           zerosUpper = mydirtyfindzeros(testfunc + target, [1b-1075; sup(dom)]);
	  	           zerosLower = mydirtyfindzeros(testfunc - target, [1b-1075; sup(dom)]);
		       } else {
		       	 if (sup(dom) == 0) then {
	  	             zerosUpper = mydirtyfindzeros(testfunc + target, [inf(dom); -1b-1075]);
	  	             zerosLower = mydirtyfindzeros(testfunc - target, [inf(dom); -1b-1075]);
			 } else {
	  	             zerosUpper = mydirtyfindzeros(testfunc + target, [inf(dom); -1b-1075]) @ mydirtyfindzeros(testfunc + target, [1b-1075; sup(dom)]);
	  	             zerosLower = mydirtyfindzeros(testfunc - target, [inf(dom); -1b-1075]) @ mydirtyfindzeros(testfunc - target, [1b-1075; sup(dom)]);
			 };
		       };
		    } else {
	  	        zerosUpper = mydirtyfindzeros(testfunc + target, dom);
	  	        zerosLower = mydirtyfindzeros(testfunc - target, dom);
		    };

		    if ((zerosUpper == [||]) && (zerosLower == [||])) then {
		      	              result.okay = true;
				      result.power = c;
				      result.sign = sign;
				      result.replacefunc = simplifysafe(horner(sign * x^c));
	            };
                 };
	      };
	  };

	  return result;
};

procedure tryImplementationThroughArgumentReductionPowering(problemdef, parametrization) {
	  var result, needArgumentReduction, res, c, recurseProblemdef, sign;
	  var doNotPerformPoweringArgRed;
          var deltaMax, epsMaxExponent, epsMaxScaledLogarithm, epsMaxAddition;
	  var Emin, Emax, Ebitwidth, cBitwidth, canDoETimesCOnDouble, cFormat;
	  var logProblemdef, logParametrization, logSuffix, resLog, logFormat, cStoreFormat;
	  var expProblemdef, expParametrization, expSuffix, resExp;
	  var expVariableformat, expDomain, expFormat, cStorageFormat;
	  var cHi, cMi, cLo, oldDisplay, eTimesCFormat, eTimesCMinusFFormat;
	  var eTimesCAdditionFormat, cTimesLogFormat, expFinalFormat;
	  var preNegate, postNegate, recurseResult, recurseSuffix, recurseParametrization;
	  var handleZero;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default,
				       .tableIndexWidth = default } } : {

				       /* Test if we may perform this type of argument
				          reduction
				       */
				       doNotPerformPoweringArgRed = false;
				       match (parametrization) with
				             { .doNotPerformPoweringArgRed = true } : { doNotPerformPoweringArgRed = true; }
					     default : { };

				       if (!doNotPerformPoweringArgRed) then {
				           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
					      polynomial degree
				           */
				           needArgumentReduction = true;
				           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                                   if (res.okay) then {
   	                                       if (res.sufficientDegree) then needArgumentReduction = false;
				           } else {
				               needArgumentReduction = false;
				           };

				           if (needArgumentReduction) then {
				       	      /* Here, we need to detect if we can use
					         the powering argument reduction
					         for the given function
					      */

					      res = tryDetectPoweringArgRed(problemdef.func, problemdef.dom, problemdef.target * 1/8);

					      if (res.okay) then {
						 c = res.power;
						 sign = res.sign;

						 /* Now check if the replacement function x^c isn't just a polynomial x^k (k == c)
						    that can be implemented with the maximum degree that is currently allowed.

						    Continue with the replacement function only if that condition is not fullfilled.

						 */
						 if (!((nearestint(c) == c) && (1 < c) && (c <= parametrization.maxDegree))) then {
						    /* Now check if the implementation domain contains negative numbers.

						       If this is the case, there are several possibilities:

						       * If c is not an integer, it is a dyadic number and the function
						         is not really defined *and continuous* on negative numbers.
							 In this case, we just fail.

						       * otherwise, do the following:
						         - if there are positive numbers in the domain,
							   simply fail. Functions x^k are symmetical and symmetry
                                                           detection will eventually detect that and call us again
							   on a domain that does not change sign.
                                                         - otherwise we call ourselves on func(-x) and -dom.

						       Otherwise, we can continue and use the replacement function.

						    */

						    if (inf(problemdef.dom) < 0) then {
						       if (c == nearestint(c)) then {
						       	  if (sup(problemdef.dom) <= 0) then {
							     /* All numbers in the implementation domain are non-positive
							        and the function is x^k.
							     */
							     recurseProblemdef = problemdef;
							     recurseProblemdef.func = problemdef.func(-x);
							     recurseProblemdef.dom = -problemdef.dom;
							     match (problemdef) with { .definitionDomain = default } : {
					                                               recurseProblemdef.definitionDomain = -problemdef.definitionDomain;
                                                                                  }
                                                                       default : {};
						             recurseSuffix = "_negate";
							     recurseParametrization = parametrization;
							     recurseParametrization.implementationFile = parametrization.implementationFile;
					       	       	     recurseParametrization.gappaFile = parametrization.gappaFile @ recurseSuffix;
					       	       	     recurseParametrization.gappaOutputFile = parametrization.gappaOutputFile @ recurseSuffix;
					       	       	     recurseParametrization.functionBasename = parametrization.functionBasename @ recurseSuffix;
						             recurseResult = tryImplementationThroughArgumentReductionPowering(recurseProblemdef, recurseParametrization);
							     if (recurseResult.okay) then {
							     	write("void ", parametrization.functionBasename, "(") >> parametrization.implementationFile;
								match (recurseResult.outputformat) with
								      D  : {
							     	               write("double *res_resh, ") >> parametrization.implementationFile;
								      	   }
								      DD : {
							     	               write("double *res_resh, double *res_resm, ") >> parametrization.implementationFile;
								      	   }
								      TD : {
							     	               write("double *res_resh, double *res_resm, double *res_resl, ") >> parametrization.implementationFile;
								      	   };
							        match (problemdef.variableFormat) with
								      D  : {
							     	               write("double xh") >> parametrization.implementationFile;
								      	   }
								      DD : {
							     	               write("double xh, double xm") >> parametrization.implementationFile;
								      	   }
								      TD : {
							     	               write("double xh, double xm, double xl") >> parametrization.implementationFile;
								      	   };
							     	write(")\n{\n",recurseResult.functionname,"(") >> parametrization.implementationFile;
								match (recurseResult.outputformat) with
								      D  : {
							     	               write("res_resh, ") >> parametrization.implementationFile;
								      	   }
								      DD : {
							     	               write("res_resh, res_resm, ") >> parametrization.implementationFile;
								      	   }
								      TD : {
							     	               write("res_resh, res_resm, res_resl, ") >> parametrization.implementationFile;
								      	   };
							        match (problemdef.variableFormat) with
								      D  : {
							     	               write("-xh") >> parametrization.implementationFile;
								      	   }
								      DD : {
							     	               write("-xh, -xm") >> parametrization.implementationFile;
								      	   }
								      TD : {
							     	               write("-xh, -xm, -xl") >> parametrization.implementationFile;
								      	   };
							     	write(");\n}\n") >> parametrization.implementationFile;
								result = recurseResult;
								result.functionname = parametrization.functionBasename;
							     };
							  };
						       };
						    } else {
					      	       write("Detected that the given function ", problemdef.func, " can be replaced with ", res.replacefunc, " on ", problemdef.dom, "\n");

						       /* Determine if we have to negate the argument
						          and/or if we have to negate the result
						       */
						       if (mid(problemdef.dom) < 0) then {
						       	  preNegate = true;
						       } else {
						       	  preNegate = false;
						       };
						       if ((res.replacefunc)(mid(problemdef.dom)) < 0) then {
						       	  postNegate = true;
						       } else {
						       	  postNegate = false;
						       };

						       /* Test if we need to be able to handle zero as an 
						          argument 
						        */
						       handleZero = (0 in problemdef.dom);

						       /* We implement x^c as follows

						       	  x^c = (2^E * m)^c = 2^F * 2^((E * c - F) + c * log2(m))

							  where F = nearestint(E * c)

							  We do NOT care about the possible catastrophic cancellation
							  between (E * c - F) and c * log2(m) as it does not amplify the
							  error after the power of 2:

							  2^(x + delta) = 2^x * 2^delta = 2^x * (1 + (2^delta - 1))

							  So for delta bounded by abs(delta) <= deltaMax where

							  deltaMax = max(-log2(1 - epsMax),log2(1 + epsMax))

							  with epsMax the target error, we get

							  2^(x + delta) = 2^x * (1 + eps) with eps bounded by

							  abs(eps) <= epsMax.

							  Knowing deltaMax we can determine

							  epsMax1 = 1/abs(max(abs(Emax),abs(Emin)) * c) * 1/4 * deltaMax

							  epsMax2 = 1/abs(c) * 1/4 * deltaMax

							  and

							  epsMax3 = 1/abs(max(c,1/2)) * 1/4 * deltaMax


							  for which we get

							  2^(((E * c - F) * (1 + eps1) + c * log2(m) * (1 + eps2)) * (1 + eps3)) =

							  = 2^(E * c - F + c * log2(m) + (E * c - F) * eps1 + c * log2(m) * eps2 + eps3 * (E * c - F + c * log2(m) + (E * c - F) * eps1 + c * log2(m) * eps2)) =
							  = 2^(E * c - F + c * log2(m)) * (1 + (2^((E * c - F) * eps1 + c * log2(m) * eps2 + eps3 * (E * c - F + c * log2(m) + (E * c - F) * eps1 + c * log2(m) * eps2)) - 1))
							  = 2^(E * c - F + c * log2(m)) * (1 + eps)

							  with

							  eps = 2^((E * c - F) * eps1 + c * log2(m) * eps2 + eps3 * (E * c - F + c * log2(m) + (E * c - F) * eps1 + c * log2(m) * eps2)) - 1

							  bounded by abs(eps) <= epsMax

							  For the ease of understanding, we call

							  epsMax1 => epsMaxExponent
							  epsMax2 => epsMaxScaledLogarithm
							  epsMax3 => epsMaxAddition

						       */
						       if (inf(abs(problemdef.dom)) == 0) then {
						       	  /* Least exponent for a double, including integer powers of 2 in the subnormal range */
							  Emin = -1074;
						       } else {
						       	  Emin = floor(log2(inf(abs(problemdef.dom))));
						       };
						       Emax = floor(log2(sup(abs(problemdef.dom))));
						       Ebitwidth = ceil(log2(max(abs(Emin),abs(Emax))));
						       cBitwidth = precision(abs(c));
						       deltaMax = max(-log2(1 - abs(problemdef.target * 1/8)),log2(1 + abs(problemdef.target * 1/8)));
				                       epsMaxScaledLogarithm = 1/abs(c) * 1/4 * deltaMax;
						       epsMaxAddition = 1/abs(max(c,1/2)) * 1/4 * deltaMax;
						       canDoETimesCOnDouble = false;
						       if (Ebitwidth + cBitwidth <= 53) then {
						       	  cFormat = D;
							  canDoETimesCOnDouble = true;
							  epsMaxExponent = 0;
						       } else {
						       	  epsMaxExponent = 13/32 * 1/abs(sup(abs([Emin,Emax])) * c) * 1/4 * deltaMax;
							  canDoETimesCOnDouble = false;
							  if (epsMaxExponent <= 1b-101) then {
							     cFormat = TD;
							  } else {
							     if (epsMaxExponent <= 1b-51) then {
							       cFormat = DD;
							     } else {
							       cFormat = D;
							     };
							  };
						       };
						       cHi = D(c);
						       cMi = D(c - cHi);
						       cLo = D(c - (cHi + cMi));
						       if (epsMaxAddition <= 1b-102) then {
						       	  eTimesCAdditionFormat = TD;
						       } else {
						       	  if (epsMaxAddition <= 1b-53) then {
							     eTimesCAdditionFormat = DD;
							  } else {
							     eTimesCAdditionFormat = D;
							  };
						       };


						       /* Now generate the code for the logarithm log2(m) */
						       logSuffix = "_pow_log";
						       logProblemdef.func = log2(x);
					               logProblemdef.dom = [1;2];
					       	       logProblemdef.target = 1/4 * epsMaxScaledLogarithm;
					       	       logProblemdef.definitionDomain = [1;2];
						       logProblemdef.variableFormat = problemdef.variableFormat;
					       	       logParametrization = parametrization;
						       logParametrization.implementationFile = parametrization.implementationFile @ logSuffix;
					       	       logParametrization.gappaFile = parametrization.gappaFile @ logSuffix;
					       	       logParametrization.gappaOutputFile = parametrization.gappaOutputFile @ logSuffix;
					       	       logParametrization.functionBasename = parametrization.functionBasename @ logSuffix;
					       	       logParametrization.minWidth = (sup([1;2]) - inf([1;2])) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
						       logParametrization.doNotPerformPoweringArgRed = true;
					               logParametrization.argumentReduced = true;

						       resLog = tryImplementation(logProblemdef, logParametrization);

						       if (resLog.okay) then {
						         write("Implementation of the logarithm subfunction has been successful\n");
							 logFormat = resLog.outputformat;

						         cStorageFormat = cFormat;
							 match (logFormat) with
							       D  : { }
							       DD : {
									if (cStorageFormat == D) then {
									   cStorageFormat = DD;
									};
								    }
							       TD : {
									cStorageFormat = TD;
							            };
						         match cStorageFormat with
						       	     TD : {
									if (D(c) == c) then {
									   cStorageFormat = D;
									} else {
									  if (DD(c) == c) then {
									     cStorageFormat = DD;
									  };
									};
							     	  }
						             DD : {
									if (D(c) == c) then {
									   cStorageFormat = D;
									};
							     	  }
						             D  : { };

							 /* Now generate the code for the exponential 2^x */
							 expVariableformat = cFormat;
							 if (logFormat == TD) then {
							    expVariableformat = TD;
							 } else {
							    if ((logFormat == DD) && (expVariableformat != TD)) then {
							       expVariableformat = DD;
							    };
							 };
							 if (eTimesCAdditionFormat == TD) then {
							    expVariableformat = TD;
							 } else {
							    if ((eTimesCAdditionFormat == DD) && (expVariableformat != TD)) then {
							       expVariableformat = DD;
							    };
							 };

							 if (c > 0) then {
							    expDomain = [-1/2;c+1/2];
							 } else {
							    expDomain = [c-1/2;1/2];
							 };
				                         expSuffix = "_pow_exp";
						       	 expProblemdef.func = 2^x;
					               	 expProblemdef.dom = expDomain;
					       	       	 expProblemdef.target = problemdef.target * 1/8;
					       	       	 expProblemdef.definitionDomain = [-500;500];
						       	 expProblemdef.variableFormat = expVariableformat;
					       	       	 expParametrization = parametrization;
						       	 expParametrization.implementationFile = parametrization.implementationFile;
					       	       	 expParametrization.gappaFile = parametrization.gappaFile @ expSuffix;
					       	       	 expParametrization.gappaOutputFile = parametrization.gappaOutputFile @ expSuffix;
					       	       	 expParametrization.functionBasename = parametrization.functionBasename @ expSuffix;
					       	       	 expParametrization.minWidth = (sup(expDomain) - inf(expDomain)) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
						       	 expParametrization.doNotPerformPoweringArgRed = true;
				                         expParametrization.argumentReduced = true;

							 resExp = tryImplementation(expProblemdef, expParametrization);

						         if (resExp.okay) then {
						            write("Implementation of the exponential subfunction has been successful\n");
							    expFormat = resExp.outputformat;

							    /* Combine both codes into one implementation file */
							    bashexecute("cat " @ parametrization.implementationFile @ logSuffix @ " >> " @ parametrization.implementationFile);
							    bashexecute("rm " @ parametrization.implementationFile @ logSuffix);

							    /* Now generate the code performing range reduction
							       and calling the two functions logarithm and
							       exponential.
							    */
							    oldDisplay = display;
							    display = decimal!;
							    poundDefines = "\n";
							    variableDecls = "\n";
							    reductionCode = "\n";

							    match (cStorageFormat) with
							    	  D  : {
										poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_hi " @ cHi @ "\n";
								       }
							    	  DD : {
										poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_hi " @ cHi @ "\n";
										poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_mi " @ cMi @ "\n";
								       }
							    	  TD : {
										poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_hi " @ cHi @ "\n";
										poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_mi " @ cMi @ "\n";
										poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_lo " @ cLo @ "\n";
								       };

							    poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_shifter 6755399441055744.0\n";

						            variableDecls = variableDecls @ "db_number argRedCaster;\n";
							    variableDecls = variableDecls @ "int E;\n";
							    variableDecls = variableDecls @ "double ed;\n";
							    variableDecls = variableDecls @ "double mh;\n";
							    if (preNegate) then {
							       reductionCode = reductionCode @ "argRedCaster.d = -xh;\n";
							    } else {
							       reductionCode = reductionCode @ "argRedCaster.d = xh;\n";
							    };

							    // TODO: Care about subnormal inputs

							    reductionCode = reductionCode @ "E = (int) ((argRedCaster.l >> 52) - 1023ll);\n";
							    reductionCode = reductionCode @ "ed = (double) E;\n";
						            reductionCode = reductionCode @ "argRedCaster.l = (argRedCaster.l & 0x800fffffffffffffull) | 0x3ff0000000000000ull;\n";
							    reductionCode = reductionCode @ "mh = argRedCaster.d;\n";
							    match (problemdef.variableFormat) with
							    	  D  : { }
								  DD : {
						                           variableDecls = variableDecls @ "db_number scaleCaster;\n";
						                           variableDecls = variableDecls @ "double scale;\n";
									   variableDecls = variableDecls @ "double mm;\n";
						                           reductionCode = reductionCode @ "scaleCaster.l = 1023 - E;\n";
						                           reductionCode = reductionCode @ "scaleCaster.l <<= 52;\n";
						                           reductionCode = reductionCode @ "scale = scaleCaster.d;\n";
									   if (preNegate) then {
									       reductionCode = reductionCode @ "mm = -xm * scale;\n";
									   } else {
									       reductionCode = reductionCode @ "mm = xm * scale;\n";
									   };
								       }
								  TD : {
						                           variableDecls = variableDecls @ "db_number scaleCaster;\n";
						                           variableDecls = variableDecls @ "double scale;\n";
									   variableDecls = variableDecls @ "double mm;\n";
									   variableDecls = variableDecls @ "double ml;\n";
						                           reductionCode = reductionCode @ "scaleCaster.l = 1023 - E;\n";
						                           reductionCode = reductionCode @ "scaleCaster.l <<= 52;\n";
						                           reductionCode = reductionCode @ "scale = scaleCaster.d;\n";
									   if (preNegate) then {
									       reductionCode = reductionCode @ "mm = -xm * scale;\n";
									       reductionCode = reductionCode @ "ml = -xl * scale;\n";
									   } else {
									       reductionCode = reductionCode @ "mm = xm * scale;\n";
									       reductionCode = reductionCode @ "ml = xl * scale;\n";
									   };
								       };
						            variableDecls = variableDecls @ "int F;\n";
							    variableDecls = variableDecls @ "double fd;\n";
							    if (canDoETimesCOnDouble) then {
							       variableDecls = variableDecls @ "double eTimesC;\n";
							       variableDecls = variableDecls @ "double shiftedETimesC;\n";
							       variableDecls = variableDecls @ "db_number fCaster;\n";
							       variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
							       reductionCode = reductionCode @ "eTimesC = ed * " @ (parametrization.functionBasename) @ "_exponent_hi;\n";
							       reductionCode = reductionCode @ "shiftedETimesC = eTimesC + " @ (parametrization.functionBasename) @ "_shifter;\n";
							       reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
							       reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
							       reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
							       reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
							       reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
							       reductionCode = reductionCode @ "eTimesCMinusF_hi = eTimesC - fd;\n";
							       eTimesCMinusFFormat = D;
							    } else {
							       match (cFormat) with
							       	     D  : {
							                          variableDecls = variableDecls @ "double eTimesC_hi;\n";
							                          variableDecls = variableDecls @ "double shiftedETimesC;\n";
							                          variableDecls = variableDecls @ "db_number fCaster;\n";
							                          reductionCode = reductionCode @ "eTimesC_hi = ed * " @ (parametrization.functionBasename) @ "_exponent_hi;\n";
							                          reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
							                          reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
							                          reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
							                          reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
							                          reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
							                          reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
										  eTimesCFormat = D;
								          }
							             DD : {
										  if (cStorageFormat == D) then {
							                              variableDecls = variableDecls @ "double eTimesC_hi;\n";
							                              variableDecls = variableDecls @ "double eTimesC_mi;\n";
							                              variableDecls = variableDecls @ "double shiftedETimesC;\n";
							                              variableDecls = variableDecls @ "db_number fCaster;\n";
										      reductionCode = reductionCode @ "Mul12(&eTimesC_hi,&eTimesC_mi,ed," @ (parametrization.functionBasename) @ "_exponent_hi);\n";
							                              reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
							                              reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
							                              reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
							                              reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
							                              reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
							                              reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
										      eTimesCFormat = DD;
										  } else {
							                              variableDecls = variableDecls @ "double eTimesC_hi;\n";
							                              variableDecls = variableDecls @ "double eTimesC_mi;\n";
							                              variableDecls = variableDecls @ "double shiftedETimesC;\n";
							                              variableDecls = variableDecls @ "db_number fCaster;\n";
										      reductionCode = reductionCode @ "Mul122(&eTimesC_hi,&eTimesC_mi,ed," @ (parametrization.functionBasename) @ "_exponent_hi," @ (parametrization.functionBasename) @ "_exponent_mi);\n";
							                              reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
							                              reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
							                              reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
							                              reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
							                              reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
							                              reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
										      eTimesCFormat = DD;
										  };
								     	  }
							             TD : {
										  match (cStorageFormat) with
										  	D  : {
							                                        variableDecls = variableDecls @ "double eTimesC_hi;\n";
							                                        variableDecls = variableDecls @ "double eTimesC_mi;\n";
							                                        variableDecls = variableDecls @ "double shiftedETimesC;\n";
							                                        variableDecls = variableDecls @ "db_number fCaster;\n";
										                reductionCode = reductionCode @ "Mul12(&eTimesC_hi,&eTimesC_mi,ed," @ (parametrization.functionBasename) @ "_exponent_hi);\n";
							                                        reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
							                                        reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
							                                        reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
							                                        reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
							                                        reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
							                                        reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
										                eTimesCFormat = DD;
											     }
										  	DD : {
							                                        variableDecls = variableDecls @ "double eTimesC_hi;\n";
							                                        variableDecls = variableDecls @ "double eTimesC_mi;\n";
							                                        variableDecls = variableDecls @ "double eTimesC_lo;\n";
							                                        variableDecls = variableDecls @ "double shiftedETimesC;\n";
							                                        variableDecls = variableDecls @ "db_number fCaster;\n";
										                reductionCode = reductionCode @ "Mul123(&eTimesC_hi,&eTimesC_mi,&eTimesC_lo,ed," @ (parametrization.functionBasename) @ "_exponent_hi," @ (parametrization.functionBasename) @ "_exponent_mi);\n";
							                                        reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
							                                        reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
							                                        reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
							                                        reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
							                                        reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
							                                        reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
										                eTimesCFormat = TD;
											     }
										  	TD : {
							                                        variableDecls = variableDecls @ "double eTimesC_hi;\n";
							                                        variableDecls = variableDecls @ "double eTimesC_mi;\n";
							                                        variableDecls = variableDecls @ "double eTimesC_lo;\n";
							                                        variableDecls = variableDecls @ "double shiftedETimesC;\n";
							                                        variableDecls = variableDecls @ "db_number fCaster;\n";
										                reductionCode = reductionCode @ "Mul133(&eTimesC_hi,&eTimesC_mi,&eTimesC_lo,ed," @ (parametrization.functionBasename) @ "_exponent_hi," @ (parametrization.functionBasename) @ "_exponent_mi," @ (parametrization.functionBasename) @ "_exponent_lo);\n";
							                                        reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
							                                        reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
							                                        reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
							                                        reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
							                                        reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
							                                        reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
										                eTimesCFormat = TD;
											     };
								     	  };
									  variableDecls = variableDecls @ "double minusFd;\n";
									  reductionCode = reductionCode @ "minusFd = -fd;\n";
									  match (eTimesCAdditionFormat) with
									  	D  : {
											match (eTimesCFormat) with
											      D  : {
													/* D - D => D */
													variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
													reductionCode = reductionCode @ "eTimesCMinusF_hi = eTimesC_hi + minusFd;\n";
													eTimesCMinusFFormat = D;
											      	   }
											      DD : {
													/* DD - D => D */
													variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
													reductionCode = reductionCode @ "eTimesCMinusF_hi = (eTimesC_hi + minusFd) + eTimesC_mi;\n";
													eTimesCMinusFFormat = D;
											      	   }
											      TD : {
													/* TD - D => D */
													variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
													reductionCode = reductionCode @ "eTimesCMinusF_hi = ((eTimesC_hi + minusFd) + eTimesC_mi) + eTimesC_lo;\n";
													eTimesCMinusFFormat = D;
											      	   };
										     }
									  	DD : {
											match (eTimesCFormat) with
											      D  : {
													/* D - D => DD (impossible - Sterbenz: D) */
													variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
													reductionCode = reductionCode @ "eTimesCMinusF_hi = eTimesC_hi + minusFd;\n";
													eTimesCMinusFFormat = D;
											      	   }
											      DD : {
													/* DD - D => DD */
													variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
													variableDecls = variableDecls @ "double eTimesCMinusF_mi;\n";
													variableDecls = variableDecls @ "double tempSubstr1;\n";
													reductionCode = reductionCode @ "tempSubstr1 = eTimesC_hi + minusFd;\n";
													reductionCode = reductionCode @ "Add12(eTimesCMinusF_hi,eTimesCMinusF_mi,tempSubstr1,eTimesC_mi);\n";
													eTimesCMinusFFormat = DD;
											      	   }
											      TD : {
													/* TD - D => DD */
													variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
													variableDecls = variableDecls @ "double eTimesCMinusF_mi;\n";
													variableDecls = variableDecls @ "double tempSubstr1;\n";
													variableDecls = variableDecls @ "double tempSubstr2_hi, tempSubstr2_lo;\n";
													variableDecls = variableDecls @ "double tempSubstr3;\n";
													reductionCode = reductionCode @ "tempSubstr1 = eTimesC_hi + minusFd;\n";
													reductionCode = reductionCode @ "Add12(tempSubstr2_hi,tempSubstr2_lo,tempSubstr1,eTimesC_mi);\n";
													reductionCode = reductionCode @ "tempSubstr3 = tempSubstr2_lo + eTimesC_mi;\n";
													reductionCode = reductionCode @ "Add12(eTimesCMinusF_hi,eTimesCMinusF_mi,tempSubstr2_hi,tempSubstr3);\n";
													eTimesCMinusFFormat = DD;
											      	   };
										     }
									  	TD : {
											match (eTimesCFormat) with
											      D  : {
													/* D - D => TD (impossible - Sterbenz: D) */
													variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
													reductionCode = reductionCode @ "eTimesCMinusF_hi = eTimesC_hi + minusFd;\n";
													eTimesCMinusFFormat = D;
											      	   }
											      DD : {
													/* DD - D => TD (impossible - Sterbenz: DD) */
													variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
													variableDecls = variableDecls @ "double eTimesCMinusF_mi;\n";
													variableDecls = variableDecls @ "double tempSubstr1;\n";
													reductionCode = reductionCode @ "tempSubstr1 = eTimesC_hi + minusFd;\n";
													reductionCode = reductionCode @ "Add12(eTimesCMinusF_hi,eTimesCMinusF_mi,tempSubstr1,eTimesC_mi);\n";
													eTimesCMinusFFormat = DD;
											      	   }
											      TD : {
													/* TD - D => TD */
													variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
													variableDecls = variableDecls @ "double eTimesCMinusF_mi;\n";
													variableDecls = variableDecls @ "double eTimesCMinusF_lo;\n";
													variableDecls = variableDecls @ "double tempSubstr1;\n";
													reductionCode = reductionCode @ "tempSubstr1 = eTimesC_hi + minusFd;\n";
													reductionCode = reductionCode @ "Renormalize3(&eTimesCMinusF_hi,&eTimesCMinusF_mi,&eTimesCMinusF_lo,tempSubstr1,eTimesC_mi,eTimesC_lo);\n";
													eTimesCMinusFFormat = TD;
											      	   };
										     };
							    };

							    variableDecls = variableDecls @ (match (logFormat) with
							    		    		    	   D  : ( "double res_logh;" )
												   DD : ( "double res_logh, res_logm;" )
												   TD : ( "double res_logh, res_logm, res_logl;" )) @ "\n";
							    reductionCode = reductionCode @ (resLog.functionname) @ "(";
							    reductionCode = reductionCode @ (match (logFormat) with
							    		    		    	   D  : ( "&res_logh, " )
												   DD : ( "&res_logh, &res_logm, " )
												   TD : ( "&res_logh, &res_logm, &res_logl, " ));
							    reductionCode = reductionCode @ (match (problemdef.variableFormat) with
							    		    		    	   D  : ( "mh" )
												   DD : ( "mh, mm" )
												   TD : ( "mh, mm, ml"));
							    reductionCode = reductionCode @ ");\n";

							    match (logFormat) with
							    	  D  : {
										variableDecls = variableDecls @ "double cTimesLog_hi;\n";
										reductionCode = reductionCode @ "cTimesLog_hi = res_logh * " @ (parametrization.functionBasename) @ "_exponent_hi;\n";
										cTimesLogFormat = D;
								       }
							    	  DD : {
										if (cStorageFormat == D) then {
										    variableDecls = variableDecls @ "double cTimesLog_hi;\n";
										    variableDecls = variableDecls @ "double cTimesLog_mi;\n";
										    reductionCode = reductionCode @ "Mul122(&cTimesLog_hi, &cTimesLog_mi, " @ (parametrization.functionBasename) @ "_exponent_hi, res_logh, res_logm);\n";
										    cTimesLogFormat = DD;
										} else {
										    variableDecls = variableDecls @ "double cTimesLog_hi;\n";
										    variableDecls = variableDecls @ "double cTimesLog_mi;\n";
										    reductionCode = reductionCode @ "Mul22(&cTimesLog_hi, &cTimesLog_mi, " @ (parametrization.functionBasename) @ "_exponent_hi, " @ (parametrization.functionBasename) @ "_exponent_mi, res_logh, res_logm);\n";
										    cTimesLogFormat = DD;
										};
								       }
							    	  TD : {
										match (cStorageFormat) with
										      D  : {
										               variableDecls = variableDecls @ "double cTimesLog_hi;\n";
										               variableDecls = variableDecls @ "double cTimesLog_mi;\n";
										               variableDecls = variableDecls @ "double cTimesLog_lo;\n";
										               reductionCode = reductionCode @ "Mul133(&cTimesLog_hi, &cTimesLog_mi, &cTimesLog_lo, " @ (parametrization.functionBasename) @ "_exponent_hi, res_logh, res_logm, res_logl);\n";
										               cTimesLogFormat = TD;
										      	   }
										      DD : {
										               variableDecls = variableDecls @ "double cTimesLog_hi;\n";
										               variableDecls = variableDecls @ "double cTimesLog_mi;\n";
										               variableDecls = variableDecls @ "double cTimesLog_lo;\n";
										               reductionCode = reductionCode @ "Mul233(&cTimesLog_hi, &cTimesLog_mi, &cTimesLog_lo, " @ (parametrization.functionBasename) @ "_exponent_hi, " @ (parametrization.functionBasename) @ "_exponent_mi, res_logh, res_logm, res_logl);\n";
										               cTimesLogFormat = TD;
										      	   }
										      TD : {
										               variableDecls = variableDecls @ "double cTimesLog_hi;\n";
										               variableDecls = variableDecls @ "double cTimesLog_mi;\n";
										               variableDecls = variableDecls @ "double cTimesLog_lo;\n";
										               reductionCode = reductionCode @ "Mul33(&cTimesLog_hi, &cTimesLog_mi, &cTimesLog_lo, " @ (parametrization.functionBasename) @ "_exponent_hi, " @ (parametrization.functionBasename) @ "_exponent_mi, " @ (parametrization.functionBasename) @ "_exponent_lo, res_logh, res_logm, res_logl);\n";
										               cTimesLogFormat = TD;
										      	   };
								       };
						            match (eTimesCMinusFFormat) with
							    	  D  : {
										match (cTimesLogFormat) with
										      D  : {
												/* D + D =>  */
												if (eTimesCAdditionFormat == D) then {
												   variableDecls = variableDecls @ "double exp_arg_hi;\n";
												   reductionCode = reductionCode @ "exp_arg_hi = eTimesCMinusF_hi + cTimesLog_hi;\n";
												   expFinalFormat = D;
												} else {
												   variableDecls = variableDecls @ "double exp_arg_hi;\n";
												   variableDecls = variableDecls @ "double exp_arg_mi;\n";
												   reductionCode = reductionCode @ "Add12Cond(exp_arg_hi, exp_arg_mi, eTimesCMinusF_hi, cTimesLog_hi);\n";
												   expFinalFormat = DD;
												};
										      	   }
										      DD : {
												/* D + DD =>  */
												if (eTimesCAdditionFormat == TD) then {
												   variableDecls = variableDecls @ "double exp_arg_hi;\n";
												   variableDecls = variableDecls @ "double exp_arg_mi;\n";
												   variableDecls = variableDecls @ "double exp_arg_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd4;\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, cTimesLog_mi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd1_hi, tempAdd2_hi);\n";
												   reductionCode = reductionCode @ "Renormalize3(tempAdd3_hi,tempAdd3_lo,tempAdd2_lo);\n";
												   expFinalFormat = TD;
												} else {
												   variableDecls = variableDecls @ "double exp_arg_hi;\n";
												   variableDecls = variableDecls @ "double exp_arg_mi;\n";
												   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd4;\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, cTimesLog_mi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd1_hi, tempAdd2_hi);\n";
												   reductionCode = reductionCode @ "tempAdd4 = tempAdd2_lo + tempAdd3_lo;\n";
												   reductionCode = reductionCode @ "Add12Cond(exp_arg_hi, exp_arg_mi, tempAdd3_hi, tempAdd4);\n";
												   expFinalFormat = DD;
												};
										      	   }
										      TD : {
												/* D + TD =>  */
												   variableDecls = variableDecls @ "double exp_arg_hi;\n";
												   variableDecls = variableDecls @ "double exp_arg_mi;\n";
												   variableDecls = variableDecls @ "double exp_arg_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd4_hi, tempAdd4_mi, tempAdd4_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd5;\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, cTimesLog_mi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd2_lo, cTimesLog_lo);\n";
												   reductionCode = reductionCode @ "Renormalize3(&tempAdd4_hi,&tempAdd4_mi,&tempAdd4_lo,tempAdd1_hi,tempAdd2_hi,tempAdd3_hi);\n";
												   reductionCode = reductionCode @ "tempAdd5 = tempAdd4_lo + tempAdd3_lo;\n";
												   reductionCode = reductionCode @ "Renormalize3(&exp_arg_hi,&exp_arg_mi,&exp_arg_lo,tempAdd4_hi,tempAdd4_mi,tempAdd5);\n";
												   expFinalFormat = TD;
										      	   };
								       }
							    	  DD : {
										match (cTimesLogFormat) with
										      D  : {
												/* DD + D =>  */
												if (eTimesCAdditionFormat == TD) then {
												   variableDecls = variableDecls @ "double exp_arg_hi;\n";
												   variableDecls = variableDecls @ "double exp_arg_mi;\n";
												   variableDecls = variableDecls @ "double exp_arg_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd4;\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, eTimesCMinusF_mi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd1_hi, tempAdd2_hi);\n";
												   reductionCode = reductionCode @ "Renormalize3(tempAdd3_hi,tempAdd3_lo,tempAdd2_lo);\n";
												   expFinalFormat = TD;
												} else {
												   variableDecls = variableDecls @ "double exp_arg_hi;\n";
												   variableDecls = variableDecls @ "double exp_arg_mi;\n";
												   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd4;\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, eTimesCMinusF_mi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd1_hi, tempAdd2_hi);\n";
												   reductionCode = reductionCode @ "tempAdd4 = tempAdd2_lo + tempAdd3_lo;\n";
												   reductionCode = reductionCode @ "Add12Cond(exp_arg_hi, exp_arg_mi, tempAdd3_hi, tempAdd4);\n";
												   expFinalFormat = DD;
												};
										      	   }
										      DD : {
												/* DD + DD =>  */
												if (eTimesCAdditionFormat == TD) then {
												   variableDecls = variableDecls @ "double exp_arg_hi;\n";
												   variableDecls = variableDecls @ "double exp_arg_mi;\n";
												   variableDecls = variableDecls @ "double exp_arg_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
												   variableDecls = variableDecls @ "double tempAdd4;\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, eTimesCMinusF_mi, cTimesLog_mi);\n";
												   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd1_lo, tempAdd2_hi);\n";
												   reductionCode = reductionCode @ "tempAdd4 = tempAdd2_lo + tempAdd3_lo;\n";
												   reductionCode = reductionCode @ "Renormalize3(&exp_arg_hi,&exp_arg_mi,&exp_arg_lo,tempAdd1_hi,tempAdd3_hi,tempAdd4);\n";
												   expFinalFormat = TD;
												} else {
												   variableDecls = variableDecls @ "double exp_arg_hi;\n";
												   variableDecls = variableDecls @ "double exp_arg_mi;\n";
												   reductionCode = reductionCode @ "Add22Cond(&exp_arg_hi, &exp_arg_mi, eTimesCMinusF_hi, eTimesCMinusF_mi, cTimesLog_hi, cTimesLog_mi);\n";
												   expFinalFormat = DD;
												};
										      	   }
										      TD : {
												/* DD + TD =>  */
												variableDecls = variableDecls @ "double exp_arg_hi;\n";
												variableDecls = variableDecls @ "double exp_arg_mi;\n";
												variableDecls = variableDecls @ "double exp_arg_lo;\n";
												variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_mi, tempAdd1_lo;\n";
												reductionCode = reductionCode @ "Add233Cond(&tempAdd1_hi, &tempAdd1_mi, &tempAdd1_lo, eTimesCMinusF_hi, eTimesCMinusF_mi, cTimesLog_hi, cTimesLog_mi, cTimesLog_lo);\n";
												expFinalFormat = TD;
										      	   };
								       }
							    	  TD : {
										match (cTimesLogFormat) with
										      D  : {
												/* TD + D =>  */
												variableDecls = variableDecls @ "double exp_arg_hi;\n";
												variableDecls = variableDecls @ "double exp_arg_mi;\n";
												variableDecls = variableDecls @ "double exp_arg_lo;\n";
												variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
												variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
												variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
												variableDecls = variableDecls @ "double tempAdd4_hi, tempAdd4_mi, tempAdd4_lo;\n";
												variableDecls = variableDecls @ "double tempAdd5;\n";
												reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
												reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, eTimesCMinusF_mi);\n";
												reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd2_lo, eTimesCMinusF_lo);\n";
												reductionCode = reductionCode @ "Renormalize3(&tempAdd4_hi,&tempAdd4_mi,&tempAdd4_lo,tempAdd1_hi,tempAdd2_hi,tempAdd3_hi);\n";
												reductionCode = reductionCode @ "tempAdd5 = tempAdd4_lo + tempAdd3_lo;\n";
												reductionCode = reductionCode @ "Renormalize3(&exp_arg_hi,&exp_arg_mi,&exp_arg_lo,tempAdd4_hi,tempAdd4_mi,tempAdd5);\n";
												expFinalFormat = TD;
										      	   }
										      DD : {
												/* TD + DD =>  */
												variableDecls = variableDecls @ "double exp_arg_hi;\n";
												variableDecls = variableDecls @ "double exp_arg_mi;\n";
												variableDecls = variableDecls @ "double exp_arg_lo;\n";
												variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_mi, tempAdd1_lo;\n";
												reductionCode = reductionCode @ "Add233Cond(&tempAdd1_hi, &tempAdd1_mi, &tempAdd1_lo, cTimesLog_hi, cTimesLog_mi, eTimesCMinusF_hi, eTimesCMinusF_mi, eTimesCMinusF_lo);\n";
												expFinalFormat = TD;
										      	   }
										      TD : {
												/* TD + TD =>  */
												variableDecls = variableDecls @ "double exp_arg_hi;\n";
												variableDecls = variableDecls @ "double exp_arg_mi;\n";
												variableDecls = variableDecls @ "double exp_arg_lo;\n";
												variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
												variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
												variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
												variableDecls = variableDecls @ "double tempAdd4;\n";
												reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
												reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, eTimesCMinusF_mi, cTimesLog_mi);\n";
												reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd2_hi, tempAdd1_lo);\n";
												reductionCode = reductionCode @ "tempAdd4 = tempAdd3_lo + (tempAdd2_lo + (cTimesLog_lo + eTimesCMinusF_lo));\n";
												reductionCode = reductionCode @ "Renormalize3(&exp_arg_hi,&exp_arg_mi,&exp_arg_lo,tempAdd1_hi,tempAdd3_hi,tempAdd4);\n";
												expFinalFormat = TD;
										      	   };
								       };
						            match (expVariableformat) with
							    	  D  : { }
								  DD : {
										if (expFinalFormat == D) then {
										   variableDecls = variableDecls @ "double exp_arg_mi;\n";
										   reductionCode = reductionCode @ "exp_arg_mi = 0.0;\n";
										};
								       }
								  TD : {
										match (expFinalFormat) with
										      D  : {
											       variableDecls = variableDecls @ "double exp_arg_mi;\n";
										   	       reductionCode = reductionCode @ "exp_arg_mi = 0.0;\n";
											       variableDecls = variableDecls @ "double exp_arg_lo;\n";
										   	       reductionCode = reductionCode @ "exp_arg_lo = 0.0;\n";
										      	   }
										      DD : {
											       variableDecls = variableDecls @ "double exp_arg_lo;\n";
										   	       reductionCode = reductionCode @ "exp_arg_lo = 0.0;\n";
										      	   }
										      TD : { };
								       };
							    variableDecls = variableDecls @ (match (expFormat) with
							    	                                   D  : ( "double res_exph;\n" )
												   DD : ( "double res_exph, res_expm;\n" )
												   TD : ( "double res_exph, res_expm, res_expl;\n" ));
							    reductionCode = reductionCode @ (resExp.functionname) @ "(";
							    reductionCode = reductionCode @ (match (expFormat) with
							    	                                   D  : ( "&res_exph, " )
												   DD : ( "&res_exph, &res_expm, " )
												   TD : ( "&res_exph, &res_expm, &res_expl, " ));
							    reductionCode = reductionCode @ (match (expVariableformat) with
							    		    		    	   D  : ( "exp_arg_hi" )
												   DD : ( "exp_arg_hi, exp_arg_mi" )
												   TD : ( "exp_arg_hi, exp_arg_mi, exp_arg_lo" ));
							    reductionCode = reductionCode @ ");\n";
							    variableDecls = variableDecls @ "int F1, F2;\n";
							    reductionCode = reductionCode @ "F1 = F >> 1;\n";
                                                            reductionCode = reductionCode @ "F2 = F - F1;\n";
							    variableDecls = variableDecls @ "db_number scaleCaster1, scaleCaster2;\n";
							    variableDecls = variableDecls @ "double scale1, scale2;\n";
							    reductionCode = reductionCode @ "scaleCaster1.l = F1 + 1023ll;\n";
							    reductionCode = reductionCode @ "scaleCaster1.l <<= 52;\n";
							    reductionCode = reductionCode @ "scale1 = scaleCaster1.d;\n";
							    reductionCode = reductionCode @ "scaleCaster2.l = F2 + 1023ll;\n";
							    reductionCode = reductionCode @ "scaleCaster2.l <<= 52;\n";
							    if (postNegate) then {
							        reductionCode = reductionCode @ "scale2 = -scaleCaster2.d;\n";
						            } else {
							        reductionCode = reductionCode @ "scale2 = scaleCaster2.d;\n";
							    };
							    match (expFormat) with
							    	  D  : {
										reductionCode = reductionCode @ "*res_resh = scale2 * (scale1 * res_exph);\n";
								       }
							    	  DD : {
										reductionCode = reductionCode @ "*res_resh = scale2 * (scale1 * res_exph);\n";
										reductionCode = reductionCode @ "*res_resm = scale2 * (scale1 * res_expm);\n";
								       }
							    	  TD : {
										reductionCode = reductionCode @ "*res_resh = scale2 * (scale1 * res_exph);\n";
										reductionCode = reductionCode @ "*res_resm = scale2 * (scale1 * res_expm);\n";
										reductionCode = reductionCode @ "*res_resl = scale2 * (scale1 * res_expl);\n";
								       };

							    display = oldDisplay!;

							    /* Generate the function header etc. and print out everything */
							    implCode = "\n";
							    implCode = implCode @ poundDefines @ "\n";
							    implCode = implCode @ "void " @ (parametrization.functionBasename) @ "(";
							    implCode = implCode @ (match expFormat with
							    	       		  	 D  : ( "double *res_resh, " )
											 DD : ( "double *res_resh, double *res_resm, " )
											 TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
							    implCode = implCode @ (match (problemdef.variableFormat) with
							    	       		  	 D  : ( "double xh" )
											 DD : ( "double xh, double xm" )
											 TD : ( "double xh, double xm, double xl"));
					                    implCode = implCode @ ") {\n";
							    implCode = implCode @ variableDecls @ "\n";
							    if (handleZero) then {
							        implCode = implCode @ "if (xh == 0.0) {\n";
								implCode = implCode @ (match expFormat with
							    	       		  	 D  : ( "*res_resh = 0.0;" )
											 DD : ( "*res_resh = 0.0; *res_resm = 0.0;" )
											 TD : ( "*res_resh = 0.0; *res_resm = 0.0; *res_resl = 0.0;" ));
								implCode = implCode @ "\n} else {\n" @ reductionCode @ "\n}\n";
							    } else {
							    	implCode = implCode @ reductionCode @ "\n";
						            };
							    implCode = implCode @ "}\n";

							    write(implCode) >> parametrization.implementationFile;

							    /* Report success */
							    result.approxerr = 1/2 * problemdef.target;   // TODO
						            result.implerr = 1/2 * problemdef.target;     // TODO
         					            result.outputformat = expFormat;
          					            result.functionname = parametrization.functionBasename;
						            result.okay = true;
							 } else {
							    write("Could not implement 2^x on \n",expDomain);
							 };
						       } else {
						       	 write("Could not implement log2(x) on [1;2]\n");
						       };
						    };
						 };
					      };
				           };
				         };
				     }
                default : { };

	  return result;
};

procedure doWorkForTryImplementationThroughMetaSplitting(problemdef, parametrization) {
	  var result, domains, dom, currDom, okay, minWidth, origDefDom;
	  var myProblemdef, myParametrization, res, suffix, i, oldDisplay, currImplementationFile;
	  var outputDomains, outputResults, outputFiles, implFile;
	  var splitterCode, recursiveSplitterRes;
	  var functionNames, outputFormats, myOutputFormat, myOutputFormatNum;
	  var implErr, approxErr;

	  result = { .okay = false };

	  dom = problemdef.dom;
	  minWidth = parametrization.metaSplitMinWidth;
	  if (inf(dom) * sup(dom) < 0) then {
	     domains = [| [ inf(dom), D(inf(dom) / 3)], [D(inf(dom) / 3), D(sup(dom) / 3)], [D(sup(dom) / 3), sup(dom)] |];
	  } else {
	     domains = [| [inf(dom), D(mid(dom))], [D(mid(dom)), sup(dom)] |];
	  };

	  okay = true; i = 0;
	  outputDomains = [||];
	  outputResults = [||];
	  outputFiles = [||];
	  while (okay && (domains != [||])) do {
	  	currDom = head(domains);
		domains = tail(domains);
		if (sup(currDom) - inf(currDom) >= abs(minWidth)) then {
 		    oldDisplay = display;
		    display = decimal!;
		    suffix = "_metasplit_" @ i;
		    display = oldDisplay!;
		    currImplementationFile = parametrization.implementationFile @ suffix;
                    myProblemdef.func = problemdef.func;
		    myProblemdef.dom = currDom;
		    myProblemdef.target = problemdef.target;
		    myProblemdef.variableFormat = problemdef.variableFormat;
		    origDefDom = problemdef.dom;
		    match (problemdef) with { .definitionDomain = default } : {
		                                 if (origDefDom in problemdef.definitionDomain) then {
                                                    origDefDom = problemdef.definitionDomain;
                                                 }; }
                                            default : {};
		    myProblemdef.definitionDomain = origDefDom;
		    myParametrization = parametrization;
		    myParametrization.gappaFile = parametrization.gappaFile @ suffix;
		    myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
		    myParametrization.functionBasename = parametrization.functionBasename @ suffix;
		    myParametrization.implementationFile = currImplementationFile;
		    myParametrization.doNotPerformMetaSplitArgRed = true;
		    myParametrization.minWidth = (sup(currDom) - inf(currDom)) * (parametrization.minWidth / (sup(dom) - inf(dom)));
		    myParametrization.argumentReduced = true;

		    write("Trying to implement the given function on ", currDom, "\n");
		    res = tryImplementation(myProblemdef, myParametrization);

		    if (res.okay) then {
		       write("The implementation of the function on ", currDom, " has been successful.\n");
		       outputDomains = outputDomains :. currDom;
		       outputResults = outputResults :. res;
		       outputFiles = outputFiles :. currImplementationFile;
		       i := i + 1;
		    } else {
		          write("The implementation of the function on ", currDom, " has failed. Resplitting.\n");
	                  if (inf(currDom) * sup(currDom) < 0) then {
	                     domains = [| [ inf(currDom), D(inf(currDom) / 3)], [D(inf(currDom) / 3), D(sup(currDom) / 3)], [D(sup(currDom) / 3), sup(currDom)] |] @ domains;
	                  } else {
	                     domains = [| [inf(currDom), D(mid(currDom))], [D(mid(currDom)), sup(currDom)] |] @ domains;
	                  };
		    };
		} else {
		    okay = false;
		};
	  };

	  if (okay) then {
	     /* Combine all implementation files into one file */
	     write("\n") > parametrization.implementationFile;
	     for implFile in outputFiles do {
	         bashexecute("cat " @ implFile @ " >> " @ (parametrization.implementationFile));
		 bashexecute("rm " @ implFile);
	     };

	     functionNames = [||];
	     outputFormats = [||];
	     myOutputFormatNum = 1;
	     implErr = 0;
	     approxErr = 0;
	     for res in outputResults do {
	     	 myOutputFormatNum = max(myOutputFormatNum,
					 match res.outputformat with D : (1) DD : (2) TD : (3));
		 implErr = max(implErr, abs(res.implerr));
		 approxErr = max(approxErr, abs(res.approxerr));
		 outputFormats = outputFormats :. (res.outputformat);
		 functionNames = functionNames :. (res.functionname);
	     };

	     myOutputFormat = match myOutputFormatNum with 1 : (D) 2 : (DD) 3 : (TD);	     

	     splitterCode = "\n";
	     recursiveSplitterRes = generateRecursiveSplitter((parametrization.functionBasename) @ "_metasplit", outputDomains, functionNames, outputFormats, problemdef.variableFormat, myOutputFormat);
             if (recursiveSplitterRes.okay) then {
		splitterCode = splitterCode @ recursiveSplitterRes.defines;
             	splitterCode = splitterCode @ "\n\nvoid " @ (parametrization.functionBasename) @ "(";
	       	splitterCode = splitterCode @ (match myOutputFormat with
                                                     D   : ( "double *res_resh, " )
                                                     DD  : ( "double *res_resh, double *res_resm, " )
                                                     TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                              );
                splitterCode = splitterCode @ (match problemdef.variableFormat with
                                                     D   : ( "double xh" )
                                                     DD  : ( "double xh, double xm" )
                                                     TD  : ( "double xh, double xm, double xl" )
                                              );
                splitterCode = splitterCode @ ") {\n";
		splitterCode = splitterCode @ recursiveSplitterRes.splitterCode;
                splitterCode = splitterCode @ "}\n\n";
		write(splitterCode) >> parametrization.implementationFile;
             };

	     result.okay = true;
	     result.approxerr = approxErr;
	     result.implErr = implErr;
	     result.outputformat = myOutputFormat;
	     result.functionname = (parametrization.functionBasename);
	  };

	  return result;
};

procedure tryImplementationThroughMetaSplitting(problemdef, parametrization) {
	  var result, needArgumentReduction, res, doNotPerformMetaSplitArgRed;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default,
				       .tableIndexWidth = default,
				       .metaSplitMinWidth = default } } : {

				       /* Test if we may perform this type of argument
				          reduction
				       */
				       doNotPerformMetaSplitArgRed = false;
				       match (parametrization) with
				             { .doNotPerformMetaSplitArgRed = true } : { doNotPerformMetaSplitArgRed = true; }
					     default : { };

				       if (!doNotPerformMetaSplitArgRed) then {
				           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
					      polynomial degree
				           */
				           needArgumentReduction = true;
				           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                                   if (res.okay) then {
   	                                       if (res.sufficientDegree) then needArgumentReduction = false;
				           } else {
				               needArgumentReduction = false;
				           };

				           if (needArgumentReduction) then {
					      result = doWorkForTryImplementationThroughMetaSplitting(problemdef, parametrization);
				           };
				         };
				     }
                default : { };

	  return result;
};

procedure limitListToNElements(l,n) {
	  var res, i;

	  if (length(l) <= n) then {
	     res = l;
	  } else {
	    res = [||];
	    for i from 0 to n - 1 do {
	    	res = res :. (l[i]);
	    };
	  };

	  return res;
};

procedure removeDoubleEntriesInSortedList(l) {
	  var ll, p, e, lll;

	  if (l == [||]) then {
	     ll = [||];
	  } else {
	     lll = l;
	     p = head(lll);
	     lll = tail(lll);
	     ll = [| p |];
	     while (lll != [||]) do {
	     	   e = head(lll);
		   lll = tail(lll);
		   if (e != p) then {
		      ll = e .: ll;
		      p = e;
		   };
	     };

	  };

	  return revert(ll);
};

procedure tryDetectPeriodicArgRed(func, dom, target, xFormat) {
	  var result, c, zeros, i, j, len;
	  var oldPrec;
	  var possiblePeriods;
	  var testfunc, y, zerosUpper, zerosLower;
	  var recDom;
	  var oldPoints;
	  var okay, myPeriod;
	  var t;
	  var zerosUpperRaw, zerosLowerRaw, z;

	  result = { .okay = false };

	  /* We try to find all points where
	     func admits the same value as in 
	     a point c. The distances to c
	     then give an idea of a possible
	     period.
	  */
	  if (0 in dom) then {
	     c = 0;
	  } else {
	     c = (1023 * inf(dom) + sup(dom)) / 1024;
	  };

	  oldPrec = prec;
	  oldPoints = points;
          meanPeriod = 0;
	  numPeriod = 0;
	  points = ((points - 1) * 4 + 1)!;
	  prec = max(500, prec, 4 * ceil(-log2(target)) + 100)!;
	  if (abs(func(c)) <= 1b1024) then {
	     zeros = mydirtyfindzeros(func - func(c), dom);
	  } else {
	     zeros = [||];
	  };
	  zeros = limitListToNElements(zeros, 25);

	  points = oldPoints!;
	  len = length(zeros);
          possiblePeriods = [||];
	  if (len >= 2) then {
	     for i from 0 to len - 2 do {
	     	 for j from i + 1 to len - 1 do {
		     possiblePeriods = (zeros[j] - zeros[i]) .: possiblePeriods;
		 };
	     };
	     possiblePeriods = sort(possiblePeriods);
	     possiblePeriods = removeDoubleEntriesInSortedList(possiblePeriods);
          };
	  prec = oldPrec!;

	  okay = false;
	  while ((!okay) && (possiblePeriods != [||])) do {
	  	myPeriod = head(possiblePeriods);
		possiblePeriods = tail(possiblePeriods);
		recDom = [inf(dom); sup(dom) - myPeriod];
	        testfunc = simplifysafe(func(x + myPeriod)/func - 1);

		if (0 in recDom) then t = 0 else t = ~((2 * inf(recDom) + sup(recDom)) / 3);
	        y = evaluate(testfunc, t);

		if (!(y in [-target, target])) then {
		   if (func(t) == 0) then {
		      t = ~(inf(recDom) + myPeriod / 3);
		      y = evaluate(testfunc, t);
		   };
		};

	        if (y in [-target, target]) then {

	  	     zerosUpperRaw = mydirtyfindzeros(testfunc + target, recDom);
	  	     zerosLowerRaw = mydirtyfindzeros(testfunc - target, recDom);

		     zerosUpper = [||];
		     for z in zerosUpperRaw do {
		     	 if (!(func(z + myPeriod) == func(z))) then {
			    zerosUpper = z .: zerosUpper;
			 };
		     };

		     zerosLower = [||];
		     for z in zerosLowerRaw do {
		     	 if (!(func(z + myPeriod) == func(z))) then {
			    zerosLower = z .: zerosLower;
			 };
		     };

		     if ((zerosUpper == [||]) && (zerosLower == [||])) then {
		     	okay = true;
		     };
		};
	  };

	  if (okay) then {
	     result.okay = true;
	     result.period = myPeriod;
	  };

	  return result;
};

procedure checkSterbenzConditionForPeriodicArgRed(dom, c, period) {
	  var domMinusCOverPeriod;
	  var kRange, k;
	  var res;
	  var alphaRange;
	  var actualA, actualB, actualDom;
	  var actualExpoDom, possibleExpoDom;

	  /* Given k = nearestint((x - c)/p), we have to check if 

	     1/2 <= abs(x) / abs(p * k) <= 2

	     or k = 0

	     for all x in dom.

	  */

	  res = false;

	  domMinusCOverPeriod = (dom - c) / period;
	  kRange = nearestint(domMinusCOverPeriod);

	  if (inf(kRange) == sup(kRange)) then {
	     k = inf(kRange);
	     if (k == 0) then {
	     	res = true;
	     } else {
	        alphaRange = abs(dom) / abs(k * period);
		res = (alphaRange in [1/2;2]);
	     };
	  } else {
	     res = false;
	     if (!(0 in kRange)) then {
	        alphaRange = abs(dom) / abs(kRange * period);
		res = (alphaRange in [1/2;2]);
	     };
	     if (!res) then {
	         if (sup(kRange) - inf(kRange) <= 10) then {
	           res = true;
	           for k from inf(kRange) to sup(kRange) do {
		       if (k != 0) then {
	       	           if (period >= 0) then {
		              actualA := period * (k - 1/2) + c;
		              actualB := period * (k + 1/2) + c;
		           } else {
		              actualA := period * (k + 1/2) + c;
		              actualB := period * (k - 1/2) + c;
		           };
		           actualA = max(inf(dom), actualA);
		           actualB = min(sup(dom), actualB);
		           if (actualA <= actualB) then {
		       	      actualDom = [actualA; actualB];
			      currRes = (inf(abs(actualDom)) >= 1/2 * abs(k * period)) && 
                                        (sup(abs(actualDom)) <= 2 * abs(k * period));
		              if ((!currRes) && (!(0 in actualDom))) then {
			          actualExpoDom = floor(log2(abs(actualDom)));
				  possibleExpoDom = [floor(log2(abs(k * period))) - 1, floor(log2(abs(k * period))) + 1];
				  currRes = actualExpoDom in possibleExpoDom;
			      };
			      res = res && currRes;  
		           };
                       };
	           };
	         } else {
	            res = (checkSterbenzConditionForPeriodicArgRed([inf(dom); mid(dom)], c, period)
		           && checkSterbenzConditionForPeriodicArgRed([mid(dom); sup(dom)], c, period));
	         };
	      };
	  };
	  
	  return res;
};

procedure computePeriodicArgumentReductionErrorAmplification(dom, c, period, xFormat) {
   var alpha;
   var kRange;
   var k;
   var pK, pKRounded, delta, currAlpha;
   var hardK;

   kRange = nearestint((dom - c)/period);
   alpha = 0;	
   hardK = inf(kRange);
   for k from inf(kRange) to sup(kRange) do {
       if (k != 0) then {
       	  pK = period * k;
	  pKRounded = round(~pK,xFormat,RN);
	  delta = pKRounded - pK;
	  currAlpha := abs((-pK)/delta);
	  if (currAlpha > alpha) then {
	     alpha = currAlpha;
	     hardK = k;
	  };
       };
   };

   if (!(alpha == alpha)) then {
      alpha = infty;
   };

   return { .alpha = alpha, .hardK = k };
};

procedure constantIsRepresentableOnDoubleExpansion(c) {
	  var res;

	  res = { .representable = false };

	  if (D(c) - c == 0) then {
	     res = { .representable = true, .format = D };
	  } else {
	     if (DD(c) - c == 0) then {
	     	res = { .representable = true, .format = DD };
	     } else {
	        if (TD(c) - c == 0) then {
	     	   res = { .representable = true, .format = TD };
	     	};
	     };
	  };

	  return res;
};

procedure tryImplementArgumentReductionCodePeriodic(dom, period, c, inputFormat, argRedConstantFormat, reducedArgFormat, outputFormat, haveSterbenzOnArgRed, 
	  		                            reducedFunctionName, implementationFile, functionName) {
    var res;
    var roundedPeriod;
    var epsSubstr;
    var variableDecls, codeDecls, poundDefineDecls;
    var okay;
    var oldDisplay;

    res = { .okay = false };
    okay = true;    
    roundedPeriod = round(~period, argRedConstantFormat, RN);
    res.epsConst = abs(roundedPeriod/period - 1);
    if (haveSterbenzOnArgRed) then {
       epsSubstr = 0;
    } else {
       epsSubstr = infty;
    };
    poundDefineDecls = "";
    variableDecls = "";
    codeDecls = "";

    /* Generate the variable declarations and the code for the argument reduction */
    oldDisplay = display;
    display = decimal!;
    poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_shifter 6755399441055744.0\n"; 
    if (D(c) != 0) then poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_center " @  D(c) @ "\n"; 
    poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_recpr " @  D(1/period) @ "\n"; 
    match (argRedConstantFormat) with
          D  : { poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_hi " @  D(-roundedPeriod) @ "\n"; }
	  DD : { poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_hi " @  D(-roundedPeriod) @ "\n"; 
                 poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_mi " @  D(-roundedPeriod - D(-roundedPeriod)) @ "\n"; 
	       }
          TD : { poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_hi " @  D(-roundedPeriod) @ "\n"; 
                 poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_mi " @  D(-roundedPeriod - D(-roundedPeriod)) @ "\n"; 
                 poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_lo " @  D(-roundedPeriod - (D(-roundedPeriod) + D(-roundedPeriod - D(-roundedPeriod)))) @ "\n"; 
               };
    display = oldDisplay!;

    variableDecls = variableDecls @ "double t, s, k;\n";
    if (D(c) != 0) then {
       codeDecls = codeDecls @ "t = " @ functionName @ "_period_recpr * (xh - " @ functionName @ "_center);\n";
    } else {
       codeDecls = codeDecls @ "t = " @ functionName @ "_period_recpr * xh;\n";
    };
    codeDecls = codeDecls @ "s = " @ functionName @ "_shifter + t;\n";
    codeDecls = codeDecls @ "k = s - " @ functionName @ "_shifter;\n";
    
    match (inputFormat) with 
          D  : {
			match (argRedConstantFormat) with 
			      D  : {
					match (reducedArgFormat) with 
					      D  : {
							codeDecls = codeDecls @ "MulAdd1111(&rh, xh, k, " @ functionName @ "_period_hi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
					      	   }
					      DD : {
							codeDecls = codeDecls @ "MulAdd1112(&rh, &rm, xh, k, " @ functionName @ "_period_hi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104; 
					      	   }
					      TD : {
							codeDecls = codeDecls @ "MulAdd1113(&rh, &rm, &rl, xh, k, " @ functionName @ "_period_hi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150; 
					      	   };
			      	   }
			      DD : {
					match (reducedArgFormat) with 
					      D  : {
							codeDecls = codeDecls @ "MulAdd1121(&rh, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
					      	   }
					      DD : {
							codeDecls = codeDecls @ "MulAdd1122(&rh, &rm, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104; 
					      	   }
					      TD : {
							codeDecls = codeDecls @ "MulAdd1123(&rh, &rm, &rl, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150; 
					      	   };
			      	   }
			      TD : {
					match (reducedArgFormat) with 
					      D  : {
							codeDecls = codeDecls @ "MulAdd1131(&rh, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
					      	   }
					      DD : {
							codeDecls = codeDecls @ "MulAdd1132(&rh, &rm, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104; 
					      	   }
					      TD : {
							codeDecls = codeDecls @ "MulAdd1133(&rh, &rm, &rl, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150; 
					      	   };
			      	   };
	       }
          DD : {
			match (argRedConstantFormat) with 
			      D  : {
					match (reducedArgFormat) with 
					      D  : {
							codeDecls = codeDecls @ "MulAdd2111(&rh, xh, xm, k, " @ functionName @ "_period_hi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
					      	   }
					      DD : {
							codeDecls = codeDecls @ "MulAdd2112(&rh, &rm, xh, xm, k, " @ functionName @ "_period_hi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104; 
					      	   }
					      TD : {
							codeDecls = codeDecls @ "MulAdd2113(&rh, &rm, &rl, xh, xm, k, " @ functionName @ "_period_hi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150; 
					      	   };
			      	   }
			      DD : {
					match (reducedArgFormat) with 
					      D  : {
							codeDecls = codeDecls @ "MulAdd2121(&rh, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
					      	   }
					      DD : {
							codeDecls = codeDecls @ "MulAdd2122(&rh, &rm, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104; 
					      	   }
					      TD : {
							codeDecls = codeDecls @ "MulAdd2123(&rh, &rm, &rl, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150; 
					      	   };
			      	   }
			      TD : {
					match (reducedArgFormat) with 
					      D  : {
							codeDecls = codeDecls @ "MulAdd2131(&rh, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
					      	   }
					      DD : {
							codeDecls = codeDecls @ "MulAdd2132(&rh, &rm, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104; 
					      	   }
					      TD : {
							codeDecls = codeDecls @ "MulAdd2133(&rh, &rm, &rl, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150; 
					      	   };
			      	   };
	       }
          TD : {
			match (argRedConstantFormat) with 
			      D  : {
					match (reducedArgFormat) with 
					      D  : {
							codeDecls = codeDecls @ "MulAdd3111(&rh, xh, xm, xl, k, " @ functionName @ "_period_hi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
					      	   }
					      DD : {
							codeDecls = codeDecls @ "MulAdd3112(&rh, &rm, xh, xm, xl, k, " @ functionName @ "_period_hi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104; 
					      	   }
					      TD : {
							codeDecls = codeDecls @ "MulAdd3113(&rh, &rm, &rl, xh, xm, xl, k, " @ functionName @ "_period_hi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150; 
					      	   };
			      	   }
			      DD : {
					match (reducedArgFormat) with 
					      D  : {
							codeDecls = codeDecls @ "MulAdd3121(&rh, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
					      	   }
					      DD : {
							codeDecls = codeDecls @ "MulAdd3122(&rh, &rm, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104; 
					      	   }
					      TD : {
							codeDecls = codeDecls @ "MulAdd3123(&rh, &rm, &rl, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150; 
					      	   };
			      	   }
			      TD : {
					match (reducedArgFormat) with 
					      D  : {
							codeDecls = codeDecls @ "MulAdd3131(&rh, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
					      	   }
					      DD : {
							codeDecls = codeDecls @ "MulAdd3132(&rh, &rm, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104; 
					      	   }
					      TD : {
							codeDecls = codeDecls @ "MulAdd3133(&rh, &rm, &rl, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
							if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150; 
					      	   };
			      	   };
	       };

    /* Write the pound-defines, the function header and the code to the file */
    write("\n\n",poundDefineDecls,"\n\n") >> implementationFile;
    write("void ", functionName, "(") >> implementationFile;
    match (outputFormat) with 
    	  D  : {
	          write("double *res_resh, ") >> implementationFile;
	       } 
    	  DD : {
	          write("double *res_resh, double *res_resm, ") >> implementationFile;
	       } 
    	  TD : {
	          write("double *res_resh, double *res_resm, double *res_resl, ") >> implementationFile;
	       };
    match (inputFormat) with 
          D  : {
                  write("double xh") >> implementationFile;
	       }
          DD : {
                  write("double xh, double xm") >> implementationFile;
	       }
          TD : {
                  write("double xh, double xm, double xl") >> implementationFile;
	       };
    write(") {\n") >> implementationFile;
    match (reducedArgFormat) with 
          D  : {
                  write("double rh;\n") >> implementationFile;
	       }
          DD : {
                  write("double rh, rm;\n") >> implementationFile;
	       }
          TD : {
                  write("double rh, rm, rl;\n") >> implementationFile;
	       };
    write(variableDecls,"\n\n",codeDecls,"\n") >> implementationFile;
    write(reducedFunctionName,"(") >> implementationFile;
    match (outputFormat) with 
    	  D  : {
	          write("res_resh, ") >> implementationFile;
	       } 
    	  DD : {
	          write("res_resh, res_resm, ") >> implementationFile;
	       } 
    	  TD : {
	          write("res_resh, res_resm, res_resl, ") >> implementationFile;
	       };
    match (reducedArgFormat) with 
          D  : {
                  write("rh") >> implementationFile;
	       }
          DD : {
                  write("rh, rm") >> implementationFile;
	       }
          TD : {
                  write("rh, rm, rl") >> implementationFile;
	       };
    write(");\n}\n\n") >> implementationFile;	 
    
    /* Return the status */
    res.epsSubstr = epsSubstr;
    if (okay) then {
       res.okay = true;
    };

    return res;					    
};

procedure computeReducedDomainAndMidpointCasesPeriodic(func, dom, c, p, xFormat) {
	  var midpointCases;
	  var a, b, r, t, s, k, i, ia, ib, td, xt, tpl, xtp;

	  /* We have to compute the image domain of the 
	     argument reduction 

	      r = x - p * nearestint((x - c) / p)

	     for x in dom a floating-point value of format xFormat.

	     For that image domain, we must not account for midpoint 
	     cases but put them in an extra list.

	     We start by analyzing at the bounds of the original 
	     domain.
	     
	  */
	  midpointCases = [||];

	  s = round(inf(dom),xFormat,RU);
	  t = (s - c) / p;
	  k = nearestint(t);
	  if (abs(k - t) == 1/2) then {
	     midpointCases = s .: midpointCases;
	     s = round(inf(dom) + 1b-2000,xFormat,RU);
	     t = (s - c) / p;
	     k = nearestint(t);
	  };
	  r = s - p * k;
	  a = r;
	  b = r;

	  s = round(sup(dom),xFormat,RD);
	  t = (s - c) / p;
	  k = nearestint(t);
	  if (abs(k - t) == 1/2) then {
	     midpointCases = s .: midpointCases;
	     s = round(sup(dom) - 1b-2000,xFormat,RD);
	     t = (s - c) / p;
	     k = nearestint(t);
	  };
	  r = s - p * k;

	  a = min(a, r);
	  b = max(b, r);

	  /* Now go over all rounding boundaries of nearestint
	     that are possible in the domain for (x - c)/p
	  */
	  td = (dom - c) / p;
	  ia = floor(inf(td)) + 1/2;
	  while (ia < inf(td)) do ia = ia + 1;
	  ib = ceil(sup(td)) - 1/2;
	  while (ib > sup(td)) do ib = ib - 1;
	  
	  for i from ia to ib by 1 do {
	      xt = i * p + c;
	      if (xt == round(xt,xFormat,RN)) then {
	      	 midpointCases = xt .: midpointCases;
		 tpl = [| round(xt - 1b-2000, xFormat, RD), round(xt + 1b-2000, xFormat, RU) |];
	      } else {
	      	 tpl = [| round(xt, xFormat, RD), round(xt, xFormat, RU) |];
	      };

	      for xtp in tpl do {
	      	  if (xtp in dom) then {
	             t = (xtp - c) / p;
	             k = nearestint(t);
	             r = xtp - p * k;

	             a = min(a, r);
	             b = max(b, r);
		  };
	      };
	  };

	  return { .reducedDom = [a, b], .midpointCases = midpointCases };
};

procedure doWorkForTryImplementationThroughPeriodic(problemdef, parametrization) {
	  var result, res;
	  var func, dom, target, period;
	  var c, reducedDom;
	  var haveSterbenzOnArgRed, pKStaysSmall, kStaysSmall;
	  var alphaPeriodConstant, alphaPeriodConstantTemp;
	  var variableFormat;
	  var alpha;
	  var argRedTarget, reducedTarget;
	  var isRepresentablePeriod;
	  var argRedConstantTarget, argRedSubtractionTarget;
	  var argRedConstantFormat;
	  var argRedRepresentationTarget; 
	  var reducedArgFormat;
	  var myProblemdef, origDefDom, suffix;
	  var resArgRed;
	  var midpointCases;
	  var redDomMidpointCases;
	  var neededAccuracyOfArg;

	  result = { .okay = false };

          res = tryDetectPeriodicArgRed(problemdef.func, problemdef.dom, problemdef.target * 1/8, problemdef.variableFormat);

	  if (res.okay) then {
	     /* Here we know that func is periodic with period period */
	     func = problemdef.func;
	     dom = problemdef.dom;
	     target = problemdef.target * 1/8;
	     period = res.period;
	     variableFormat = problemdef.variableFormat;

	     /* Now compute a value c and a resulting 
	        reduced domain:

		r = x - p * nearestint((x - c) / p)

		where p is the period

		The reduced domain is

		reducedDom = [ c - p/2 ; c + p/2 ]

		As we want to stay in the same definition 
		domain of the function, we must choose c in
		such a way that reducedDom is included in dom.
              */
	      if (sup(dom) - inf(dom) > period) then {
	      	 if (0 in [inf(dom) + period/2; sup(dom) - period/2]) then {
		    c = 0;
		 } else {
		    if (0 in [inf(dom); inf(dom) + period/2]) then {
		       c = D(inf(dom) + period/2);
		    } else {
		      if (0 in [sup(dom) - period/2; sup(dom)]) then {
		      	 c = D(sup(dom) - period/2);
		      } else {
		      	 c = D(mid(dom));
		      };
		    };
		 };
		 reducedDom = [ c - period/2; c + period/2 ];
		 midpointCases = [||];
	
		 /* Just to be sure, we check that the reduced domain 
		    is contained in the original domain. Otherwise, we simply fail.

		    We also check if the integer nearestint((x-c)/p)) we need for
                    argument reduction does not grow too large.

		 */
		 if ((reducedDom in dom) && (sup(abs((dom - c)/period)) <= 1b13)) then {
		    /* Now check if the function has a zero in the reduced domain.
		       If yes, recompute the reduced domain to contain only
		       non-midpoint cases of argument reduction, along with a
		       list of midpoint cases.
		    */

		    if (mydirtyfindzeros(func, reducedDom) != [||]) then {
		       redDomMidpointCases = computeReducedDomainAndMidpointCasesPeriodic(func, dom, c, period, variableFormat);
		       reducedDom = redDomMidpointCases.reducedDom;
		       midpointCases = redDomMidpointCases.midpointCases;
		    };

		    /* Now we check if we have either the Sterbenz condition 
                       for the subtraction 

                          x minus p * nearestint((x - c)/p) 

                       or the certainty that 
        
                          abs(p * nearestint((x - c)/p)) <= 1/2 * abs(x)
                    */
		    haveSterbenzOnArgRed = checkSterbenzConditionForPeriodicArgRed(dom, c, period);

		    pKStaysSmall = false;
		    if (!haveSterbenzOnArgRed) then {
		       pKStaysSmall = (sup(abs(period * nearestint((dom - c)/period))) <= inf(abs(1/2 * dom)));
		    };

		    kStaysSmall = false;
		    if (!pKStaysSmall) then {
		       kStaysSmall = (sup(abs(nearestint((dom - c)/period))) < 1000);
		    };

		    if (haveSterbenzOnArgRed || pKStaysSmall || kStaysSmall) then {
		       /* Compute the factor alpha by which the function amplifies the 
		          relative error of the reduced argument into the final error due
			  to argument reduction.
		       */   		       

		       neededAccuracyOfArg = computeNeededAccuracyOfArgumentWorkHard(func, reducedDom, target);

		       alpha = abs(abs(target) / abs(neededAccuracyOfArg));
		       write("The amplification factor of the periodic function is approximately ", round(alpha,12,RN), " = 2^(", round(log2(alpha),12,RN),")\n");

		       /* Compute the target errors */
		       reducedTarget = 1/8 * target;
		       argRedTarget = 1/8 * target * 1/alpha;
		       if (haveSterbenzOnArgRed) then {
		       	  argRedConstantTarget = 1/4 * argRedTarget; 
			  argRedSubtractionTarget = 0;
			  argRedRepresentationTarget = 1/8 * argRedTarget;
		       } else {
		       	  argRedConstantTarget = 1/8 * argRedTarget; 
			  argRedSubtractionTarget = 1/8 * argRedTarget;
			  argRedRepresentationTarget = 1/8 * argRedTarget;
		       };

		       /* Check if the period is representable on a double expansion.
		         
			  If yes, we perhaps don't need to compute the amplification factor of the 
			  error in the constant.
		       */
		       isRepresentablePeriod = constantIsRepresentableOnDoubleExpansion(period);

		       /* Preset the format for the argument reduction constant (the period) */
		       argRedConstantFormat = { .determined = false };

		       /* Depending on whether the period is representable on a double expansion, 
		          compute the amplification factor that determines how much the error in the
			  stored constant is amplified.
		       */
		       if (isRepresentablePeriod.representable) then {
		       	  if (isRepresentablePeriod.format == D) then {
			     argRedConstantFormat = { .determined = true, .format = D };
			  } else {
			     /* Now, we compute the amplification factor alphaPeriodConstant
		                that amplifies the relative error in the stored constant for the period
                                with respect to the relative error of the reduced argument that gets
                                computed out of the approximate constant.
		             */
		             alphaPeriodConstantTemp = computePeriodicArgumentReductionErrorAmplification(dom, c, period, variableFormat);
		             alphaPeriodConstant = alphaPeriodConstantTemp.alpha;

		             if (1b-53 * alphaPeriodConstant <= argRedConstantTarget) then {
			     	argRedConstantFormat = { .determined = true, .format = D };
			     } else {
			        if (1b-107 * alphaPeriodConstant <= argRedConstantTarget) then {
			           argRedConstantFormat = { .determined = true, .format = DD };
			        } else {
			           if (1b-161 * alphaPeriodConstant <= argRedConstantTarget) then {
				      if (isRepresentablePeriod.format == DD) then {
                                         argRedConstantFormat = { .determined = true, .format = DD };
				      } else {
			                 argRedConstantFormat = { .determined = true, .format = TD };
			              };
			           } else {
				      argRedConstantFormat = { .determined = true, .format = isRepresentablePeriod.format };
				   };
			        };
			     };
			  };
		       } else {
			  /* Now, we compute the amplification factor alphaPeriodConstant
		             that amplifies the relative error in the stored constant for the period
                             with respect to the relative error of the reduced argument that gets
                             computed out of the approximate constant.
		          */
		          alphaPeriodConstantTemp = computePeriodicArgumentReductionErrorAmplification(dom, c, period, variableFormat);
		          alphaPeriodConstant = alphaPeriodConstantTemp.alpha;
			  
			  if (1b-53 * alphaPeriodConstant <= argRedConstantTarget) then {
			     argRedConstantFormat = { .determined = true, .format = D };
			  } else {
			     if (1b-107 * alphaPeriodConstant <= argRedConstantTarget) then {
			        argRedConstantFormat = { .determined = true, .format = DD };
			     } else {
			        if (1b-161 * alphaPeriodConstant <= argRedConstantTarget) then {
			           argRedConstantFormat = { .determined = true, .format = TD };
			        };
			     };
			  };
		       };

		       if (argRedConstantFormat.determined) then {
		       	  argRedConstantFormat = argRedConstantFormat.format;
			  write("Periodic argument reduction will store the periodic constant as a ", argRedConstantFormat, "\n");

			  /* Now determine the format the reduced
                             argument has to be in. This format
                             usually is smaller than the format used for the periodic constant and it might 
                             actually be smaller than the entering variable format. 
			 */
		         reducedArgFormat = { .determined = false };
			 
			 if (1b-53 <= argRedRepresentationTarget) then {
			    reducedArgFormat = { .determined = true, .format = D };
			 } else {
			    if (1b-107 <= argRedRepresentationTarget) then {
			       reducedArgFormat = { .determined = true, .format = DD };
			    } else {
			       if (1b-161 <= argRedRepresentationTarget) then {
			          reducedArgFormat = { .determined = true, .format = TD };
			       }; 
                            };
			 };

			 if (reducedArgFormat.determined) then {
			    reducedArgFormat = reducedArgFormat.format;
			    write("The reduced argument after periodic argument reduction will be represented on a ", reducedArgFormat, "\n");

			    /* Now try to implement the reduced function */
			    suffix = "_periodic";
                            myProblemdef.func = problemdef.func;
		            myProblemdef.dom = reducedDom;
		            myProblemdef.target = reducedTarget;
		            myProblemdef.variableFormat = reducedArgFormat;
		            origDefDom = problemdef.dom;
		            match (problemdef) with { .definitionDomain = default } : {
		                                      if (origDefDom in problemdef.definitionDomain) then {
                                                          origDefDom = problemdef.definitionDomain;
                                                      }; }
                                                    default : {};
		            myProblemdef.definitionDomain = origDefDom;
		            myParametrization = parametrization;
		            myParametrization.functionBasename = parametrization.functionBasename @ suffix;
		            myParametrization.doNotPerformPeriodicArgRed = true;
			    myParametrization.minWidth = (sup(reducedDom) - inf(reducedDom)) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
                            myParametrization.argumentReduced = true;

		            write("Trying to implement the function on the reduced argument domain ", reducedDom, "\n");
		            res = tryImplementation(myProblemdef, myParametrization);

 		            if (res.okay) then {
			       write("Implementation of the function on the reduced domain was successful. Trying to implement the argument reduction.\n");
			       resArgRed = tryImplementArgumentReductionCodePeriodic(dom, period, c, variableFormat, argRedConstantFormat, reducedArgFormat, res.outputformat, haveSterbenzOnArgRed, 
			                                                             res.functionname, parametrization.implementationFile, parametrization.functionBasename);
			    
			       if (resArgRed.okay) then {
	                          result.okay = true;
	                          result.approxerr = res.approxerr;
	                          result.implErr = (1 + problemdef.target * 1/8) * (1 + alpha * alphaPeriodConstant * resArgRed.epsConst + 
                                                                                        alpha * resArgRed.epsSubstr + 
                                                                                        alpha * alphaPeriodConstant * resArgRed.epsConst * resArgRed.epsSubstr) - 1;
	                          result.outputformat = res.outputformat;
	                          result.functionname = parametrization.functionBasename;
	                       };
			    };
			 };
		       };
		    };
		 };
	      };
	  };

	  return result;
};

procedure tryImplementationThroughArgumentReductionPeriodic(problemdef, parametrization) {
	  var result, needArgumentReduction, res, doNotPerformPeriodicArgRed;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default,
				       .tableIndexWidth = default,
				       .metaSplitMinWidth = default } } : {

				       /* Test if we may perform this type of argument
				          reduction
				       */
				       doNotPerformPeriodicArgRed = false;
				       match (parametrization) with
				             { .doNotPerformPeriodicArgRed = true } : { doNotPerformPeriodicArgRed = true; }
					     default : { };

				       if (!doNotPerformPeriodicArgRed) then {
				           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
					      polynomial degree
				           */
				           needArgumentReduction = true;
				           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                                   if (res.okay) then {
   	                                       if (res.sufficientDegree) then needArgumentReduction = false;
				           } else {
				               needArgumentReduction = false;
				           };

				           if (needArgumentReduction) then {
					      result = doWorkForTryImplementationThroughPeriodic(problemdef, parametrization);
				           };
				         };
				     }
                default : { };

	  return result;
};


procedure formatToExpansionLength(format) {
	  return match (format) with
                  D       : (1)
		  DD      : (2)
                  TD      : (3)
                  default : (error);
};

procedure expansionLengthToFormat(expans) {
	  return [| D, DD, TD |][expans - 1];
};

procedure doWorkForTryImplementationThroughExpressionDecompositionAddition(f, g, h, problemdef, parametrization) {
	  var result;
	  var maxeps, dom;
	  var maxepsAdd, maxepsG, maxepsH, alphaG, alphaH;

	  result = { .okay = false };

	  /* Get the target error bound and the domain for g and h */
	  maxeps = abs(problemdef.target);
	  dom = problemdef.dom;

	  /* Cut the target error into pieces */
	  maxepsAdd = 1/3 * maxeps;
	  
	  alphaG = mydirtyinfnorm(g / (g + h),dom);
	  alphaH = mydirtyinfnorm(h / (g + h),dom);	  
	  
	  "alphaG = ", alphaG;
	  "alphaH = ", alphaH;

	  /* TODO */


	  return result;
};



procedure doWorkForTryImplementationThroughExpressionDecompositionMultiplication(f, g, h, problemdef, parametrization) {
	  var result;
	  var maxeps, dom, maxepsG, maxepsH, maxepsMul;
	  var myProblemdef, suffix, origDefDom, myParametrization, res, res2;
	  var finalOutputFormat;
	  var implementationcode;

	  result = { .okay = false };

	  /* Get the target error bound and the domain for g and h */
	  maxeps = abs(problemdef.target);
	  dom = problemdef.dom;

	  /* Cut the target error into pieces */
	  maxepsG = 1/4 * maxeps;
	  maxepsH = 1/4 * maxeps;
	  maxepsMul = 1/4 * maxeps;

	  /* Say that we are going to decompose f into g and h */
	  write("Expression decomposition detected that the function can be split into f = g(x) * h(x) with\n");
	  write("    g(x) = ", g, " on domain ", dom, " and\n");
	  write("    h(x) = ", h, " on domain ", dom, "\n");
	  
	  /* Try to implement g */
	  myProblemdef.func = g;
	  myProblemdef.dom = dom;
	  myProblemdef.target = maxepsG;
	  myProblemdef.variableFormat = problemdef.variableFormat;
	  suffix = "_expr_decomp_prod_g";
	  origDefDom = problemdef.dom;
	  match (problemdef) with { .definitionDomain = default } : {
	                               if (origDefDom in problemdef.definitionDomain) then {
                                          origDefDom = problemdef.definitionDomain;
                                       }; }
                                  default : {};
	  myProblemdef.definitionDomain = origDefDom;
	  myParametrization = parametrization;
	  myParametrization.performExpressionDecomposition = max(parametrization.performExpressionDecomposition - 1, 0);
	  myParametrization.gappaFile = parametrization.gappaFile @ suffix;
	  myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
	  myParametrization.functionBasename = parametrization.functionBasename @ suffix;

	  res = tryImplementation(myProblemdef, myParametrization);

	  if (res.okay) then {
	  	write("Implementation of subfunction g successful, now trying to implement h\n");

	        myProblemdef.func = h;
	     	myProblemdef.dom = dom;
	     	myProblemdef.target = maxepsH;
	     	myProblemdef.variableFormat = problemdef.variableFormat;
	     	suffix = "_expr_decomp_prod_h";
	     	myProblemdef.definitionDomain = origDefDom;
	     	myParametrization = parametrization;
	        myParametrization.performExpressionDecomposition = max(parametrization.performExpressionDecomposition - 1, 0);
	     	myParametrization.gappaFile = parametrization.gappaFile @ suffix;
	     	myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
	     	myParametrization.functionBasename = parametrization.functionBasename @ suffix;
             	myParametrization.implementationFile = parametrization.implementationFile @ "_expr_decomp_prod_subfunction_g"; 

	     	res2 = tryImplementation(myProblemdef, myParametrization);

		if (res2.okay) then {
		   write("Implementation of subfunction h successful\n");
		   bashexecute("cat " @ parametrization.implementationFile @ "_expr_decomp_prod_subfunction_g >> " @ parametrization.implementationFile);		   
		   bashexecute("rm " @ parametrization.implementationFile @ "_expr_decomp_prod_subfunction_g");
		   write("Generating multiplication code\n");

		   if (maxepsMul < 1b-102) then finalOutputFormat = TD else
		    if (maxepsMul < 1b-53) then finalOutputFormat = DD else
		     finalOutputFormat = D;
		   
		   finalOutputFormat = expansionLengthToFormat(max(formatToExpansionLength(finalOutputFormat),
							           formatToExpansionLength(res.outputformat),
							           formatToExpansionLength(res2.outputformat)));
		   		    
		   implementationcode = "\n";
		   implementationcode = implementationcode @ "void " @ parametrization.functionBasename @ "(";
		   implementationcode = implementationcode @ (match finalOutputFormat with
		   			    		       	 	D  : ( "double *res_resh, " )
		   							DD : ( "double *res_resh, double *res_resm, " )
		   							TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
		   implementationcode = implementationcode @ (match problemdef.variableFormat with
		   			    		       	 	D  : ( "double xh" )
		   							DD : ( "double xh, double xm" )
		   							TD : ( "double xh, double xm, double xl"));
		   implementationcode = implementationcode @ ") {\n";
		   match (res.outputformat) with
		   	     D  : {
		   			implementationcode = implementationcode @ "double res_g_resh;\n";
		   	     	  }
		   	     DD : {
		   			implementationcode = implementationcode @ "double res_g_resh;\n";
		   			implementationcode = implementationcode @ "double res_g_resm;\n";
		   	     	  }
		   	     TD : {
		   			implementationcode = implementationcode @ "double res_g_resh;\n";
		   			implementationcode = implementationcode @ "double res_g_resm;\n";
		   			implementationcode = implementationcode @ "double res_g_resl;\n";
		   	     	  };
		   match (res2.outputformat) with
		   	     D  : {
		   			implementationcode = implementationcode @ "double res_h_resh;\n";
		   	     	  }
		   	     DD : {
		   			implementationcode = implementationcode @ "double res_h_resh;\n";
		   			implementationcode = implementationcode @ "double res_h_resm;\n";
		   	     	  }
		   	     TD : {
		   			implementationcode = implementationcode @ "double res_h_resh;\n";
		   			implementationcode = implementationcode @ "double res_h_resm;\n";
		   			implementationcode = implementationcode @ "double res_h_resl;\n";
		   	     	  };
		   implementationcode = implementationcode @ "\n";
		   implementationcode = implementationcode @ res.functionname @ "(";
		   implementationcode = implementationcode @ (match (res.outputformat) with
		   			    		       	 	D  : ( "&res_g_resh, " )
		   							DD : ( "&res_g_resh, &res_g_resm, " )
		   							TD : ( "&res_g_resh, &res_g_resm, &res_g_resl, "));
		   implementationcode = implementationcode @ (match (problemdef.variableFormat) with
		   			    		       	 	D  : ( "xh" )
		   							DD : ( "xh, xm" )
		   							TD : ( "xh, xm, xl" ));
		   implementationcode = implementationcode @ ");\n";
                   implementationcode = implementationcode @ res2.functionname @ "(";
		   implementationcode = implementationcode @ (match (res2.outputformat) with
		   			    		       	 	D  : ( "&res_h_resh, " )
		   							DD : ( "&res_h_resh, &res_h_resm, " )
		   							TD : ( "&res_h_resh, &res_h_resm, &res_h_resl, "));
		   implementationcode = implementationcode @ (match (problemdef.variableFormat) with
		   			    		       	 	D  : ( "xh" )
		   							DD : ( "xh, xm" )
		   							TD : ( "xh, xm, xl" ));
		   implementationcode = implementationcode @ ");\n";
		   match (finalOutputFormat) with
		   	     D  : {
		   			implementationcode = implementationcode @ "*res_resh = res_g_resh * res_h_resh;\n";
                              }
		         DD : {
		   			match (res.outputformat) with
		   			      D  : {
		   					implementationcode = implementationcode @ "Mul122(res_resh,res_resm,res_g_resh,res_h_resh,res_h_resm);\n";
		   			      	   }
		   		              DD : {
		   					match (res2.outputformat) with
		   					      D  : {
		   					      	        implementationcode = implementationcode @ "Mul122(res_resh,res_resm,res_h_resh,res_g_resh,res_g_resm);\n";
		   						   }
		   				              DD : {
		   					                implementationcode = implementationcode @ "Mul22(res_resh,res_resm,res_g_resh,res_g_resm,res_h_resh,res_h_resm);\n";
		   						   };
		   			      	   };
		   	          }
		   	     TD : {
		   			match (res.outputformat) with
		   			      D  : {
		   			      		implementationcode = implementationcode @ "Mul133(res_resh,res_resm,res_resl,res_g_resh,res_h_resh,res_h_resm,res_h_resl);\n";
		   			      	   }
		   			      DD : {
		   			      		implementationcode = implementationcode @ "Mul233(res_resh,res_resm,res_resl,res_g_resh,res_g_resm,res_h_resh,res_h_resm,res_h_resl);\n";
		   			      	   }
		   			      TD : {
		   					match (res2.outputformat) with
		   					      D  : {
		   					      	        implementationcode = implementationcode @ "Mul133(res_resh,res_resm,res_resl,res_h_resh,res_g_resh,res_g_resm,res_g_resl);\n";
		   					      	   }
		   					      DD : {
		   					      	        implementationcode = implementationcode @ "Mul233(res_resh,res_resm,res_resl,res_h_resh,res_h_resm,res_g_resh,res_g_resm,res_g_resl);\n";
		   					      	   }
		   					      TD : {
		   					      	        implementationcode = implementationcode @ "Mul33(res_resh,res_resm,res_resl,res_h_resh,res_h_resm,res_h_resl,res_g_resh,res_g_resm,res_g_resl);\n";
		   					      	   };
		   			      	   };
		   	     	  };
		   implementationcode = implementationcode @ "}\n";
		   write(implementationcode) >> parametrization.implementationFile;
		   result.okay = true;
		   result.outputformat = finalOutputFormat;
		   result.functionname = parametrization.functionBasename;
		   // TODO Add error bounds
		};	  
	  };

	  return result;
};

procedure doWorkForTryImplementationThroughExpressionDecompositionComposition(f, g, h, problemdef, parametrization) {
	  var result;
	  var domG, domH;
	  var maxepsG, maxepsH, maxeps;
	  var myProblemdef, suffix, origDefDom, myParametrization, res, res2;

	  result = { .okay = false };

	  /* Get the target error bound, get the domain for h */
	  maxeps = abs(problemdef.target);
	  domH = problemdef.dom;

	  /* Compute the domain for g */
	  domG = dirtyEvaluateImage(h,domH);

	  /* Compute the accuracy needed for h in order to stay within the target error bound 
	     after the amplification of the error by g 
	  */
	  maxepsH = abs(computeNeededAccuracyOfArgumentWorkHard(g,domG,3/8 * maxeps));
	  maxepsG = 3/8 * maxeps;

	  /* Check if we can theoretically do both error bounds */
	  if ((maxepsH > 1b-157) && (maxepsG > 1b-157)) then {
	     write("Expression decomposition detected that the function can be split into f = g(h(x)) with\n");
	     write("    g(x) = ", g, " on domain ", domG, " with rel. err. bounded by 2^(",~log2(maxepsG),") and\n");
	     write("    h(x) = ", h, " on domain ", domH, " with rel. err. bounded by 2^(",~log2(maxepsH),")\n");

	     write("Trying to implement h\n");
	     myProblemdef.func = h;
	     myProblemdef.dom = domH;
	     myProblemdef.target = maxepsH;
	     myProblemdef.variableFormat = problemdef.variableFormat;
	     suffix = "_expr_decomp_h";
	     origDefDom = problemdef.dom;
	     match (problemdef) with { .definitionDomain = default } : {
	                                  if (origDefDom in problemdef.definitionDomain) then {
                                             origDefDom = problemdef.definitionDomain;
                                          }; }
                                     default : {};
	     myProblemdef.definitionDomain = origDefDom;
	     myParametrization = parametrization;
	     myParametrization.performExpressionDecomposition = max(parametrization.performExpressionDecomposition - 1, 0);
	     myParametrization.gappaFile = parametrization.gappaFile @ suffix;
	     myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
	     myParametrization.functionBasename = parametrization.functionBasename @ suffix;

	     res = tryImplementation(myProblemdef, myParametrization);

	     if (res.okay) then {
	     	write("Implementation of subfunction h successful, now trying to implement g\n");
					    
	        myProblemdef.func = g;
	     	myProblemdef.dom = domG;
	     	myProblemdef.target = maxepsG;
	     	myProblemdef.variableFormat = res.outputformat;
	     	suffix = "_expr_decomp_g";
	     	myProblemdef.definitionDomain = domG;
	     	myParametrization = parametrization;
	        myParametrization.performExpressionDecomposition = max(parametrization.performExpressionDecomposition - 1, 0);
	     	myParametrization.gappaFile = parametrization.gappaFile @ suffix;
	     	myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
	     	myParametrization.functionBasename = parametrization.functionBasename @ suffix;
             	myParametrization.implementationFile = parametrization.implementationFile @ "_expr_decomp_subfunction_g"; 

	     	res2 = tryImplementation(myProblemdef, myParametrization);

		if (res2.okay) then {
		   write("Implementation of subfunction g successful\n");
		   bashexecute("cat " @ parametrization.implementationFile @ "_expr_decomp_subfunction_g >> " @ parametrization.implementationFile);		   
		   bashexecute("rm " @ parametrization.implementationFile @ "_expr_decomp_subfunction_g"); 
		   write("Generating composition code\n");

		   implementationcode = "\n";
		   implementationcode = implementationcode @ "void " @ parametrization.functionBasename @ "(";
		   implementationcode = implementationcode @ (match res2.outputformat with
		   			    		       	 	D  : ( "double *res_resh, " )
		   							DD : ( "double *res_resh, double *res_resm, " )
		   							TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
		   implementationcode = implementationcode @ (match problemdef.variableFormat with
		   			    		       	 	D  : ( "double xh" )
		   							DD : ( "double xh, double xm" )
		   							TD : ( "double xh, double xm, double xl"));
		   implementationcode = implementationcode @ ") {\n";
		   implementationcode = implementationcode @ (match res.outputformat with
		   			    		       	 	D  : ( "double res_h_resh;\n" )
		   							DD : ( "double res_h_resh, res_h_resm;\n" )
		   							TD : ( "double res_h_resh, res_h_resm, res_h_resl;\n" ));
		   implementationcode = implementationcode @ "\n";
		   
		   implementationcode = implementationcode @ res.functionname @ "(";
		   implementationcode = implementationcode @ (match res.outputformat with
		   			    		       	 	D  : ( "&res_h_resh, " )
		   							DD : ( "&res_h_resh, &res_h_resm, " )
		   							TD : ( "&res_h_resh, &res_h_resm, &res_h_resl, " ));							
		   implementationcode = implementationcode @ (match problemdef.variableFormat with
		   			    		       	 	D  : ( "xh" )
		   							DD : ( "xh, xm" )
		   							TD : ( "xh, xm, xl"));
		   implementationcode = implementationcode @ ");\n";

		   implementationcode = implementationcode @ res2.functionname @ "(";
		   implementationcode = implementationcode @ (match res2.outputformat with
		   			    		       	 	D  : ( "res_resh, " )
		   							DD : ( "res_resh, res_resm, " )
		   							TD : ( "res_resh, res_resm, res_resl, " ));
		   implementationcode = implementationcode @ (match res.outputformat with
		   			    		       	 	D  : ( "res_h_resh" )
		   							DD : ( "res_h_resh, res_h_resm" )
		   							TD : ( "res_h_resh, res_h_resm, res_h_resl" ));							
		   implementationcode = implementationcode @ ");\n";									

		   implementationcode = implementationcode @ "}\n\n";

		   write(implementationcode) >> parametrization.implementationFile;		   		   
                   result.okay = true;
		   result.outputformat = res2.outputformat;
		   result.functionname = parametrization.functionBasename;
		   // TODO: add error bounds
		};
	     };
	  };

	  return result;
};

procedure doWorkForTryImplementationThroughExpressionDecomposition(problemdef, parametrization) {
	  var result, func;

	  result = { .okay = false };

	  func = problemdef.func;

	  match (func) with 
	  	g + h  : {
				/* Make sure that neither g nor h is a stupid constant */
				if ((degree(g) != 0) && (degree(h) != 0)) then {
				   result = doWorkForTryImplementationThroughExpressionDecompositionAddition(func, g, h, problemdef, parametrization);
				};
		         }
                g * h  : {
				result = doWorkForTryImplementationThroughExpressionDecompositionMultiplication(func, g, h, problemdef, parametrization);
		      	 } 
                g ^ h  : {
                                /* Make sure that g is just a constant and h is neither a constant nor just x */
				if ((degree(g) == 0) && (!(degree(h) in [0;1]))) then {
				   result = doWorkForTryImplementationThroughExpressionDecompositionComposition(func, g^x, h, problemdef, parametrization);
				};
                         }
                g(h)   : {
				/* Make sure that h is neither a constant nor just x */
				if (!(degree(h) in [0;1])) then {
				   result = doWorkForTryImplementationThroughExpressionDecompositionComposition(func, g, h, problemdef, parametrization);
				};
		      	 }
                default: {
			 };

	  return result;
};

procedure tryImplementationThroughExpressionDecomposition(problemdef, parametrization) {
	  var result, needArgumentReduction, res, performExpressionDecompositionLevel;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default,
				       .tableIndexWidth = default,
				       .metaSplitMinWidth = default } } : {

				       /* Test if we may perform this type of argument
				          reduction
				       */
				       performExpressionDecompositionLevel = 0;
				       match (parametrization) with
				             { .performExpressionDecomposition = a } : { performExpressionDecompositionLevel = a; }
					     default : { };

				       if (performExpressionDecompositionLevel > 0) then {
				           /* Start with a test if the domain actually needs
                                              decomposition or argument reduction in order to stay below the maximum
					      polynomial degree
				           */
				           needArgumentReduction = true;
				           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                                   if (res.okay) then {
   	                                       if (res.sufficientDegree) then needArgumentReduction = false;
				           } else {
				               needArgumentReduction = false;
				           };

				           if (needArgumentReduction) then {
					      result = doWorkForTryImplementationThroughExpressionDecomposition(problemdef, parametrization);
				           };
				         };
				     }
                default : { };

	  return result;
};

procedure tryImplementation(problemdef, parametrization) {
	  var result, res, tryImplementationInstance, tryImplementationChoices;
	  var okay, i;
	  var needArgumentReduction, argumentAlreadyReduced;
	  var showMethodName;

	  showMethodName = true;

	  result = { .okay = false };

	  write("Trying to implement ", problemdef.func, " on ", problemdef.dom, "\n");

	  needArgumentReduction = true;
	  res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	  if (res.okay) then {
   	      if (res.sufficientDegree) then needArgumentReduction = false;
	  } else {
	      needArgumentReduction = true;
	  };

	  argumentAlreadyReduced = false;
	  match (parametrization) with 
	  	{ .argumentReduced = true } : { argumentAlreadyReduced = true; }
                default : { };

	  if (needArgumentReduction) then {
	       if (argumentAlreadyReduced) then {
	           tryImplementationChoices = [| { .method = tryImplementationThroughExpressionDecomposition, .name = "tryImplementationThroughExpressionDecomposition" },
                                                 { .method = tryImplementationConstant, .name = "tryImplementationConstant" },
	                                         { .method = tryImplementationThroughArgumentReductionPowering, .name = "tryImplementationThroughArgumentReductionPowering" },
		     	    		         { .method = tryImplementationThroughArgumentReductionLogarithm, .name = "tryImplementationThroughArgumentReductionLogarithm" },
	                                         { .method = tryImplementationThroughArgumentReductionExponential, .name = "tryImplementationThroughArgumentReductionExponential" },
					         { .method = tryImplementationThroughArgumentReductionPeriodic, .name = "tryImplementationThroughArgumentReductionPeriodic" },
                                                 { .method = tryImplementationThroughArgumentReductionWithParamountBehavior, .name = "tryImplementationThroughArgumentReductionWithParamountBehavior" },
					         { .method = tryImplementationThroughSquaring, .name = "tryImplementationThroughSquaring" },
                                                 { .method = tryImplementationThroughDomainSplitting, .name = "tryImplementationThroughDomainSplitting" },
                                                 { .method = tryImplementationThroughSymmetryDetectionAroundZero, .name = "tryImplementationThroughSymmetryDetectionAroundZero" },
					         { .method = tryImplementationThroughMetaSplitting, .name = "tryImplementationThroughMetaSplitting" } |];
	       } else {
	           tryImplementationChoices = [| { .method = tryImplementationThroughExpressionDecomposition, .name = "tryImplementationThroughExpressionDecomposition" },
                                                 { .method = tryImplementationConstant, .name = "tryImplementationConstant" },
	                                         { .method = tryImplementationThroughArgumentReductionPowering, .name = "tryImplementationThroughArgumentReductionPowering" },
		     	    		         { .method = tryImplementationThroughArgumentReductionLogarithm, .name = "tryImplementationThroughArgumentReductionLogarithm" },
	                                         { .method = tryImplementationThroughArgumentReductionExponential, .name = "tryImplementationThroughArgumentReductionExponential" },
					         { .method = tryImplementationThroughArgumentReductionPeriodic, .name = "tryImplementationThroughArgumentReductionPeriodic" },
                                                 { .method = tryImplementationThroughArgumentReductionWithParamountBehavior, .name = "tryImplementationThroughArgumentReductionWithParamountBehavior" },
					         { .method = tryImplementationThroughSquaring, .name = "tryImplementationThroughSquaring" },
                                                 { .method = tryImplementationThroughSymmetryDetectionAroundZero, .name = "tryImplementationThroughSymmetryDetectionAroundZero" },
                                                 { .method = tryImplementationThroughDomainSplitting, .name = "tryImplementationThroughDomainSplitting" },
					         { .method = tryImplementationThroughMetaSplitting, .name = "tryImplementationThroughMetaSplitting" } |];
               };
	  } else {
	       tryImplementationChoices = [| { .method = tryImplementationThroughDomainSplitting, .name = "tryImplementationThroughDomainSplitting" },
                                             { .method = tryImplementationThroughExpressionDecomposition, .name = "tryImplementationThroughExpressionDecomposition" },
                                             { .method = tryImplementationConstant, .name = "tryImplementationConstant" },
	                                     { .method = tryImplementationThroughArgumentReductionPowering, .name = "tryImplementationThroughArgumentReductionPowering" },
		     			     { .method = tryImplementationThroughArgumentReductionLogarithm, .name = "tryImplementationThroughArgumentReductionLogarithm" },
	                                     { .method = tryImplementationThroughArgumentReductionExponential, .name = "tryImplementationThroughArgumentReductionExponential" },
					     { .method = tryImplementationThroughArgumentReductionPeriodic, .name = "tryImplementationThroughArgumentReductionPeriodic" },
                                             { .method = tryImplementationThroughArgumentReductionWithParamountBehavior, .name = "tryImplementationThroughArgumentReductionWithParamountBehavior" },
					     { .method = tryImplementationThroughSquaring, .name = "tryImplementationThroughSquaring" },
                                             { .method = tryImplementationThroughSymmetryDetectionAroundZero, .name = "tryImplementationThroughSymmetryDetectionAroundZero" },
					     { .method = tryImplementationThroughMetaSplitting, .name = "tryImplementationThroughMetaSplitting" } |];
          };

	  okay = false; i = 0;
	  while ((!okay) && (tryImplementationChoices != [||])) do {
	          tryImplementationInstance = head(tryImplementationChoices);
		  tryImplementationChoices = tail(tryImplementationChoices);


		  if (showMethodName) then "Starting to try out implementation method ", tryImplementationInstance.name, " on function ", problemdef.func, " and domain ", problemdef.dom;
	          res = tryImplementationInstance.method(problemdef, parametrization);

		  if (res.okay) then {
		     if (showMethodName) then "Successfully returning from implementation method ", tryImplementationInstance.name;
		     result = res;
		     okay = true;
		  } else {
                     if (showMethodName) then "Unsuccessfully returning from implementation method ", tryImplementationInstance.name;
		  };
	  };

	  return result;
};

procedure tryImplementationExternal(problemdef, parametrization) {
	  var res;
	  var myparam;

	  myparam = parametrization;
	  myparam.implementationFile = parametrization.implementationFile @ ".tmp.c";

	  res = tryImplementation(problemdef, myparam);

	  write("") > parametrization.implementationFile;
	  emitCopyrightStatement(parametrization.implementationFile);
          bashexecute("cat " @ myparam.implementationFile @ " >> " @ parametrization.implementationFile);	  
	  bashexecute("rm " @ myparam.implementationFile);
	  
	  return res;
};

procedure emitCopyrightStatement(outputFile) {
          write("/* \n") >> outputFile;
          write("\n") >> outputFile;
          write("    This code was generated using non-trivial code generation commands\n") >> outputFile;
          write("    of the Metalibm software program.\n") >> outputFile;
          write("    \n") >> outputFile;
          write("    Before using, modifying and/or integrating this code into other\n") >> outputFile;
          write("    software, review the copyright and license status of this\n") >> outputFile;
          write("    generated code. In particular, see the exception below.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    This generated program is partly or entirely based on a program\n") >> outputFile;
          write("    generated using non-trivial code generation commands of the Sollya\n") >> outputFile;
          write("    software program. See the copyright notice and exception text\n") >> outputFile;
          write("    referring to that Sollya-generated part of this program generated\n") >> outputFile;
          write("    with Metalibm below.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    Metalibm is\n") >> outputFile;
          write(" \n") >> outputFile;
          write("    Copyright 2008-2013 by \n") >> outputFile;
          write("\n") >> outputFile;
          write("    Laboratoire de l'Informatique du Parall√©lisme, \n") >> outputFile;
          write("    UMR CNRS - ENS Lyon - UCB Lyon 1 - INRIA 5668\n") >> outputFile;
          write("\n") >> outputFile;
          write("    and by\n") >> outputFile;
          write("\n") >> outputFile;
          write("    Laboratoire d'Informatique de Paris 6, equipe PEQUAN,\n") >> outputFile;
          write("    UPMC Universite Paris 06 - CNRS - UMR 7606 - LIP6, Paris, France.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    Contributors: Christoph Quirin Lauter \n") >> outputFile;
          write("                  (UPMC LIP6 PEQUAN formerly LIP/ENS Lyon) \n") >> outputFile;
          write("                  christoph.lauter@lip6.fr\n") >> outputFile;
          write("\n") >> outputFile;
          write("		  and\n") >> outputFile;
          write("\n") >> outputFile;
          write("		  Olga Kupriianova \n") >> outputFile;
          write("		  (UPMC LIP6 PEQUAN)\n") >> outputFile;
          write("		  olga.kupriianova@lip6.fr\n") >> outputFile;
          write("\n") >> outputFile;
          write("    Metalibm was formerly developed by the Arenaire project at Ecole\n") >> outputFile;
          write("    Normale Superieure de Lyon and is now developed by Equipe PEQUAN\n") >> outputFile;
          write("    at Universite Pierre et Marie Curie Paris 6.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    The Metalibm software program is free software; you can\n") >> outputFile;
          write("    redistribute it and/or modify it under the terms of the GNU Lesser\n") >> outputFile;
          write("    General Public License as published by the Free Software\n") >> outputFile;
          write("    Foundation; either version 2 of the License, or (at your option)\n") >> outputFile;
          write("    any later version.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    Metalibm is distributed in the hope that it will be useful,\n") >> outputFile;
          write("    but WITHOUT ANY WARRANTY; without even the implied warranty of\n") >> outputFile;
          write("    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n") >> outputFile;
          write("    GNU General Public License for more details.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    You should have received a copy of the GNU Lesser General Public\n") >> outputFile;
          write("    License along with the Metalibm program; if not, write to the Free\n") >> outputFile;
          write("    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n") >> outputFile;
          write("    02111-1307, USA.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    This generated program is distributed WITHOUT ANY WARRANTY; without\n") >> outputFile;
          write("    even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n") >> outputFile;
          write("    PARTICULAR PURPOSE.\n") >> outputFile;
          write("    \n") >> outputFile;
          write("    As a special exception, you may create a larger work that contains\n") >> outputFile;
          write("    part or all of this software generated using Metalibm and\n") >> outputFile;
          write("    distribute that work under terms of your choice, so long as that\n") >> outputFile;
          write("    work isn't itself a numerical code generator using the skeleton of\n") >> outputFile;
          write("    this code or a modified version thereof as a code skeleton.\n") >> outputFile;
          write("    Alternatively, if you modify or redistribute this generated code\n") >> outputFile;
          write("    itself, or its skeleton, you may (at your option) remove this\n") >> outputFile;
          write("    special exception, which will cause this generated code and its\n") >> outputFile;
          write("    skeleton and the resulting Metalibm output files to be licensed\n") >> outputFile;
          write("    under the General Public licence (version 2) without this special\n") >> outputFile;
          write("    exception.\n") >> outputFile;
          write("    \n") >> outputFile;
          write("    This special exception was added by the Metalibm copyright holders \n") >> outputFile;
          write("    on November 20th 2013.\n") >> outputFile;
          write("    \n") >> outputFile;
          write("*/\n") >> outputFile;
          write("\n") >> outputFile;
};

