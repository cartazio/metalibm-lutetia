/*
 * Copyright 2008-2011 by 
 * 
 * Laboratoire de l'Informatique du Parall√©lisme, 
 * UMR CNRS - ENS Lyon - UCB Lyon 1 - INRIA 5668
 *
 * and by
 *
 * Laboratoire d'Informatique de Paris 6, equipe PEQUAN,
 * UPMC Universite Paris 06 - CNRS - UMR 7606 - LIP6, Paris, France.
 *
 * Sollya metalibm main procedures for implementing functions 
 * with polynomial approximation and Horner scheme evaluation
 *
 * Contributor: Christoph Quirin Lauter (ENS Lyon/ UPMC LIP6 PEQUAN) 
 *              christoph.lauter@ens-lyon.org
 *
 * This file is part of the metalibm library developed by the Arenaire
 * project at Ecole Normale Superieure de Lyon and by the equipe PEQUAN
 * at Universite Pierre et Marie Curie Paris 6.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or 
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
*/

execute("remezwrapper.sollya");
execute("upperbounds.sollya");
execute("vandercoeff.sollya");
execute("fpminimax.sollya");
execute("galoptimisation.sollya");
execute("symetries.sollya");


/* Quickly checks if the infinite norm of func 
   in dom is less than target 

   Returns false if it is not
   Returns the infinite norm if it is

*/
procedure dirtycheckinfnorm(func,dom,target) {
	  var t, b, h, y, maxy;
	  var oldprec;
	  var res;
	  var infn;

	  oldprec = prec = ?;
	  prec = 20!;
	  t = inf(dom);
	  b = sup(dom);
	  h = round((b - t) / 64,12,RU);
	  maxy = 0; 
	  while ((t <= b) && (maxy <= target)) do {
	  	maxy := abs(func(t));
		t = round(t + h,12,RU);
	  };
	  prec = oldprec!;
	  
	  if (maxy > target) then 
	      res = false 
	  else {
	       infn = dirtyinfnorm(func,dom);
	       if (infn > target) then {
	       	  write("Warning: dirtycheckinfnorm decides false case by dirtyinfnorm\n");
	       	  res = false; 
	       } else res = infn;
 	  };

	  return res;
};


/* implementandcheck

   implements a polynomial in a domain for a given target error 
   and checks whether the overall error is less than the target error

   approxerr may be false, in which case the procedure computes the infnorm

   Returns a list containing a boolean (works or not), a polynomial (the implemented one if works), an approx error and an evaluation error.

   The procedure may return false for problems with the implementation

*/
procedure implementandcheck(func,poly,dom,targeterr,targeterrimpl,approxerr,beta,variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName) {
	  var res;
	  var myapproxerr;
	  var q;
	  var implapproxerr;
	  var boundsList;
	  var evalerr;
	  var i;
	  var oldverb;

	  q = poly;
	  
	  if (approxerr == false) then {
	    myapproxerr = dirtyinfnorm(poly/func-1,dom);
	  } else {
	    myapproxerr = approxerr;
	  };
	  implapproxerr = myapproxerr;
	  evalerr = false;

	  // myapproxerr, targeterr;

	  res = (myapproxerr < targeterr);
	  if (res) then {
	     	q = implementpoly(poly,dom,targeterrimpl,variableFormat,polynomialName,implementationFile,honorcoeffprec,gappaFile);
		if (!(q == q)) then {
		   write("Something strange happened. The implementpoly command did not succeed\n");
		   oldverb = verbosity = ?;
		   verbosity = 2!;
	     	   q = implementpoly(poly,dom,targeterrimpl,variableFormat,polynomialName,implementationFile,honorcoeffprec,gappaFile);
		   verbosity = oldverb!;
		   q = poly;
		};
		if (horner(q) == horner(poly)) then {
		   implapproxerr = myapproxerr;
		} else {
		   implapproxerr = dirtyinfnorm(q/func-1,dom);
		};
	        res = (implapproxerr < targeterr);		
		if (res) then {
		   	write("boundsList = [|") > gappaOutputFile;
			bashexecute(gappaExecutable@" < "@gappaFile@" 2>&1 | grep 'epsilon in' | sed -n 's/\\({[^}]*}\\)//g;p' | sed -n 's/epsilon in \\[//;p' | sed -n 's/\\]/,/;p' | sed -n 's/, /,\\n/;p' >> "@gappaOutputFile);
			print("0|];") >> gappaOutputFile;
			execute(gappaOutputFile);	
			evalerr = 0;
			for i in boundsList do if (abs(i) > evalerr) then evalerr = abs(i);			
			if (evalerr == 0) then evalerr := 1/0;
			write("\tGappa determined evaluation error = 2^(",round(log2(evalerr),12,RU),")\n");

			res = ((implapproxerr + evalerr + implapproxerr * evalerr) <= (targeterr * beta));
		};
	  };
	  
	  if (res) then res = [|true, q, implapproxerr, evalerr|] else res = [| false, q, implapproxerr, evalerr|];

	  return res;
};


/* configToNumber 

   Gives the number of a configuration under a permutation order

*/
procedure configToNumber(config,permut) {
	  var res, k, i, tt;

	  res = 0;
	  for k from length(config)-1 to 0 by -1 do {
	      i = config[permut[k]];
	      res = res * 3;
	      if (i == D) then
		tt = 0
	      else 
		if (i == DD) then
			tt = 1
		else 
			tt = 2;
	      res = res + tt;
	  };

	  return res;
};

/* numberToConfig

   Gives a configuration of a configuration number under a permutation order

*/
procedure numberToConfig(t,permut,numberMonomials) {
	var k, configur, j, dv, r, form;
	k = t;
	configur = [|1,...,numberMonomials|];
	j = 0;
	while (j < numberMonomials) do {
		dv := floor(k / 3);
		r := k - 3 * dv;
		if (r == 0) then
			form = D
		else 
			if (r == 1) then
				form = DD
			else 
				form = TD;
		configur[permut[j]] = form;
		k = dv;
		j := j + 1;
	};
	return configur;
};


procedure isHigherPrecisionConfig(config,bounds) {
	  var res;
	  var i, c, b;

	  if (length(config) != length(bounds)) then {
	     res = false;
	  } else {
	     res = true;
	     i = 0;
	     while ((i < length(bounds)) && res) do {
	     	   c = config[i];
		   b = bounds[i];
		   if (((c == D) && (b != D)) || ((c == DD) && (b == TD))) then res = false;
	     	   i := i + 1;
	     };
	  };
	  return res;
};

procedure isLowerPrecisionConfig(config,bounds) {
	  var res;
	  var i, c, b;

	  if (length(config) != length(bounds)) then {
	     res = false;
	  } else {
	     res = true;
	     i = 0;
	     while ((i < length(bounds)) && res) do {
	     	   c = config[i];
		   b = bounds[i];
		   if (((b == D) && (c != D)) || ((b == DD) && (c == TD))) then res = false;
	     	   i := i + 1;
	     };
	  };
	  return res;
};


procedure extraroundcoefficients(poly,monomials,configuration) {
	  var confli;
	  var i;

	  confli = [||];
	  for i from 0 to degree(poly) do confli = D.:confli;

	  for i from 0 to length(monomials) - 1 do {
	      confli[monomials[i]] = configuration[i];
	  };

	  return roundcoefficients(poly,confli);
};


/* implementconfigurations

   Based on func, pstar, lowerbounds, upperbounds and optimisationPermut
   tries to find the first polynomial in optimisationPermut order
   (with the least number of coefficients) that satisfies targeterr

   Uses fpminimax

   Returns [|true, poly, approxerr, implerr, pstar|] if a configuration has been found
   Returns [|false, bestpoly, bestapprox, bestimplerr, pstar |] if no configuration satisfies the target error
   Returns [|false, pstar, 0, 0, false, pstar|] if some other error occurs

*/
procedure implementconfigurations(func,pstar,dom,targeterr,beta,lowerbounds,upperbounds,optimisationPermut,
	                          variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName) {
          var ii;
	  var okay;
	  var numbercoefficients;
	  var res;
	  var approxerr;
	  var pointlist;
	  var d;
	  var monomials;
	  var symetrical;
	  var firstmonomial;
	  var bestpoly, bestapprox, bestimplerr;
	  var configuration;
	  var implresult;
	  var poly;
	  var targetlog;
	  var looparound, targeterrimpl;
	  var dci, dcii, polyRound;

	  okay = true;
	  numbercoefficients = 0;
	  for ii from 0 to degree(pstar) do if (coeff(pstar,ii) != 0) then numbercoefficients := numbercoefficients + 1;
	  if ((length(lowerbounds) != length(upperbounds)) || (numbercoefficients != length(lowerbounds))) then {
	     okay = false;
	     res = [| false, pstar, 0, 0, false, pstar |];
	  };

	  if (okay) then {
	     approxerr = dirtyinfnorm(pstar/func-1,dom);

	     monomials = [||];
	     for ii from 0 to degree(pstar) do 
	           if (coeff(pstar,ii) != 0) then monomials = monomials:.ii;
	     
	     symetrical = true;
	     ii := length(monomials) - 1;
	     firstmonomial = head(monomials);
	     while ((ii >= 0) && symetrical) do {
	  	if (floor((monomials[ii] + firstmonomial) / 2) * 2 != (monomials[ii] + firstmonomial)) then 
		   symetrical = false;
		ii := ii - 1;
	     };
	     if (symetrical) then {
	        if (-inf(dom) > sup(dom)) then 
		   d = [1b-1075, -inf(dom)]
	        else 
		   d = [1b-1075, sup(dom)];
	     } else {
	        d = dom;
	     };

	     pointlist = dirtyfindzeros(pstar/func-1,d);

	     firstConfigNumber = configToNumber(lowerbounds,optimisationPermut);
	     lastConfigNumber = configToNumber(upperbounds,optimisationPermut);
	     t = firstConfigNumber;
	     found = false;
	     bestpoly = 0;
	     bestimplerr = 1000;	
	     bestapproxerr = 1000;
	     ii = 1;
	     targetlog = round(log2(targeterr),12,RN);
	     while ((!found) && (t <= lastConfigNumber)) do {
	           // "Configuration t = ", t, ", lastConfigNumber = ", lastConfigNumber;
	     	   configuration = numberToConfig(t,optimisationPermut,numbercoefficients);
		   if (isHigherPrecisionConfig(configuration,lowerbounds) && isLowerPrecisionConfig(configuration,upperbounds)) then {
		      write("Trying configuration #",ii," ",configuration,":\n");

		      poly = fpminimaxwrapper(func,dom,monomials,pstar,pointlist,configuration);
		      
		      if (poly != false) then {
		      	        dci = dirtycheckinfnorm(poly/func-1,dom,targeterr); 
				if (dci == false) then {
				   polyRound = extraroundcoefficients(pstar,monomials,configuration);
				   dcii = dirtycheckinfnorm(polyRound/func-1,dom,targeterr);
				   if (dcii != false) then {
				      write("Warning: rounded Pstar better that fpminimax polynomial\n");
				      poly = polyRound;
				      dci = dcii;
				   };
				};
		      	       	if (dci != false) then {      	              
		      	       	      looparound = true;
				      targeterrimpl = targeterr;
				      while (looparound && (targeterrimpl >= targeterr/16)) do {
		      		      	    implresult = implementandcheck(func,poly,dom,targeterr,targeterrimpl,dci,beta,
									   variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName);

					    // implresult[0], implresult[3];				   
				            if (implresult[0]) then 
					       looparound = false
					    else {
					    	 if ((implresult[3] == false) || (implresult[3] == 1/0)) then 
						    looparound = false 
						 else 
						    targeterrimpl := targeterrimpl / 2;
					    };					    
				      };
                                      if (implresult[0]) then {
				            found = true;
                                            bestpoly = poly;
					    bestimplerr = implresult[3];
					    bestapproxerr = implresult[2];
					    
					    write("\tfound: target = 2^(",targetlog,"), approx = 2^(",round(log2(bestapproxerr),12,RU),"), evaluat = 2^(",
                                                  round(log2(bestimplerr),12,RU),"), overall = 2^(",
						  round(log2(bestimplerr + bestapproxerr + bestimplerr * bestapproxerr),12,RU),")");
			              } else {				      
				            if (implresult[2] < bestapproxerr) then {
					       bestpoly = poly;
					       bestapproxerr = implresult[2];
					       bestimplerr = implresult[3];
                                            };
				            write("\tunusable: target = 2^(",targetlog,"), approx = 2^(", 
                                                  round(log2(implresult[2]),12,RN),") (best approx = 2^(",
					          round(log2(bestapproxerr),12,RN),"))");
                                      };
                                } else {
				      write("\tunusable: target = 2^(",targetlog,")");
				};
		      } else {
		      	write("\tproblem with fpminimax");
		      };
		      write("\n");
		      ii := ii + 1;
		   };
	     	   t := t + 1;
	     };
	     res = [| found, bestpoly, bestapproxerr, bestimplerr, pstar |];
	  };

          return res;		    
};


/* implements a function by polynomial approximation in an interval centered in 0 

   Returns 

    [| true, poly, approxerr, implerr, pstar |] if everything is fine
    [| false, 0, 0, 0, 0 |] otherwise

    No test is made whether the interval is correctly centered in 0

*/
procedure implementcentered(func, dom, target, beta, variableFormat, galoptimizedMonomials, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName) {
	  var res;
	  var Pstar, upperbounds, lowerbounds, optimisationPermut;	  
	  var i, monomials;
	  var lowerboundsAndOptiPermut;
	  var k, l;

	  res = [| false, 0, 0, 0, 0 |];

	  Pstar = remezwrapper(func, dom, target, 3);

	  if (Pstar != false) then {
	  
		monomials = [||];
		for i from 0 to degree(Pstar) do {
		    if (coeff(Pstar,i) != 0) then monomials = monomials:.i;
		};

		upperbounds = determineupperbounds(Pstar, func, dom, target, variableFormat, implementationFile);

		lowerboundsAndOptiPermut = determinelowerbounds(Pstar, func, dom, target);


		if (lowerboundsAndOptiPermut == false) then {

          	        lowerbounds = [||];
	                for i in upperbounds do {
	                   if (i == D) then 
	                      lowerbounds = lowerbounds:.D
                           else
	                      if (i == DD) then 
		                 lowerbounds = lowerbounds:.D
	                      else 
                                 lowerbounds = lowerbounds:.DD;
                        };

                        optimisationPermut = [| 0, ..., length(upperbounds)-1 |];
                } else {
		        lowerbounds = lowerboundsAndOptiPermut[0];
			optimisationPermut = lowerboundsAndOptiPermut[1];
			
			for l from 0 to length(monomials) - 1 do {
			    if (listcontains(galoptimizedMonomials,monomials[l])) then {
			       lowerbounds[l] = D;
			    }; 
			};

                };

		if (length(lowerbounds) == length(upperbounds)) then {

		for k from 0 to length(lowerbounds) - 1 do {
		    if ((upperbounds[k] == D) && (lowerbounds[k] != D)) then upperbounds[k] = lowerbounds[k];
		    if ((upperbounds[k] == DD) && (lowerbounds[k] == TD)) then upperbounds[k] = lowerbounds[k];
		};

	        write("Chosen monomial base: ",monomials,"\n");
	        write("Lower bounds for precisions of coefficients: ",lowerbounds,"\n");
	        write("Upper bounds for precisions of coefficients: ",upperbounds,"\n");		
	        write("Optimisation permutation: ",optimisationPermut,"\n");
	        write("\n");

                res = implementconfigurations(func,Pstar,dom,target,beta,lowerbounds,upperbounds,optimisationPermut,
	                                      variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable, polynomialName);
		};
          };

	  return res;
};



/* implements a function by polynomial approximation in a small interval

   Returns 

    [| true, centerpoint, poly, approxerr, implerr |] if everything is fine
    [| false, 0, 0, 0, 0 |] otherwise

   The function to be implemented may have at most 1 zero in the domain.
   No test for this condition is made.

*/
procedure implementsmall(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName) {
	  var res;
	  var zerosInInterval, zerosInIntervalRaw, zr, midpoint, zerosInIntervalTemp, zerosInIntervalRaw2;
	  var smallestAbsZero;
	  var Pstar;
	  var okay;
	  var startmidpoint;
	  var shiftedFunc, shiftedDom;
	  var resImpl;
	  var oldprec, oldpoints, olddiam;
	  var galoptim;		  
	  var galoptimizedMonomials;

	  
	  galoptimizedMonomials = [||];
	  okay = true;
	  

	  if (inf(dom) * sup(dom) >= 0) then {


	       zerosInInterval = [||];
	       oldprec = (prec = ?);
	       prec = oldprec * 3!;
	       oldpoints = (points = ?);
	       points = oldpoints * 6!;
	       olddiam = (diam = ?);
	       diam = olddiam / 1b8!;
 	       zerosInIntervalRaw2 = findzeros(func,dom);
	       zerosInIntervalRaw = [||];
	       for zr in zerosInIntervalRaw2 do 
	          zerosInIntervalRaw = zerosInIntervalRaw @(findzeros(func,zr));
	       for zr in zerosInIntervalRaw do 
	          zerosInInterval = zerosInInterval @ (dirtyfindzeros(func,zr));
	       prec = oldprec!;
	       points = oldpoints!;
	       diam = olddiam!;
	       zerosInIntervalTemp = sort(zerosInInterval);	  
	       zeroInInterval = [||];
	       for zr in zerosInIntervalTemp do zerosInInterval = zerosInInterval:.(mid(evaluate(D(x),zr)));
	       if (zerosInInterval != [||]) then {
	           smallestAbsZero = zerosInInterval[0];
	           for zr in zerosInInterval do 
	     	       if (abs(func(zr)) < abs(func(smallestAbsZero))) then smallestAbsZero = zr;
	           midpoint := D(smallestAbsZero);	 	 
	       } else {
	           symetrypoint = testEvenSymetry(func, dom, 1b-10);
		   if (symetrypoint != false) then {
		      write("Even symmetry dectected\n");
		      midpoint := D(symetrypoint);
		   } else {
		     if (target < 1b-50) then {
	              Pstar = simplifysafe(horner(simplifysafe(substitute(remezwrapper(func(x + D(mid(dom))), [inf(dom) - D(mid(dom));sup(dom) - D(mid(dom))], target, 3),(x - D(mid(dom)))))));
	              if (Pstar != false) then {
	                 startmidpoint := D(mid(dom));
			 galoptim = galoptimisation(Pstar,func,dom,target,startmidpoint);
	                 midpoint := D(galoptim[0]);
			 galoptimizedMonomials = galoptim[1];
	              } else {
	                 midpoint := D(mid(dom));
	              };
		      } else {
		      	 midpoint := D(mid(dom));
		      };
		   };
	       };

          } else {
	       midpoint = 0;
          };

	  if (okay) then {
	     write("Chosen midpoint = ",round(midpoint,53,RN)," = ");
	     printhexa(midpoint);
	     
	     shiftedFunc = horner(func(x + midpoint));
	     shiftedDom = [inf(dom) - midpoint ; sup(dom) - midpoint];

	     write("The translated function is f = ",shiftedFunc,"\n");
	     write("The translated domain is dom = ",shiftedDom,"\n");

	     resImpl = implementcentered(shiftedFunc, shiftedDom, target, beta, variableFormat, galoptimizedMonomials,
	                                 implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName);

	     res = [| resImpl[0], midpoint, resImpl[1], resImpl[2], resImpl[3], resImpl[4] |];				 

	  } else {
	    res = [| false, 0, 0, 0, 0, 0 |];
	  };

	  return res;
};

procedure implementShifter(centerPoint, dom, variableFormat, outputFormat, polynomialName, functionName, implementationFile) {
	  var res;
	  var shifterCode, oldDisplay;
	  var sterbenzOkay;

	  res = { .okay = false };

	  /* Check if centerPoint is a double precision number in the domain
             and if Sterbenz' lemma will be verified for the whole domain */
	  if ((D(centerPoint) - centerPoint == 0) && 
              (centerPoint in dom)) then {	      
              sterbenzOkay = (((inf(dom) * sup(dom) > 0) && (inf(dom) * centerPoint > 0)) && ((abs(inf(dom)) >= abs(centerPoint)/2) && (abs(sup(dom)) <= 2 * abs(centerPoint))));
	      if (sterbenzOkay) then {
               res.okay = true;
	       oldDisplay = display;
	       display = decimal!;
	       shifterCode = "\n\n#define " @ functionName @ "_centerpoint " @ centerPoint;
	       display = oldDisplay!;
	       shifterCode = shifterCode @ "\n\nvoid "@functionName@"(";
	       shifterCode = shifterCode @ (match outputFormat with 
                                                  D   : ( "double *res_resh, " )
                                                  DD  : ( "double *res_resh, double *res_resm, " )
                                                  TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                           );
               shifterCode = shifterCode @ (match variableFormat with 
                                                  D   : ( "double x" )
                                                  DD  : ( "double xh, double xm" )
                                                  TD  : ( "double xh, double xm, double xl" )
                                           );
               shifterCode = shifterCode @ ") {\n";
               shifterCode = shifterCode @ (match variableFormat with 
                                                  D   : ( "double t;\n\n" )
                                                  DD  : ( "double th, tm;\ndouble temp;\n\n" )
                                                  TD  : ( "double th, tm, tl;\ndouble temp;\n\n" )
                                           );
               shifterCode = shifterCode @ (match variableFormat with 
                                                  D   : ( "t = x - " @ functionName @ "_centerpoint;" )
                                                  DD  : ( "temp = xh - " @ functionName @ "_centerpoint;\nAdd12(th,tm,temp,xm);" )
                                                  TD  : ( "temp = xh - " @ functionName @ "_centerpoint;\nRenormalize3(&th,&tm,&tl,temp,xm,xl);" )
                                           );
               shifterCode = shifterCode @ "\n\n";
	       shifterCode = shifterCode @ polynomialName @ "(";
	       shifterCode = shifterCode @ (match outputFormat with 
                                                  D   : ( "res_resh, " )
                                                  DD  : ( "res_resh, res_resm, " )
                                                  TD  : ( "res_resh, res_resm, res_resl, " )
                                           );
               shifterCode = shifterCode @ (match variableFormat with 
                                                  D   : ( "t" )
                                                  DD  : ( "th, tm" )
                                                  TD  : ( "th, tm, tl" )
                                           );
               shifterCode = shifterCode @ ");\n\n";
	       shifterCode = shifterCode @ "}\n";
	       write(shifterCode) >> implementationFile;
          } else {
	    write("Error: Sterbenz condition not fulfilled for argument center ", centerPoint, " and domain ", dom, "\n");
	  };
	  };

	  return res;
};

/* implements a function by polynomial approximation in a small interval
   while issuing appropriate range translation code if the interval 
   is not centered in zero.

   Returns a structure that 

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the approximation error
          * implerr      the implementation (round-off) error
          * centerpoint  the point the original interval got centered at
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         translation
          * poly         the polynomial that has been used
          * pstar        the best approximation polynomial used for 
                         floating-point approximation

   The function to be implemented may have at most 1 zero in the domain.
   No test for this condition is made.

*/
procedure implementsmallwithcentering(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName) {
	  var res, resultat, outputFormat, resShifter;

	  resultat = { .okay = false };

	  res = implementsmall(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName);

	  if (res[0]) then {
	     /* Get the information returned by the implementer function working on a small interval */
	     resultat.okay = true;
	     resultat.approxerr = res[3];
	     resultat.implerr = res[4];
	     resultat.poly = res[2];
	     resultat.pstar = res[5];
	     resultat.centerpoint = res[1];

	     /* Determine the output format of the implemented polynomial */
	     outputFormat = parse(bashevaluate("cat "@implementationFile@" | grep \"void "@polynomialName@"\" | sed -n 's/double x.*//g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, double \\*"@polynomialName@"_resm, double \\*"@polynomialName@"_resl, /TD/g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, double \\*"@polynomialName@"_resm, /DD/g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, /D/g;p'"));
	     resultat.outputformat = outputFormat;

	     /* Generate the code that shifts the domain with the centerpoint determined beforehand */
	     if (resultat.centerpoint != 0) then {
	       resultat.functionname = polynomialName@ "_shifter";
	       resShifter = implementShifter(resultat.centerpoint, dom, variableFormat, outputFormat, polynomialName, resultat.functionname, implementationFile);
	       if (!resShifter.okay) then {
	       	  resultat = { .okay = false };
	       };
	     } else {
	       resultat.functionname = polynomialName;
	     };
	  }; 

	  return resultat;
};

procedure splitList(l, i) {
	  var res;
	  var lA, lB, k, lenL;

	  lenL = length(l);
	  if ((i < 0) || (i >= lenL)) then {
	     res.lA = l;
	     res.lB = [||];
	  } else {
	    lA = [||];
	    for k from 0 to i - 1 do {
	    	lA = lA :. (l[k]);
	    };
	    lB = [||];
	    for k from i to lenL - 1 do {
	    	lB = lB :. (l[k]);
	    };
	    res.lA = lA;
	    res.lB = lB;
	  };

	  return res;
};

procedure generateRecursiveSplitter(splitPointName, domains, functionNames, outputFormats, variableFormat, globalOutputFormat) {
	  var resultat;
	  var lenDomains, lenFunctionNames, lenOutputFormats, splitterCode, middleIndex, res;
	  var splitPointA, splitPointB;
	  var temp;
	  var domainsLeft, domainsRight, functionNamesLeft, functionNamesRight, outputFormatsLeft, outputFormatsRight;
	  var oldDisplay, resLeft, resRight, myDefines;

	  resultat = { .okay = false };

	  lenDomains = length(domains);
	  lenFunctionNames = length(functionNames);
	  lenOutputFormats = length(outputFormats);
	  
	  if ((lenDomains == lenFunctionNames) &&
	      (lenFunctionNames == lenOutputFormats) &&
	      (lenDomains != 0)) then {

	      if (lenDomains == 1) then {
	          resultat.okay = true;
		  resultat.defines = "";
		  splitterCode = functionNames[0] @ "(";
		  splitterCode = splitterCode @ (match (outputFormats[0]) with 
		                                       D  :    ("res_resh, ")
                                                       DD :    ("res_resh, res_resm, ")
                                                       TD :    ("res_resh, res_resm, res_resl, ")
                                                );
                  splitterCode = splitterCode @ (match (variableFormat) with 
                                                       D  :    ("xh")
                                                       DD :    ("xh, xm")
                                                       TD :    ("xh, xm, xl")
                                                );
                  splitterCode = splitterCode @ ");\n";
                  match (globalOutputFormat) with 
                        TD : {
                                match (outputFormats[0]) with 
                                      DD :  {
                                                splitterCode = splitterCode @ "*res_resl = 0.0;\n";
                                            }
                                      D  :  {
                                                splitterCode = splitterCode @ "*res_resm = 0.0;\n";
                                                splitterCode = splitterCode @ "*res_resl = 0.0;\n";
                                            }
                                      default : { };
                             }
                        DD : {
                                if (outputFormats[0] == D) then {
                                   splitterCode = splitterCode @ "*res_resm = 0.0;\n";
                                };
                             }
                        default : { };
	          resultat.splitterCode = splitterCode;
	      } else {
	      	  middleIndex = floor(lenDomains / 2);
		  splitPointA = inf(domains[middleIndex]);
		  splitPointB = sup(domains[middleIndex - 1]);
                  if (splitPointA == splitPointB) then {
		     temp = splitList(domains, middleIndex);
		     domainsLeft = temp.lA;
		     domainsRight = temp.lB;
		     temp = splitList(functionNames, middleIndex);
		     functionNamesLeft = temp.lA;
		     functionNamesRight = temp.lB;
		     temp = splitList(outputFormats, middleIndex);
		     outputFormatsLeft = temp.lA;
		     outputFormatsRight = temp.lB;
		     resLeft = generateRecursiveSplitter(splitPointName @ "_0", domainsLeft, functionNamesLeft, outputFormatsLeft, variableFormat, globalOutputFormat);
		     resRight = generateRecursiveSplitter(splitPointName @ "_1", domainsRight, functionNamesRight, outputFormatsRight, variableFormat, globalOutputFormat);
		     if (resLeft.okay && resRight.okay) then {
		         resultat.okay = true;
			 oldDisplay = display;
			 display = decimal!;
			 myDefines = "#define " @ splitPointName @ "_splitpoint " @ splitPointA @ "\n";
			 display = oldDisplay!;
			 splitterCode = "if ( xh < " @ splitPointName @ "_splitpoint ) {\n" @
                                        resLeft.splitterCode @ "} else {\n" @
                                        resRight.splitterCode @ "}\n";
			 resultat.defines = resLeft.defines @ myDefines @ resRight.defines;
			 resultat.splitterCode = splitterCode;
		     };
		  };
	      };
	  };

	  return resultat;
};


/* implements a function by polynomial approximation in small intervals
   obtained by cutting the interval at given points

   Returns a structure that 

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the maximum approximation error
          * implerr      the maximum implementation (round-off) error
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         reduction

   The function to be implemented may have at most 1 zero in each sub-domain.
   No test for this condition is made.

*/
procedure implementwithdomainsplitlist(func, dom, splitPoints, minWidth, definitionDomain, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName) {
	  var resultat;
	  var okay, sp;
	  var mySplitPoints;
	  var approxerr, implerr, outputFormats, functionNames;
	  var domains, i, numberSplitPoints, myDom, mySuffix, myImplementationFile;
	  var res, implementationFiles, implFile, myOutputFormat, opF, myOutputFormatNum;
	  var myFunctionName, splitterCode, oldDisplay, recursiveSplitterRes, symmetrizedDom, recovered;

	  resultat = { .okay = false };

	  /* First of all, if no splitPoints are given, the domain is not
	     split and we can simply call implementsmallwithcentering
	  */
	  if (splitPoints == [||]) then {
	     resultat = implementsmallwithcentering(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName);
	  } else {	   
	  /* To start with, check if all splitPoints are doubles and 
             if they are contained in the given domain 
          */
	  okay = true;
	  for sp in splitPoints do {
	      okay = okay && ((D(sp) - sp == 0) && (sp in dom));
	  };
	  if (okay) then {
	     /* Now sort the split points by increasing order, 
	     adding the bounds to the list */
	     mySplitPoints = sort(splitPoints @ [| inf(dom), sup(dom) |]);

	     /* While we succeed in implementing the subdomains,
	        cut out a new subdomain, generate function and
		file names and try implementation.
             */
	     approxerr = 0;
	     implerr = 0;
	     outputformats = [||];
  	     functionNames = [||];
	     domains = [||];
	     implementationFiles = [||];
	     numberSplitPoints = length(mySplitPoints);
	     myDomains = [||];
	     for i from 0 to numberSplitPoints - 2 do {
	     	 myDomains = myDomains :. ( [ mySplitPoints[i], mySplitPoints[i + 1] ] );
	     };
	     i = 0;
	     while ((okay) && (myDomains != [||])) do {
	     	   myDom = head(myDomains);
		   myDomains = tail(myDomains);
		   write("\nStarting implementation on subdomain ",myDom,"\n");
		   mySuffix = "_subdomain_" @ i ;
		   myImplementationFile = implementationFile @ mySuffix;	
		   res = implementsmallwithcentering(func, myDom, target, beta, variableFormat, myImplementationFile, gappaFile @ mySuffix, gappaOutputFile @ mySuffix, gappaExecutable, polynomialBaseName @ mySuffix);
		   if (res.okay) then {
		         write("Subdomain ",myDom," done\n");
   		         domains = domains :. myDom;
		         implementationFiles = implementationFiles :. myImplementationFile;
			 approxerr = max(approxerr, abs(res.approxerr));
			 implerr = max(implerr, abs(res.implerr));
			 outputformats = outputformats :. (res.outputformat);
			 functionNames = functionNames :. (res.functionname);
			 i := i + 1;
		   } else {
		     if (abs(sup(myDom) - inf(myDom)) < minWidth) then {
		        write("Error on subdomain ",myDom,", check ", gappaFile @ mySuffix, "\n");
		        okay = false;
	             } else {
		        recovered = false;
		        symmetrizedDom = myDom;
			if (inf(myDom) == 0) then { 
			   symmetrizedDom = [-sup(myDom),sup(myDom)];
			};
			if (sup(myDom) == 0) then {
			   symmetrizedDom = [inf(myDom),-inf(myDom)];
			};
			if ((inf(myDom) == 0) || (sup(myDom) == 0)) then {
			   if (symmetrizedDom in definitionDomain) then {
			      write("Using symmetrized domain around 0 instead of original domain to exploit symmetries of the function\n");
			      res = implementsmallwithcentering(func, symmetrizedDom, target, beta, variableFormat, myImplementationFile, gappaFile @ mySuffix, gappaOutputFile @ mySuffix, gappaExecutable, polynomialBaseName @ mySuffix);
      		              if (res.okay) then {
		                 write("Subdomain ",myDom," done\n");
   		                 domains = domains :. myDom;
		                 implementationFiles = implementationFiles :. myImplementationFile;
			         approxerr = max(approxerr, abs(res.approxerr));
			         implerr = max(implerr, abs(res.implerr));
			         outputformats = outputformats :. (res.outputformat);
			         functionNames = functionNames :. (res.functionname);
			         i := i + 1;
				 recovered = true;
		              };
			   };
			};

			if (!recovered) then {
			   write("Resplitting on subdomain ",myDom,"\n");
		           if (inf(myDom) * sup(myDom) < 0) then {
			      myDomains = [ inf(myDom) , D(inf(myDom) / 3) ] .: ( [ D(inf(myDom) / 3) , D(sup(myDom) / 3) ] .: ( [ D(sup(myDom) / 3) , sup(myDom) ] .: myDomains )); 	  
			   } else {
			      myDomains = [ inf(myDom) , D(mid(myDom)) ] .: ( [ D(mid(myDom)) , sup(myDom) ] .: myDomains ); 	  
			   };
			};
		     };
		   };
	     };
	     
	     /* Now generate the argument reduction code if 
	        we succeeded in generating code for all 
		subdomains and combine all files.
             */
	     if (okay) then {
	        oldDisplay = display;
		display = dyadic!;
	     	write("\n\n") > implementationFile;
                display = oldDisplay!;
		for implFile in implementationFiles do {
		    bashexecute("cat " @ implFile @ " >> " @ implementationFile);
		};
		write("\n\n") >> implementationFile;
		myOutputFormatNum = 1;
		for opF in outputformats do {
		    myOutputFormatNum = max(myOutputFormatNum,
                                            match opF with 
                                                  D  : (1) 
                                                  DD : (2) 
                                                  TD : (3)
                                                  default : { okay = false; return 0; });
		};
		if (okay) then {
		   myOutputFormat = match myOutputFormatNum with 1 : (D) 2 : (DD) 3 : (TD);
                   myFunctionName = polynomialBaseName @ "_splitter";
		   splitterCode = "\n\n";
		   recursiveSplitterRes = generateRecursiveSplitter(myFunctionName, domains, functionNames, outputformats, variableFormat, myOutputFormat); 
		   if (!recursiveSplitterRes.okay) then okay = false;
		   if (okay) then {
		        splitterCode = splitterCode @ recursiveSplitterRes.defines;
             	        splitterCode = splitterCode @ "\n\nvoid "@myFunctionName@"(";
	       	        splitterCode = splitterCode @ (match myOutputFormat with 
                   	                                     D   : ( "double *res_resh, " )
                                                             DD  : ( "double *res_resh, double *res_resm, " )
                                                             TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                                      );
                        splitterCode = splitterCode @ (match variableFormat with 
                                                             D   : ( "double xh" )
                                                             DD  : ( "double xh, double xm" )
                                                             TD  : ( "double xh, double xm, double xl" )
                                                      );
                        splitterCode = splitterCode @ ") {\n";
		        splitterCode = splitterCode @ recursiveSplitterRes.splitterCode;
                        splitterCode = splitterCode @ "}\n\n";
		        write(splitterCode) >> implementationFile; 
                   };
		   if (okay) then {
		      resultat.okay = true;
		      resultat.approxerr = approxerr;
		      resultat.implerr = implerr;
		      resultat.outputformat = myOutputFormat;
		      resultat.functionname = myFunctionName;
		   };
		};
	     };
	  };
	  };

	  return resultat;
};

procedure computeDomainSplitting(func, dom, maxDegree, target) {
	  var resultat;
	  var poly;
	  var deg;
	  var subdomains, splitpoints, aSp, bSp, sd;
	  var res, recursiveSplitPoints, y, guess;
	  var midpoint;
	  var remezFunc, remezDom;
	  var zeros, t, z;

	  resultat = { .okay = false };
	  deg = -1;

	  if ((!(0 in dom)) && 
	      (!(dom in [(mid(dom) * 100)/199;(mid(dom)*199)/100]))) then {
	      /* We have to split because the Sterbenz condition will
	         not be fulfilled for center points on this subdomain 

		 We simultate the case with a dummy degree that is too huge
	       */
	       deg = maxDegree * 2;

	  } else {

	  remezFunc = func;
	  remezDom = dom;
	  if (0 in evaluate(func,dom)) then {
	     y = evaluate(func, 0);
	     if (!((inf(y) <= 0) && (sup(y) >= 0))) then {
	     	/* func has a zero in dom but not in 0 */
		zeros = dirtyfindzeros(func, dom);
		if (zeros != [||]) then {
		   /* I found zeros of func in dom,
		      let's look for the zero farthest
		      from 0
		   */
		   t = zeros[0];
		   for z in zeros do {
		       if (abs(z) > abs(t)) then t = z;
		   };
		   /* Now translate the function so 
		      that it has a zero in 0
                   */
		   remezFunc = func(x + t);
		   remezDom = dom - t;
		};
	     };
	  };

	  if (0 in remezDom) then { y = evaluate(remezFunc, 0); } else { y = 1; };
	  if ((inf(y) <= 0) && (sup(y) >= 0)) then {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),x/remezFunc,maxDegree+2); };
	     guess = guess + 1;
	  } else {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),1/remezFunc,maxDegree+2); };
	  };

	  if ((guess == guess) && (guess != false)) then {
	          deg = inf(guess);
	  } else {
	  	  write("Computing a remez polynomial for ", func, " in ", dom, " with target ", target,"\n");
	  	  poly = simpleRemezWrapper(remezFunc, remezDom, target, 3);
		  if ((poly == poly) && (poly != false)) then {
		     deg = degree(poly);
		  };
          };

	  };

	     if (deg > 0) then { 
	     	if (deg <= maxDegree) then {
		   resultat.okay = true;
		   resultat.splitPoints = [||];
		} else {
		   if (inf(dom) * sup(dom) < 0) then {
		      aSp = D(inf(dom)/3);
		      bSp = D(sup(dom)/3);
		      splitpoints = [| aSp , bSp |];
		      subdomains = [| [ inf(dom) , aSp ], [ aSp, bSp ], [ bSp, sup(dom) ] |];
		   } else {
		      aSp = D(mid(dom));
		      splitpoints = [| aSp |];
		      subdomains = [| [ inf(dom), aSp ], [ aSp, sup(dom) ] |];
		   };
		   okay = true;
		   recursiveSplitPoints = [||];
		   while ((okay) && (subdomains != [||])) do {
		   	 sd = head(subdomains);
			 subdomains = tail(subdomains);
			 res = computeDomainSplitting(func, sd, maxDegree, target);
			 if (res.okay) then {
			    recursiveSplitPoints = recursiveSplitPoints @ (res.splitPoints);
			 } else {
			   okay = false;
			 };
		   };
		   if (okay) then {
		      resultat.okay = true;
		      resultat.splitPoints = recursiveSplitPoints @ splitpoints;
		   };
	     	};
	     };
	    

	  return resultat;
};


/* implements a function by polynomial approximation in small intervals
   that are automatically computed using a maximum polynomial degree
   indication

   Returns a structure that 

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the maximum approximation error
          * implerr      the maximum implementation (round-off) error
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         reduction

   The function to be implemented may have at most 1 zero in each sub-domain.
   No test for this condition is made.

*/
procedure implementwithdomainsplitting(func, dom, maxDegree, minWidth, definitionDomain, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName) {
	  var resultat, res, splitPoints;

	  resultat = { .okay = false };

	  res = computeDomainSplitting(func, dom, maxDegree, target);

	  if (res.okay) then {
	     splitPoints = sort(res.splitPoints);

	     write("The domain will first be split at the following points: ", splitPoints, "\n");

	     res = implementwithdomainsplitlist(func, dom, splitPoints, minWidth, definitionDomain, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName);

	     if (res.okay) then {
	     	resultat = res;
	     };

	  };

	  return resultat;
};


procedure tryImplementationThroughDomainSplitting(problemdef, parametrization) {
	  var result, definitionDomain;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with 
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default } } : {
				                definitionDomain = problemdef.dom;
						match (problemdef) with 
                                                      { .definitionDomain = default } : { definitionDomain = problemdef.definitionDomain; }
                                                      default : { };
					        result = implementwithdomainsplitting(problemdef.func, 
						                                      problemdef.dom, 
                                                                                      parametrization.maxDegree, 
                                                                                      parametrization.minWidth, 
										      definitionDomain,
                                                                                      problemdef.target, 
                                                                                      parametrization.beta, 
                                                                                      problemdef.variableFormat, 
                                                                                      parametrization.implementationFile, 
										      parametrization.gappaFile, 
										      parametrization.gappaOutputFile, 
										      parametrization.gappaExecutable, 
										      parametrization.functionBasename);
					}
                default : { };

	  return result;
};

procedure checkIfSufficientDegree(func, dom, maxDegree, target) {
	  var resultat;
	  var poly;
	  var deg;
	  var y, guess;
	  var remezFunc, remezDom;
	  var zeros, t, z;

	  resultat = { .okay = false };
	  deg = -1;

	  if ((!(0 in dom)) && 
	      (!(dom in [(mid(dom) * 100)/199;(mid(dom)*199)/100]))) then {
	      /* We have to split because the Sterbenz condition will
	         not be fulfilled for center points on this subdomain 

		 We simultate the case with a dummy degree that is too huge
	       */
	       deg = maxDegree * 2;

	  } else {

	  remezFunc = func;
	  remezDom = dom;
	  if (0 in evaluate(func,dom)) then {
	     y = evaluate(func, 0);
	     if (!((inf(y) <= 0) && (sup(y) >= 0))) then {
	     	/* func has a zero in dom but not in 0 */
		zeros = dirtyfindzeros(func, dom);
		if (zeros != [||]) then {
		   /* I found zeros of func in dom,
		      let's look for the zero farthest
		      from 0
		   */
		   t = zeros[0];
		   for z in zeros do {
		       if (abs(z) > abs(t)) then t = z;
		   };
		   /* Now translate the function so 
		      that it has a zero in 0
                   */
		   remezFunc = func(x + t);
		   remezDom = dom - t;
		};
	     };
	  };

	  if (0 in remezDom) then { y = evaluate(remezFunc, 0); } else { y = 1; };
	  if ((inf(y) <= 0) && (sup(y) >= 0)) then {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),x/remezFunc,maxDegree+2); };
	     guess = guess + 1;
	  } else {
	     { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),1/remezFunc,maxDegree+2); };
	  };

	  if ((guess == guess) && (guess != false)) then {
	          deg = inf(guess);
	  } else {
	  	  write("Computing a remez polynomial for ", func, " in ", dom, " with target ", target,"\n");
	  	  poly = simpleRemezWrapper(remezFunc, remezDom, target, 3);
		  if ((poly == poly) && (poly != false)) then {
		     deg = degree(poly);
		  };
          };

	  };

	     if (deg > 0) then { 
	     	if (deg <= maxDegree) then {
		   resultat.okay = true;
		   resultat.sufficientDegree = true;
		} else {
		   resultat.okay = true;
		   resultat.sufficientDegree = false;
	     	};
	     };
	    

	  return resultat;
};

procedure tryDetectSymmetry(func, dom, target) {
	  var res, testfunc, zerosUpper, zerosLower, myDom, y;

	  res = { .okay = false };

	  myDom = [0; min(sup(dom), -inf(dom))];
	  testfunc = simplifysafe((func/(func(-x))) - 1);
	  y = evaluate(testfunc, min(sup(dom), -inf(dom)) / 2);
	  if (y in [-target, target]) then {
	  	  zerosUpper = dirtyfindzeros(testfunc + target, myDom);
	  	  zerosLower = dirtyfindzeros(testfunc - target, myDom);
          } else {
	          zerosUpper = [| 0 |];
		  zerosLower = [| 0 |];
	  };		  

	  if ((zerosUpper == [||]) && (zerosLower == [||])) then {
	     res.okay = true;
	     res.evenSymmetry = true;
	  } else {
	     testfunc = simplifysafe((func/(-func(-x))) - 1);
   	     y = evaluate(testfunc, min(sup(dom), -inf(dom)) / 2);
	     if (y in [-target, target]) then {
	  	  zerosUpper = dirtyfindzeros(testfunc + target, myDom);
	  	  zerosLower = dirtyfindzeros(testfunc - target, myDom);
             } else {
	          zerosUpper = [| 0 |];
		  zerosLower = [| 0 |];
	     };		  

	     if ((zerosUpper == [||]) && (zerosLower == [||])) then {
	        res.okay = true;
	        res.evenSymmetry = false;
	     };
	  };

	  return res;
};

procedure tryImplementationThroughSymmetryDetectionAroundZero(problemdef, parametrization) {
	  var result, splitPoints, needToDetectSymmetry, res, evenSymmetry, myDom, oppositeOnNegative;
	  var suffix, myProblemdef, myParametrization, origDefDom, symmetryCode;

	  result = { .okay = false };

	  match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with 
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
			               .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
				       .functionBasename = default } } : {
				       
				       /* Start with a test if zero is actually inside the domain */
				       if (sup(problemdef.dom) * inf(problemdef.dom) < 0) then {

				       /* Continue with a test if the domain actually needs 
                                          to be split in order to stay below the maximum 
					  polynomial degree 
				        */	     
				       needToDetectSymmetry = true;
				       res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

      	                               if (res.okay) then {
   	                                   if (res.sufficientDegree) then needToDetectSymmetry = false;
				       } else {
				           needToDetectSymmetry = false;
				       };

				       if (needToDetectSymmetry) then {
				       
				            /* Try to detect a symmetry of func around 0 */
					    res = tryDetectSymmetry(problemdef.func, problemdef.dom, problemdef.target * 13/32);

					    if (res.okay) then {
					       /* If we detected a symmetry */
					       if (res.evenSymmetry) then {
					       	  write("Detected an even symmetry\n");
					       } else {
					          write("Detected an odd symmetry\n");
					       };
					       /* Now compute the reduced domain and determine
					          when we have to compute the opposite of the argument.
					       */
                                               if (-inf(dom) < sup(dom)) then {
					           myDom = [ 0, sup(dom) ];
						   oppositeOnNegative = true;
					       } else {
					           myDom = [ inf(dom), 0 ];
						   oppositeOnNegative = false;
					       };
					       evenSymmetry = res.evenSymmetry;
					       write("The subdomain after range reduction for symmetry is: ", myDom, "\n");
					       
					       /* Now call the implementer recursively on the reduced domain */
					       suffix = "_symmetrical";
					       myProblemdef = problemdef;
					       myProblemdef.dom = myDom;
					       myProblemdef.target = problemdef.target * 13/32;
					       origDefDom = dom;
					       match (problemdef) with { .definitionDomain = default } : { 
					                       if (origDefDom in problemdef.definitionDomain) then {
                                                                  origDefDom = problemdef.definitionDomain;
                                                               }; }
                                                                       default : {};
					       myProblemdef.definitionDomain = origDefDom;
					       myParametrization = parametrization;
					       myParametrization.gappaFile = parametrization.gappaFile @ suffix;
					       myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
					       myParametrization.functionBasename = parametrization.functionBasename @ suffix;
					       res = tryImplementation(myProblemdef, myParametrization);
					       
					       if (res.okay) then {
					       	  /* The implementation worked on the subdomain 

						     Now generate the reduction code.

						  */
						  symmetryCode = "";
						  symmetryCode = symmetryCode @ "\n\nvoid "@parametrization.functionBasename@"(";
						  symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                       D   : ( "double *res_resh, " )
                                                                                       DD  : ( "double *res_resh, double *res_resm, " )
                                                                                       TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                                                                );
                                                  symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                       D   : ( "double xh" )
                                                                                       DD  : ( "double xh, double xm" )
                                                                                       TD  : ( "double xh, double xm, double xl" )
                                                                                );
                                                  symmetryCode = symmetryCode @ ") {\n";
						  if (evenSymmetry) then {
						     if (oppositeOnNegative) then {
						     	symmetryCode = symmetryCode @ "if (xh < 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     } else {
						     	symmetryCode = symmetryCode @ "if (xh > 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     };
						  } else {
						     symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                          D   : ( "double sym_res_resh;" )
                                                                                          DD  : ( "double sym_res_resh, sym_res_resm;" )
                                                                                          TD  : ( "double sym_res_resh, sym_res_resm, sym_res_resl;" )
                                                                                   );
						     symmetryCode = symmetryCode @ "\n";
						     if (oppositeOnNegative) then {
						     	symmetryCode = symmetryCode @ "if (xh < 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "&sym_res_resh, " )
                                                                                             DD  : ( "&sym_res_resh, &sym_res_resm, " )
                                                                                             TD  : ( "&sym_res_resh, &sym_res_resm, &sym_res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "*res_resh = -sym_res_resh;" )
                                                                                             DD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm;" )
                                                                                             TD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm; *res_resl = -sym_res_resl;" )
                                                                                      );
						        symmetryCode = symmetryCode @ "\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     } else {
						     	symmetryCode = symmetryCode @ "if (xh > 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "&sym_res_resh, " )
                                                                                             DD  : ( "&sym_res_resh, &sym_res_resm, " )
                                                                                             TD  : ( "&sym_res_resh, &sym_res_resm, &sym_res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "*res_resh = -sym_res_resh;" )
                                                                                             DD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm;" )
                                                                                             TD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm; *res_resl = -sym_res_resl;" )
                                                                                      );
						        symmetryCode = symmetryCode @ "\n";
						     	symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
 						        symmetryCode = symmetryCode @ (match res.outputformat with 
                                          	                                             D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with 
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
							symmetryCode = symmetryCode @ ");\n";
							symmetryCode = symmetryCode @ "}\n";
						     };
						  };						  
						  symmetryCode = symmetryCode @ "}\n";
						  write(symmetryCode) >> parametrization.implementationFile;
						  result = res;
						  result.functionname = parametrization.functionBasename;
					       }; 
					    };
				       };
				       };
				     }
                default : { };

	  return result;
};


procedure tryImplementation(problemdef, parametrization) {
	  var result, res, tryImplementationInstance, tryImplementationChoices;
	  var okay;

	  result = { .okay = false };

	  tryImplementationChoices = [| tryImplementationThroughSymmetryDetectionAroundZero, tryImplementationThroughDomainSplitting |];

	  okay = false;
	  while ((!okay) && (tryImplementationChoices != [||])) do {
	          tryImplementationInstance = head(tryImplementationChoices);
		  tryImplementationChoices = tail(tryImplementationChoices);
	          res = tryImplementationInstance(problemdef, parametrization);

		  if (res.okay) then {
		     result = res;
		     okay = true;
		  };
	  };

	  return result;
};

